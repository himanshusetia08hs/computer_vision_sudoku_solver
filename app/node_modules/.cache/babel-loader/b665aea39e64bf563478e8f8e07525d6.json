{"ast":null,"code":"/**\n * @license\n * Copyright 2022 CodeSmith LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { image, serialization, tidy } from '@tensorflow/tfjs-core'; // mul, add\nimport { Layer } from '../../engine/topology';\nimport { ValueError } from '../../errors';\nimport { getExactlyOneShape } from '../../utils/types_utils'; //, getExactlyOneTensor\n// tf methods unimplemented in tfjs: 'bicubic', 'area', 'lanczos3', 'lanczos5',\n//                                   'gaussian', 'mitchellcubic'\nconst INTERPOLATION_KEYS = ['bilinear', 'nearest'];\nconst INTERPOLATION_METHODS = new Set(INTERPOLATION_KEYS);\n/**\n * Preprocessing Resizing Layer\n *\n * This resizes images by a scaling and offset factor\n */\nexport class Resizing extends Layer {\n  constructor(args) {\n    super(args);\n    this.height = args.height;\n    this.width = args.width;\n    if (args.interpolation) {\n      if (INTERPOLATION_METHODS.has(args.interpolation)) {\n        this.interpolation = args.interpolation;\n      } else {\n        throw new ValueError(`Invalid interpolation parameter: ${args.interpolation} is not implemented`);\n      }\n    } else {\n      this.interpolation = 'bilinear';\n    }\n    this.cropToAspectRatio = Boolean(args.cropToAspectRatio);\n  }\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    const numChannels = inputShape[2];\n    return [this.height, this.width, numChannels];\n  }\n  getConfig() {\n    const config = {\n      'height': this.height,\n      'width': this.width,\n      'interpolation': this.interpolation,\n      'cropToAspectRatio': this.cropToAspectRatio\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const size = [this.height, this.width];\n      if (this.interpolation === 'bilinear') {\n        return image.resizeBilinear(inputs, size, !this.cropToAspectRatio);\n      } else if (this.interpolation === 'nearest') {\n        return image.resizeNearestNeighbor(inputs, size, !this.cropToAspectRatio);\n      } else {\n        throw new Error(`Interpolation is ${this.interpolation} but only ${[...INTERPOLATION_METHODS]} are supported`);\n      }\n    });\n  }\n}\n/** @nocollapse */\nResizing.className = 'Resizing';\nserialization.registerClass(Resizing);","map":{"version":3,"sources":["../../../../../../../tfjs-layers/src/layers/preprocessing/image_resizing.ts"],"names":[],"mappings":"AAAA;;;;;;;;AAQG;AAEH,SAAQ,KAAK,EAAQ,aAAa,EAAU,IAAI,QAAO,uBAAuB,CAAC,CAAE;AAEjF,SAAQ,KAAK,QAAkB,uBAAuB;AACtD,SAAQ,UAAU,QAAO,cAAc;AAGvC,SAAQ,kBAAkB,QAAO,yBAAyB,CAAC,CAAE;AAE7D;AACA;AACA,MAAM,kBAAkB,GAAG,CAAC,UAAU,EAAE,SAAS,CAAU;AAC3D,MAAM,qBAAqB,GAAG,IAAI,GAAG,CAAC,kBAAkB,CAAC;AAUzD;;;;AAIG;AAEH,OAAM,MAAO,QAAS,SAAQ,KAAK,CAAA;EAUjC,WAAA,CAAY,IAAkB,EAAA;IAC5B,KAAK,CAAC,IAAI,CAAC;IAEX,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM;IACzB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK;IAEvB,IAAI,IAAI,CAAC,aAAa,EAAE;MACtB,IAAI,qBAAqB,CAAC,GAAG,CAAC,IAAI,CAAC,aAAa,CAAC,EAAE;QACjD,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa;OACxC,MAAM;QACL,MAAM,IAAI,UAAU,CAAC,oCACjB,IAAI,CAAC,aAAa,qBAAqB,CAAC;MAC7C;KACF,MAAM;MACL,IAAI,CAAC,aAAa,GAAG,UAAU;IAChC;IACD,IAAI,CAAC,iBAAiB,GAAG,OAAO,CAAC,IAAI,CAAC,iBAAiB,CAAC;EAC1D;EAES,kBAAkB,CAAC,UAAyB,EAAA;IACnD,UAAU,GAAG,kBAAkB,CAAC,UAAU,CAAC;IAC3C,MAAM,WAAW,GAAG,UAAU,CAAC,CAAC,CAAC;IACjC,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,EAAE,WAAW,CAAC;EAC/C;EAES,SAAS,GAAA;IAChB,MAAM,MAAM,GAA6B;MACvC,QAAQ,EAAE,IAAI,CAAC,MAAM;MACrB,OAAO,EAAE,IAAI,CAAC,KAAK;MACnB,eAAe,EAAE,IAAI,CAAC,aAAa;MACnC,mBAAmB,EAAE,IAAI,CAAC;KAC3B;IAED,MAAM,UAAU,GAAG,KAAK,CAAC,SAAS,EAAE;IACpC,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,UAAU,CAAC;IACjC,OAAO,MAAM;EACf;EAES,IAAI,CAAC,MAAuC,EAAE,MAAc,EAAA;IAEnE,OAAO,IAAI,CAAC,MAAK;MACf,MAAM,IAAI,GAAqB,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC;MACxD,IAAI,IAAI,CAAC,aAAa,KAAK,UAAU,EAAE;QACrC,OAAO,KAAK,CAAC,cAAc,CAAC,MAAM,EAAE,IAAI,EAAE,CAAC,IAAI,CAAC,iBAAiB,CAAC;OACnE,MAAM,IAAI,IAAI,CAAC,aAAa,KAAK,SAAS,EAAE;QAC3C,OAAO,KAAK,CAAC,qBAAqB,CAC9B,MAAM,EAAE,IAAI,EAAE,CAAC,IAAI,CAAC,iBAAiB,CAAC;OAC3C,MAAM;QACL,MAAM,IAAI,KAAK,CAAC,oBAAoB,IAAI,CAAC,aAAa,aAAa,CAAC,GAAG,qBAAqB,CAAC,gBAAgB,CAAC;MAC/G;IACH,CAAC,CAAC;EACJ;;AA5DA;AACO,QAAA,CAAA,SAAS,GAAG,UAAU;AA8D/B,aAAa,CAAC,aAAa,CAAC,QAAQ,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2022 CodeSmith LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\nimport {image, Rank, serialization, Tensor, tidy} from '@tensorflow/tfjs-core';  // mul, add\n\nimport {Layer, LayerArgs} from '../../engine/topology';\nimport {ValueError} from '../../errors';\nimport {Shape} from '../../keras_format/common';\nimport {Kwargs} from '../../types';\nimport {getExactlyOneShape} from '../../utils/types_utils';  //, getExactlyOneTensor\n\n// tf methods unimplemented in tfjs: 'bicubic', 'area', 'lanczos3', 'lanczos5',\n//                                   'gaussian', 'mitchellcubic'\nconst INTERPOLATION_KEYS = ['bilinear', 'nearest'] as const;\nconst INTERPOLATION_METHODS = new Set(INTERPOLATION_KEYS);\ntype InterpolationType = typeof INTERPOLATION_KEYS[number];\n\nexport declare interface ResizingArgs extends LayerArgs {\n  height: number;\n  width: number;\n  interpolation?: InterpolationType; // default = 'bilinear';\n  cropToAspectRatio?: boolean;       // default = false;\n}\n\n/**\n * Preprocessing Resizing Layer\n *\n * This resizes images by a scaling and offset factor\n */\n\nexport class Resizing extends Layer {\n  /** @nocollapse */\n  static className = 'Resizing';\n  private readonly height: number;\n  private readonly width: number;\n  // method of interpolation to be used; default = \"bilinear\";\n  private readonly interpolation: InterpolationType;\n  // toggle whether the aspect ratio should be preserved; default = false;\n  private readonly cropToAspectRatio: boolean;\n\n  constructor(args: ResizingArgs) {\n    super(args);\n\n    this.height = args.height;\n    this.width = args.width;\n\n    if (args.interpolation) {\n      if (INTERPOLATION_METHODS.has(args.interpolation)) {\n        this.interpolation = args.interpolation;\n      } else {\n        throw new ValueError(`Invalid interpolation parameter: ${\n            args.interpolation} is not implemented`);\n      }\n    } else {\n      this.interpolation = 'bilinear';\n    }\n    this.cropToAspectRatio = Boolean(args.cropToAspectRatio);\n  }\n\n  override computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    inputShape = getExactlyOneShape(inputShape);\n    const numChannels = inputShape[2];\n    return [this.height, this.width, numChannels];\n  }\n\n  override getConfig(): serialization.ConfigDict {\n    const config: serialization.ConfigDict = {\n      'height': this.height,\n      'width': this.width,\n      'interpolation': this.interpolation,\n      'cropToAspectRatio': this.cropToAspectRatio\n    };\n\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n  override call(inputs: Tensor<Rank.R3>|Tensor<Rank.R4>, kwargs: Kwargs):\n      Tensor[]|Tensor {\n    return tidy(() => {\n      const size: [number, number] = [this.height, this.width];\n      if (this.interpolation === 'bilinear') {\n        return image.resizeBilinear(inputs, size, !this.cropToAspectRatio);\n      } else if (this.interpolation === 'nearest') {\n        return image.resizeNearestNeighbor(\n            inputs, size, !this.cropToAspectRatio);\n      } else {\n        throw new Error(`Interpolation is ${this.interpolation} but only ${[...INTERPOLATION_METHODS]} are supported`);\n      }\n    });\n  }\n}\n\nserialization.registerClass(Resizing);\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}