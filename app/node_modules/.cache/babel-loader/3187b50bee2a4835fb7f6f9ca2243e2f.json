{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Slice, slice_util, util } from '@tensorflow/tfjs-core';\nimport { sliceImplCPU } from '../kernel_utils/shared';\nexport function slice(args) {\n  const {\n    inputs: {\n      x\n    },\n    attrs: {\n      begin,\n      size\n    },\n    backend\n  } = args;\n  const [begin_, size_] = slice_util.parseSliceParams(x, begin, size);\n  const isContinous = slice_util.isSliceContinous(x.shape, begin_, size_);\n  const xVals = backend.readSync(x.dataId);\n  const out = backend.makeOutput(size_, x.dtype);\n  const xStrides = util.computeStrides(x.shape);\n  const outData = backend.dataIdMap.get(out.dataId);\n  if (isContinous) {\n    const flatOffset = slice_util.computeFlatOffset(begin_, xStrides);\n    if (x.dtype === 'string') {\n      outData.stringBytes = xVals.slice(flatOffset, flatOffset + util.sizeFromShape(size_));\n    } else {\n      const outVals = backend.typedArrayFromHeap(out);\n      outVals.set(xVals.subarray(flatOffset, flatOffset + util.sizeFromShape(size_)));\n    }\n    return out;\n  }\n  if (x.dtype === 'string') {\n    const res = sliceImplCPU(xVals, begin_, size_, x.shape, x.dtype);\n    outData.stringBytes = res;\n    return out;\n  }\n  const outVals = backend.typedArrayFromHeap(out);\n  const rank = x.shape.length;\n  if (rank === 2) {\n    slice2d(xVals, xStrides[0], outVals, begin_, size_);\n  } else if (rank === 3) {\n    slice3d(xVals, xStrides[0], xStrides[1], outVals, begin_, size_);\n  } else if (rank === 4) {\n    slice4d(xVals, xStrides[0], xStrides[1], xStrides[2], outVals, begin_, size_);\n  } else {\n    const res = sliceImplCPU(xVals, begin_, size_, x.shape, x.dtype);\n    outVals.set(res);\n  }\n  return out;\n}\nfunction slice2d(xVals, xStride, outVals, begin, size) {\n  let outOffset = 0;\n  const beginI = begin[0];\n  const beginJ = begin[1];\n  const endI = beginI + size[0];\n  for (let i = beginI; i < endI; i++) {\n    const xOffset = i * xStride + beginJ;\n    outVals.set(xVals.subarray(xOffset, xOffset + size[1]), outOffset);\n    outOffset += size[1];\n  }\n}\nfunction slice3d(xVals, xStride1, xStride2, outVals, begin, size) {\n  let outOffset = 0;\n  const beginI = begin[0];\n  const beginJ = begin[1];\n  const beginK = begin[2];\n  const endI = beginI + size[0];\n  const endJ = beginJ + size[1];\n  for (let i = beginI; i < endI; i++) {\n    for (let j = beginJ; j < endJ; j++) {\n      const xOffset = i * xStride1 + j * xStride2 + beginK;\n      outVals.set(xVals.subarray(xOffset, xOffset + size[2]), outOffset);\n      outOffset += size[2];\n    }\n  }\n}\nfunction slice4d(xVals, xStride1, xStride2, xStride3, outVals, begin, size) {\n  let outOffset = 0;\n  const beginI = begin[0];\n  const beginJ = begin[1];\n  const beginK = begin[2];\n  const endI = beginI + size[0];\n  const endJ = beginJ + size[1];\n  const endK = beginK + size[2];\n  const beginL = begin[3];\n  for (let i = beginI; i < endI; i++) {\n    for (let j = beginJ; j < endJ; j++) {\n      for (let k = beginK; k < endK; k++) {\n        const xOffset = i * xStride1 + j * xStride2 + k * xStride3 + beginL;\n        outVals.set(xVals.subarray(xOffset, xOffset + size[3]), outOffset);\n        outOffset += size[3];\n      }\n    }\n  }\n}\nexport const sliceConfig = {\n  kernelName: Slice,\n  backendName: 'wasm',\n  kernelFunc: slice\n};","map":{"version":3,"sources":["../../src/kernels/Slice.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Slice, slice_util, util } from '@tensorflow/tfjs-core';\nimport { sliceImplCPU } from '../kernel_utils/shared';\nexport function slice(args) {\n    const { inputs: { x }, attrs: { begin, size }, backend } = args;\n    const [begin_, size_] = slice_util.parseSliceParams(x, begin, size);\n    const isContinous = slice_util.isSliceContinous(x.shape, begin_, size_);\n    const xVals = backend.readSync(x.dataId);\n    const out = backend.makeOutput(size_, x.dtype);\n    const xStrides = util.computeStrides(x.shape);\n    const outData = backend.dataIdMap.get(out.dataId);\n    if (isContinous) {\n        const flatOffset = slice_util.computeFlatOffset(begin_, xStrides);\n        if (x.dtype === 'string') {\n            outData.stringBytes =\n                xVals\n                    .slice(flatOffset, flatOffset + util.sizeFromShape(size_));\n        }\n        else {\n            const outVals = backend.typedArrayFromHeap(out);\n            outVals.set(xVals\n                .subarray(flatOffset, flatOffset + util.sizeFromShape(size_)));\n        }\n        return out;\n    }\n    if (x.dtype === 'string') {\n        const res = sliceImplCPU(xVals, begin_, size_, x.shape, x.dtype);\n        outData.stringBytes = res;\n        return out;\n    }\n    const outVals = backend.typedArrayFromHeap(out);\n    const rank = x.shape.length;\n    if (rank === 2) {\n        slice2d(xVals, xStrides[0], outVals, begin_, size_);\n    }\n    else if (rank === 3) {\n        slice3d(xVals, xStrides[0], xStrides[1], outVals, begin_, size_);\n    }\n    else if (rank === 4) {\n        slice4d(xVals, xStrides[0], xStrides[1], xStrides[2], outVals, begin_, size_);\n    }\n    else {\n        const res = sliceImplCPU(xVals, begin_, size_, x.shape, x.dtype);\n        outVals.set(res);\n    }\n    return out;\n}\nfunction slice2d(xVals, xStride, outVals, begin, size) {\n    let outOffset = 0;\n    const beginI = begin[0];\n    const beginJ = begin[1];\n    const endI = beginI + size[0];\n    for (let i = beginI; i < endI; i++) {\n        const xOffset = i * xStride + beginJ;\n        outVals.set(xVals.subarray(xOffset, xOffset + size[1]), outOffset);\n        outOffset += size[1];\n    }\n}\nfunction slice3d(xVals, xStride1, xStride2, outVals, begin, size) {\n    let outOffset = 0;\n    const beginI = begin[0];\n    const beginJ = begin[1];\n    const beginK = begin[2];\n    const endI = beginI + size[0];\n    const endJ = beginJ + size[1];\n    for (let i = beginI; i < endI; i++) {\n        for (let j = beginJ; j < endJ; j++) {\n            const xOffset = i * xStride1 + j * xStride2 + beginK;\n            outVals.set(xVals.subarray(xOffset, xOffset + size[2]), outOffset);\n            outOffset += size[2];\n        }\n    }\n}\nfunction slice4d(xVals, xStride1, xStride2, xStride3, outVals, begin, size) {\n    let outOffset = 0;\n    const beginI = begin[0];\n    const beginJ = begin[1];\n    const beginK = begin[2];\n    const endI = beginI + size[0];\n    const endJ = beginJ + size[1];\n    const endK = beginK + size[2];\n    const beginL = begin[3];\n    for (let i = beginI; i < endI; i++) {\n        for (let j = beginJ; j < endJ; j++) {\n            for (let k = beginK; k < endK; k++) {\n                const xOffset = i * xStride1 + j * xStride2 + k * xStride3 + beginL;\n                outVals.set(xVals.subarray(xOffset, xOffset + size[3]), outOffset);\n                outOffset += size[3];\n            }\n        }\n    }\n}\nexport const sliceConfig = {\n    kernelName: Slice,\n    backendName: 'wasm',\n    kernelFunc: slice,\n};\n//# sourceMappingURL=Slice.js.map"]},"metadata":{},"sourceType":"module"}