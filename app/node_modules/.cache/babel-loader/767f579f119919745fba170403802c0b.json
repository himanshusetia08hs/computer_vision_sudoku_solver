{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport * as tex_util from './tex_util';\nimport * as webgl_util from './webgl_util';\nexport function createVertexShader(gl) {\n  const glsl = getGlslDifferences();\n  const vertexShaderSource = `${glsl.version}\n    precision highp float;\n    ${glsl.attribute} vec3 clipSpacePos;\n    ${glsl.attribute} vec2 uv;\n    ${glsl.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;\n  return webgl_util.createVertexShader(gl, vertexShaderSource);\n}\nexport function createVertexBuffer(gl) {\n  // [x y z u v] * [upper-left, lower-left, upper-right, lower-right]\n  const vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);\n  return webgl_util.createStaticVertexBuffer(gl, vertexArray);\n}\nexport function createIndexBuffer(gl) {\n  // OpenGL (and WebGL) have \"CCW == front\" winding\n  const triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);\n  return webgl_util.createStaticIndexBuffer(gl, triangleVertexIndices);\n}\nfunction createAndConfigureTexture(gl, width, height, internalFormat, textureFormat, textureType) {\n  webgl_util.validateTextureSize(width, height);\n  const texture = webgl_util.createTexture(gl);\n  const tex2d = gl.TEXTURE_2D;\n  webgl_util.callAndCheck(gl, () => gl.bindTexture(tex2d, texture));\n  webgl_util.callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE));\n  webgl_util.callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE));\n  webgl_util.callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST));\n  webgl_util.callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST));\n  webgl_util.callAndCheck(gl, () => gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, textureFormat, textureType, null));\n  webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n  return texture;\n}\nexport function getInternalFormatForFloat32MatrixTexture(textureConfig) {\n  return textureConfig.internalFormatFloat;\n}\nexport function createFloat32MatrixTexture(gl, rows, columns, textureConfig) {\n  const [width, height] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat32MatrixTexture(textureConfig), textureConfig.textureFormatFloat, gl.FLOAT);\n}\nexport function getInternalFormatForFloat16MatrixTexture(textureConfig) {\n  return textureConfig.internalFormatHalfFloat;\n}\nexport function createFloat16MatrixTexture(gl, rows, columns, textureConfig) {\n  const [width, height] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16MatrixTexture(textureConfig), textureConfig.textureFormatFloat, textureConfig.textureTypeHalfFloat);\n}\nexport function getInternalFormatForUnsignedBytesMatrixTexture(textureConfig) {\n  return textureConfig.downloadTextureFormat;\n}\nexport function createUnsignedBytesMatrixTexture(gl, rows, columns, textureConfig) {\n  const [width, height] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(gl, width, height, getInternalFormatForUnsignedBytesMatrixTexture(textureConfig), gl.RGBA, gl.UNSIGNED_BYTE);\n}\nexport function getInternalFormatForPackedMatrixTexture(textureConfig) {\n  return textureConfig.internalFormatPackedFloat;\n}\nexport function createPackedMatrixTexture(gl, rows, columns, textureConfig) {\n  const [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(gl, width, height, getInternalFormatForPackedMatrixTexture(textureConfig), gl.RGBA, gl.FLOAT);\n}\nexport function getInternalFormatForFloat16PackedMatrixTexture(textureConfig) {\n  return textureConfig.internalFormatPackedHalfFloat;\n}\nexport function createFloat16PackedMatrixTexture(gl, rows, columns, textureConfig) {\n  const [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16PackedMatrixTexture(textureConfig), gl.RGBA, textureConfig.textureTypeHalfFloat);\n}\nexport function bindVertexProgramAttributeStreams(gl, program, vertexBuffer) {\n  const posOffset = 0; // x is the first buffer element\n  const uvOffset = 3 * 4; // uv comes after [x y z]\n  const stride = 3 * 4 + 2 * 4; // xyz + uv, each entry is 4-byte float.\n  webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer));\n  const success = webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset);\n  return success && webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'uv', vertexBuffer, 2, stride, uvOffset);\n}\nexport function uploadDenseMatrixToTexture(gl, texture, width, height, data, textureConfig) {\n  webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n  let dataForUpload, texelDataType, internalFormat;\n  if (data instanceof Uint8Array) {\n    dataForUpload = new Uint8Array(width * height * 4);\n    texelDataType = gl.UNSIGNED_BYTE;\n    internalFormat = gl.RGBA;\n  } else {\n    dataForUpload = new Float32Array(width * height * 4);\n    texelDataType = gl.FLOAT;\n    internalFormat = textureConfig.internalFormatPackedFloat;\n  }\n  dataForUpload.set(data);\n  webgl_util.callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, gl.RGBA, texelDataType, dataForUpload));\n  webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function uploadPixelDataToTexture(gl, texture, pixels) {\n  webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n  if (pixels.data instanceof Uint8Array) {\n    webgl_util.callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pixels.width, pixels.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels.data));\n  } else {\n    webgl_util.callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels));\n  }\n  webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function createBufferFromOutputTexture(gl2, rows, columns, textureConfig) {\n  // Create and bind the buffer.\n  const buffer = gl2.createBuffer();\n  webgl_util.callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer));\n  // Initialize the buffer to the size of the texture in bytes.\n  const bytesPerFloat = 4;\n  const valuesPerTexel = 4;\n  const bufferSizeBytes = bytesPerFloat * valuesPerTexel * rows * columns;\n  webgl_util.callAndCheck(gl2, () => gl2.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl2.STREAM_READ));\n  // Enqueue a command on the GPU command queue to copy of texture into the\n  // buffer.\n  webgl_util.callAndCheck(gl2, () => gl2.readPixels(0, 0, columns, rows, gl2.RGBA, gl2.FLOAT, 0));\n  webgl_util.callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null));\n  return buffer;\n}\nexport function downloadFloat32MatrixFromBuffer(gl, buffer, size) {\n  const gl2 = gl;\n  const downloadTarget = new Float32Array(size);\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n  gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n  return downloadTarget;\n}\nexport function downloadByteEncodedFloatMatrixFromOutputTexture(gl, rows, columns, textureConfig) {\n  const [w, h] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n  const numChannels = 4;\n  const downloadTarget = new Uint8Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, numChannels));\n  webgl_util.callAndCheck(gl, () => gl.readPixels(0, 0, w, h, textureConfig.downloadTextureFormat, gl.UNSIGNED_BYTE, downloadTarget));\n  // By wrapping the buffer in a Float32Array, we use native browser IEEE 754\n  // decoding of the 4 bytes that back each 32 bit float.\n  return new Float32Array(downloadTarget.buffer);\n}\nexport function downloadPackedMatrixFromBuffer(gl, buffer, batch, rows, cols, physicalRows, physicalCols, textureConfig) {\n  const gl2 = gl;\n  const downloadTarget = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(physicalRows, physicalCols));\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n  gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n  return downloadTarget;\n}\nexport function downloadMatrixFromPackedOutputTexture(gl, physicalRows, physicalCols) {\n  const packedRGBA = new Float32Array(physicalRows * physicalCols * 4);\n  webgl_util.callAndCheck(gl, () => gl.readPixels(0, 0, physicalCols, physicalRows, gl.RGBA, gl.FLOAT, packedRGBA));\n  return packedRGBA;\n}","map":{"version":3,"sources":["../src/gpgpu_util.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAIH,SAAQ,kBAAkB,QAAO,gBAAgB;AACjD,OAAO,KAAK,QAAQ,MAAM,YAAY;AAEtC,OAAO,KAAK,UAAU,MAAM,cAAc;AAE1C,OAAM,SAAU,kBAAkB,CAAC,EAAyB,EAAA;EAC1D,MAAM,IAAI,GAAG,kBAAkB,EAAE;EACjC,MAAM,kBAAkB,GAAG,GAAG,IAAI,CAAC,OAAO;;MAEtC,IAAI,CAAC,SAAS;MACd,IAAI,CAAC,SAAS;MACd,IAAI,CAAC,SAAS;;;;;MAKd;EACJ,OAAO,UAAU,CAAC,kBAAkB,CAAC,EAAE,EAAE,kBAAkB,CAAC;AAC9D;AAEA,OAAM,SAAU,kBAAkB,CAAC,EAAyB,EAAA;EAC1D;EACA,MAAM,WAAW,GAAG,IAAI,YAAY,CAChC,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;EACrE,OAAO,UAAU,CAAC,wBAAwB,CAAC,EAAE,EAAE,WAAW,CAAC;AAC7D;AAEA,OAAM,SAAU,iBAAiB,CAAC,EAAyB,EAAA;EACzD;EACA,MAAM,qBAAqB,GAAG,IAAI,WAAW,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;EACjE,OAAO,UAAU,CAAC,uBAAuB,CAAC,EAAE,EAAE,qBAAqB,CAAC;AACtE;AAEA,SAAS,yBAAyB,CAC9B,EAAyB,EAAE,KAAa,EAAE,MAAc,EACxD,cAAsB,EAAE,aAAqB,EAC7C,WAAmB,EAAA;EACrB,UAAU,CAAC,mBAAmB,CAAC,KAAK,EAAE,MAAM,CAAC;EAC7C,MAAM,OAAO,GAAG,UAAU,CAAC,aAAa,CAAC,EAAE,CAAC;EAE5C,MAAM,KAAK,GAAG,EAAE,CAAC,UAAU;EAC3B,UAAU,CAAC,YAAY,CAAC,EAAE,EAAE,MAAM,EAAE,CAAC,WAAW,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;EACjE,UAAU,CAAC,YAAY,CACnB,EAAE,EAAE,MAAM,EAAE,CAAC,aAAa,CAAC,KAAK,EAAE,EAAE,CAAC,cAAc,EAAE,EAAE,CAAC,aAAa,CAAC,CAAC;EAC3E,UAAU,CAAC,YAAY,CACnB,EAAE,EAAE,MAAM,EAAE,CAAC,aAAa,CAAC,KAAK,EAAE,EAAE,CAAC,cAAc,EAAE,EAAE,CAAC,aAAa,CAAC,CAAC;EAC3E,UAAU,CAAC,YAAY,CACnB,EAAE,EAAE,MAAM,EAAE,CAAC,aAAa,CAAC,KAAK,EAAE,EAAE,CAAC,kBAAkB,EAAE,EAAE,CAAC,OAAO,CAAC,CAAC;EACzE,UAAU,CAAC,YAAY,CACnB,EAAE,EAAE,MAAM,EAAE,CAAC,aAAa,CAAC,KAAK,EAAE,EAAE,CAAC,kBAAkB,EAAE,EAAE,CAAC,OAAO,CAAC,CAAC;EACzE,UAAU,CAAC,YAAY,CACnB,EAAE,EACF,MAAM,EAAE,CAAC,UAAU,CACf,KAAK,EAAE,CAAC,EAAE,cAAc,EAAE,KAAK,EAAE,MAAM,EAAE,CAAC,EAAE,aAAa,EACzD,WAAW,EAAE,IAAI,CAAC,CAAC;EAC3B,UAAU,CAAC,YAAY,CAAC,EAAE,EAAE,MAAM,EAAE,CAAC,WAAW,CAAC,EAAE,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;EACtE,OAAO,OAAO;AAChB;AAEA,OAAM,SAAU,wCAAwC,CACpD,aAA4B,EAAA;EAC9B,OAAO,aAAa,CAAC,mBAAmB;AAC1C;AAEA,OAAM,SAAU,0BAA0B,CACtC,EAAyB,EAAE,IAAY,EAAE,OAAe,EACxD,aAA4B,EAAA;EAC9B,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,GACjB,QAAQ,CAAC,wCAAwC,CAAC,IAAI,EAAE,OAAO,CAAC;EACpE,OAAO,yBAAyB,CAC5B,EAAE,EAAE,KAAK,EAAE,MAAM,EACjB,wCAAwC,CAAC,aAAa,CAAC,EACvD,aAAa,CAAC,kBAAkB,EAAE,EAAE,CAAC,KAAK,CAAC;AACjD;AAEA,OAAM,SAAU,wCAAwC,CACpD,aAA4B,EAAA;EAC9B,OAAO,aAAa,CAAC,uBAAuB;AAC9C;AAEA,OAAM,SAAU,0BAA0B,CACtC,EAAyB,EAAE,IAAY,EAAE,OAAe,EACxD,aAA4B,EAAA;EAC9B,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,GACjB,QAAQ,CAAC,wCAAwC,CAAC,IAAI,EAAE,OAAO,CAAC;EACpE,OAAO,yBAAyB,CAC5B,EAAE,EAAE,KAAK,EAAE,MAAM,EACjB,wCAAwC,CAAC,aAAa,CAAC,EACvD,aAAa,CAAC,kBAAkB,EAAE,aAAa,CAAC,oBAAoB,CAAC;AAC3E;AAEA,OAAM,SAAU,8CAA8C,CAC1D,aAA4B,EAAA;EAC9B,OAAO,aAAa,CAAC,qBAAqB;AAC5C;AAEA,OAAM,SAAU,gCAAgC,CAC5C,EAAyB,EAAE,IAAY,EAAE,OAAe,EACxD,aAA4B,EAAA;EAC9B,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,GACjB,QAAQ,CAAC,wCAAwC,CAAC,IAAI,EAAE,OAAO,CAAC;EACpE,OAAO,yBAAyB,CAC5B,EAAE,EAAE,KAAK,EAAE,MAAM,EACjB,8CAA8C,CAAC,aAAa,CAAC,EAAE,EAAE,CAAC,IAAI,EACtE,EAAE,CAAC,aAAa,CAAC;AACvB;AAEA,OAAM,SAAU,uCAAuC,CACnD,aAA4B,EAAA;EAC9B,OAAO,aAAa,CAAC,yBAAyB;AAChD;AAEA,OAAM,SAAU,yBAAyB,CACrC,EAAyB,EAAE,IAAY,EAAE,OAAe,EACxD,aAA4B,EAAA;EAC9B,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,GACjB,QAAQ,CAAC,sCAAsC,CAAC,IAAI,EAAE,OAAO,CAAC;EAClE,OAAO,yBAAyB,CAC5B,EAAE,EAAE,KAAK,EAAE,MAAM,EAAE,uCAAuC,CAAC,aAAa,CAAC,EACzE,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,KAAK,CAAC;AACxB;AAEA,OAAM,SAAU,8CAA8C,CAC1D,aAA4B,EAAA;EAC9B,OAAO,aAAa,CAAC,6BAA6B;AACpD;AAEA,OAAM,SAAU,gCAAgC,CAC5C,EAAyB,EAAE,IAAY,EAAE,OAAe,EACxD,aAA4B,EAAA;EAC9B,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,GACjB,QAAQ,CAAC,sCAAsC,CAAC,IAAI,EAAE,OAAO,CAAC;EAClE,OAAO,yBAAyB,CAC5B,EAAE,EAAE,KAAK,EAAE,MAAM,EACjB,8CAA8C,CAAC,aAAa,CAAC,EAAE,EAAE,CAAC,IAAI,EACtE,aAAa,CAAC,oBAAoB,CAAC;AACzC;AAEA,OAAM,SAAU,iCAAiC,CAC7C,EAAyB,EAAE,OAAqB,EAChD,YAAyB,EAAA;EAC3B,MAAM,SAAS,GAAG,CAAC,CAAC,CAAe;EACnC,MAAM,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC,CAAY;EACnC,MAAM,MAAM,GAAI,CAAC,GAAG,CAAC,GAAK,CAAC,GAAG,CAAE,CAAC,CAAE;EACnC,UAAU,CAAC,YAAY,CACnB,EAAE,EAAE,MAAM,EAAE,CAAC,UAAU,CAAC,EAAE,CAAC,YAAY,EAAE,YAAY,CAAC,CAAC;EAC3D,MAAM,OAAO,GAAG,UAAU,CAAC,kCAAkC,CACzD,EAAE,EAAE,OAAO,EAAE,cAAc,EAAE,YAAY,EAAE,CAAC,EAAE,MAAM,EAAE,SAAS,CAAC;EACpE,OAAO,OAAO,IACV,UAAU,CAAC,kCAAkC,CACzC,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,YAAY,EAAE,CAAC,EAAE,MAAM,EAAE,QAAQ,CAAC;AAC/D;AAEA,OAAM,SAAU,0BAA0B,CACtC,EAAyB,EAAE,OAAqB,EAAE,KAAa,EAC/D,MAAc,EAAE,IAAgB,EAAE,aAA4B,EAAA;EAChE,UAAU,CAAC,YAAY,CAAC,EAAE,EAAE,MAAM,EAAE,CAAC,WAAW,CAAC,EAAE,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;EAEzE,IAAI,aAAyB,EAAE,aAAqB,EAAE,cAAsB;EAC5E,IAAI,IAAI,YAAY,UAAU,EAAE;IAC9B,aAAa,GAAG,IAAI,UAAU,CAAC,KAAK,GAAG,MAAM,GAAG,CAAC,CAAC;IAClD,aAAa,GAAG,EAAE,CAAC,aAAa;IAChC,cAAc,GAAG,EAAE,CAAC,IAAI;GACzB,MAAM;IACL,aAAa,GAAG,IAAI,YAAY,CAAC,KAAK,GAAG,MAAM,GAAG,CAAC,CAAC;IACpD,aAAa,GAAG,EAAE,CAAC,KAAK;IACxB,cAAc,GAAG,aAAa,CAAC,yBAAyB;EACzD;EAED,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC;EAEvB,UAAU,CAAC,YAAY,CACnB,EAAE,EACF,MAAM,EAAE,CAAC,UAAU,CACf,EAAE,CAAC,UAAU,EAAE,CAAC,EAAE,cAAc,EAAE,KAAK,EAAE,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC,IAAI,EAC3D,aAAa,EAAE,aAAa,CAAC,CAAC;EAEtC,UAAU,CAAC,YAAY,CAAC,EAAE,EAAE,MAAM,EAAE,CAAC,WAAW,CAAC,EAAE,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;AACxE;AAEA,OAAM,SAAU,wBAAwB,CACpC,EAAyB,EAAE,OAAqB,EAChD,MACgB,EAAA;EAClB,UAAU,CAAC,YAAY,CAAC,EAAE,EAAE,MAAM,EAAE,CAAC,WAAW,CAAC,EAAE,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;EACzE,IAAK,MAAoB,CAAC,IAAI,YAAY,UAAU,EAAE;IACpD,UAAU,CAAC,YAAY,CACnB,EAAE,EACF,MAAM,EAAE,CAAC,UAAU,CACf,EAAE,CAAC,UAAU,EAAE,CAAC,EAAE,EAAE,CAAC,IAAI,EAAE,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC,IAAI,EAClE,EAAE,CAAC,aAAa,EAAG,MAAoB,CAAC,IAAI,CAAC,CAAC;GACvD,MAAM;IACL,UAAU,CAAC,YAAY,CACnB,EAAE,EACF,MAAM,EAAE,CAAC,UAAU,CACf,EAAE,CAAC,UAAU,EAAE,CAAC,EAAE,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,aAAa,EACpD,MACoB,CAAC,CAAC;EAC/B;EAED,UAAU,CAAC,YAAY,CAAC,EAAE,EAAE,MAAM,EAAE,CAAC,WAAW,CAAC,EAAE,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;AACxE;AAEA,OAAM,SAAU,6BAA6B,CACzC,GAA2B,EAAE,IAAY,EAAE,OAAe,EAC1D,aAA4B,EAAA;EAC9B;EACA,MAAM,MAAM,GAAG,GAAG,CAAC,YAAY,EAAE;EACjC,UAAU,CAAC,YAAY,CACnB,GAAG,EAAE,MAAM,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,iBAAiB,EAAE,MAAM,CAAC,CAAC;EAE7D;EACA,MAAM,aAAa,GAAG,CAAC;EACvB,MAAM,cAAc,GAAG,CAAC;EACxB,MAAM,eAAe,GAAG,aAAa,GAAG,cAAc,GAAG,IAAI,GAAG,OAAO;EAEvE,UAAU,CAAC,YAAY,CACnB,GAAG,EACH,MAAM,GAAG,CAAC,UAAU,CAChB,GAAG,CAAC,iBAAiB,EAAE,eAAe,EAAE,GAAG,CAAC,WAAW,CAAC,CAAC;EAEjE;EACA;EACA,UAAU,CAAC,YAAY,CACnB,GAAG,EAAE,MAAM,GAAG,CAAC,UAAU,CAAC,CAAC,EAAE,CAAC,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;EAE3E,UAAU,CAAC,YAAY,CACnB,GAAG,EAAE,MAAM,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,iBAAiB,EAAE,IAAI,CAAC,CAAC;EAE3D,OAAO,MAAM;AACf;AAEA,OAAM,SAAU,+BAA+B,CAC3C,EAAyB,EAAE,MAAmB,EAC9C,IAAY,EAAA;EACd,MAAM,GAAG,GAAG,EAA4B;EAExC,MAAM,cAAc,GAAG,IAAI,YAAY,CAAC,IAAI,CAAC;EAE7C,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,iBAAiB,EAAE,MAAM,CAAC;EAC7C,GAAG,CAAC,gBAAgB,CAAC,GAAG,CAAC,iBAAiB,EAAE,CAAC,EAAE,cAAc,CAAC;EAC9D,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,iBAAiB,EAAE,IAAI,CAAC;EAE3C,OAAO,cAAc;AACvB;AAEA,OAAM,SAAU,+CAA+C,CAC3D,EAAyB,EAAE,IAAY,EAAE,OAAe,EACxD,aAA4B,EAAA;EAC9B,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,GACR,QAAQ,CAAC,wCAAwC,CAAC,IAAI,EAAE,OAAO,CAAC;EAEpE,MAAM,WAAW,GAAG,CAAC;EACrB,MAAM,cAAc,GAAG,IAAI,UAAU,CACjC,QAAQ,CAAC,kCAAkC,CAAC,IAAI,GAAG,OAAO,EAAE,WAAW,CAAC,CAAC;EAE7E,UAAU,CAAC,YAAY,CACnB,EAAE,EACF,MAAM,EAAE,CAAC,UAAU,CACf,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,aAAa,CAAC,qBAAqB,EAAE,EAAE,CAAC,aAAa,EACjE,cAAc,CAAC,CAAC;EAExB;EACA;EACA,OAAO,IAAI,YAAY,CAAC,cAAc,CAAC,MAAM,CAAC;AAChD;AAEA,OAAM,SAAU,8BAA8B,CAC1C,EAAyB,EAAE,MAAmB,EAAE,KAAa,EAAE,IAAY,EAC3E,IAAY,EAAE,YAAoB,EAAE,YAAoB,EACxD,aAA4B,EAAA;EAC9B,MAAM,GAAG,GAAG,EAA4B;EAExC,MAAM,cAAc,GAChB,IAAI,YAAY,CAAC,QAAQ,CAAC,qCAAqC,CAC3D,YAAY,EAAE,YAAY,CAAC,CAAC;EAEpC,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,iBAAiB,EAAE,MAAM,CAAC;EAC7C,GAAG,CAAC,gBAAgB,CAAC,GAAG,CAAC,iBAAiB,EAAE,CAAC,EAAE,cAAc,CAAC;EAC9D,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,iBAAiB,EAAE,IAAI,CAAC;EAE3C,OAAO,cAAc;AACvB;AAEA,OAAM,SAAU,qCAAqC,CACjD,EAAyB,EAAE,YAAoB,EAC/C,YAAoB,EAAA;EACtB,MAAM,UAAU,GAAG,IAAI,YAAY,CAAC,YAAY,GAAG,YAAY,GAAG,CAAC,CAAC;EACpE,UAAU,CAAC,YAAY,CACnB,EAAE,EACF,MAAM,EAAE,CAAC,UAAU,CACf,CAAC,EAAE,CAAC,EAAE,YAAY,EAAE,YAAY,EAAE,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;EAEzE,OAAO,UAAU;AACnB","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport * as tex_util from './tex_util';\nimport * as webgl_util from './webgl_util';\nexport function createVertexShader(gl) {\n    const glsl = getGlslDifferences();\n    const vertexShaderSource = `${glsl.version}\n    precision highp float;\n    ${glsl.attribute} vec3 clipSpacePos;\n    ${glsl.attribute} vec2 uv;\n    ${glsl.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;\n    return webgl_util.createVertexShader(gl, vertexShaderSource);\n}\nexport function createVertexBuffer(gl) {\n    // [x y z u v] * [upper-left, lower-left, upper-right, lower-right]\n    const vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);\n    return webgl_util.createStaticVertexBuffer(gl, vertexArray);\n}\nexport function createIndexBuffer(gl) {\n    // OpenGL (and WebGL) have \"CCW == front\" winding\n    const triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);\n    return webgl_util.createStaticIndexBuffer(gl, triangleVertexIndices);\n}\nfunction createAndConfigureTexture(gl, width, height, internalFormat, textureFormat, textureType) {\n    webgl_util.validateTextureSize(width, height);\n    const texture = webgl_util.createTexture(gl);\n    const tex2d = gl.TEXTURE_2D;\n    webgl_util.callAndCheck(gl, () => gl.bindTexture(tex2d, texture));\n    webgl_util.callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE));\n    webgl_util.callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE));\n    webgl_util.callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST));\n    webgl_util.callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST));\n    webgl_util.callAndCheck(gl, () => gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, textureFormat, textureType, null));\n    webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n    return texture;\n}\nexport function getInternalFormatForFloat32MatrixTexture(textureConfig) {\n    return textureConfig.internalFormatFloat;\n}\nexport function createFloat32MatrixTexture(gl, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat32MatrixTexture(textureConfig), textureConfig.textureFormatFloat, gl.FLOAT);\n}\nexport function getInternalFormatForFloat16MatrixTexture(textureConfig) {\n    return textureConfig.internalFormatHalfFloat;\n}\nexport function createFloat16MatrixTexture(gl, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16MatrixTexture(textureConfig), textureConfig.textureFormatFloat, textureConfig.textureTypeHalfFloat);\n}\nexport function getInternalFormatForUnsignedBytesMatrixTexture(textureConfig) {\n    return textureConfig.downloadTextureFormat;\n}\nexport function createUnsignedBytesMatrixTexture(gl, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForUnsignedBytesMatrixTexture(textureConfig), gl.RGBA, gl.UNSIGNED_BYTE);\n}\nexport function getInternalFormatForPackedMatrixTexture(textureConfig) {\n    return textureConfig.internalFormatPackedFloat;\n}\nexport function createPackedMatrixTexture(gl, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForPackedMatrixTexture(textureConfig), gl.RGBA, gl.FLOAT);\n}\nexport function getInternalFormatForFloat16PackedMatrixTexture(textureConfig) {\n    return textureConfig.internalFormatPackedHalfFloat;\n}\nexport function createFloat16PackedMatrixTexture(gl, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16PackedMatrixTexture(textureConfig), gl.RGBA, textureConfig.textureTypeHalfFloat);\n}\nexport function bindVertexProgramAttributeStreams(gl, program, vertexBuffer) {\n    const posOffset = 0; // x is the first buffer element\n    const uvOffset = 3 * 4; // uv comes after [x y z]\n    const stride = (3 * 4) + (2 * 4); // xyz + uv, each entry is 4-byte float.\n    webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer));\n    const success = webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset);\n    return success &&\n        webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'uv', vertexBuffer, 2, stride, uvOffset);\n}\nexport function uploadDenseMatrixToTexture(gl, texture, width, height, data, textureConfig) {\n    webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n    let dataForUpload, texelDataType, internalFormat;\n    if (data instanceof Uint8Array) {\n        dataForUpload = new Uint8Array(width * height * 4);\n        texelDataType = gl.UNSIGNED_BYTE;\n        internalFormat = gl.RGBA;\n    }\n    else {\n        dataForUpload = new Float32Array(width * height * 4);\n        texelDataType = gl.FLOAT;\n        internalFormat = textureConfig.internalFormatPackedFloat;\n    }\n    dataForUpload.set(data);\n    webgl_util.callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, gl.RGBA, texelDataType, dataForUpload));\n    webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function uploadPixelDataToTexture(gl, texture, pixels) {\n    webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n    if (pixels.data instanceof Uint8Array) {\n        webgl_util.callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pixels.width, pixels.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels.data));\n    }\n    else {\n        webgl_util.callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels));\n    }\n    webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function createBufferFromOutputTexture(gl2, rows, columns, textureConfig) {\n    // Create and bind the buffer.\n    const buffer = gl2.createBuffer();\n    webgl_util.callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer));\n    // Initialize the buffer to the size of the texture in bytes.\n    const bytesPerFloat = 4;\n    const valuesPerTexel = 4;\n    const bufferSizeBytes = bytesPerFloat * valuesPerTexel * rows * columns;\n    webgl_util.callAndCheck(gl2, () => gl2.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl2.STREAM_READ));\n    // Enqueue a command on the GPU command queue to copy of texture into the\n    // buffer.\n    webgl_util.callAndCheck(gl2, () => gl2.readPixels(0, 0, columns, rows, gl2.RGBA, gl2.FLOAT, 0));\n    webgl_util.callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null));\n    return buffer;\n}\nexport function downloadFloat32MatrixFromBuffer(gl, buffer, size) {\n    const gl2 = gl;\n    const downloadTarget = new Float32Array(size);\n    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n    gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n    return downloadTarget;\n}\nexport function downloadByteEncodedFloatMatrixFromOutputTexture(gl, rows, columns, textureConfig) {\n    const [w, h] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n    const numChannels = 4;\n    const downloadTarget = new Uint8Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, numChannels));\n    webgl_util.callAndCheck(gl, () => gl.readPixels(0, 0, w, h, textureConfig.downloadTextureFormat, gl.UNSIGNED_BYTE, downloadTarget));\n    // By wrapping the buffer in a Float32Array, we use native browser IEEE 754\n    // decoding of the 4 bytes that back each 32 bit float.\n    return new Float32Array(downloadTarget.buffer);\n}\nexport function downloadPackedMatrixFromBuffer(gl, buffer, batch, rows, cols, physicalRows, physicalCols, textureConfig) {\n    const gl2 = gl;\n    const downloadTarget = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(physicalRows, physicalCols));\n    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n    gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n    return downloadTarget;\n}\nexport function downloadMatrixFromPackedOutputTexture(gl, physicalRows, physicalCols) {\n    const packedRGBA = new Float32Array(physicalRows * physicalCols * 4);\n    webgl_util.callAndCheck(gl, () => gl.readPixels(0, 0, physicalCols, physicalRows, gl.RGBA, gl.FLOAT, packedRGBA));\n    return packedRGBA;\n}\n//# sourceMappingURL=gpgpu_util.js.map"]},"metadata":{},"sourceType":"module"}