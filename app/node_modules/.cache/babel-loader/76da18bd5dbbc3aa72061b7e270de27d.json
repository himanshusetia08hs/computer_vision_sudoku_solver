{"ast":null,"code":"import { isNode } from '../../utils/is';\nimport { keywords } from '../keywords';\nimport { escape } from '../../utils/string';\nimport { forEach, join } from '../../utils/array';\nimport { toSymbol } from '../../utils/latex';\nimport { getPrecedence } from '../operators';\nimport { setSafeProperty } from '../../utils/customs';\nimport { factory } from '../../utils/factory';\nvar name = 'FunctionAssignmentNode';\nvar dependencies = ['typed', 'Node'];\nexport var createFunctionAssignmentNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    Node = _ref.Node;\n\n  /**\n   * @constructor FunctionAssignmentNode\n   * @extends {Node}\n   * Function assignment\n   *\n   * @param {string} name           Function name\n   * @param {string[] | Array.<{name: string, type: string}>} params\n   *                                Array with function parameter names, or an\n   *                                array with objects containing the name\n   *                                and type of the parameter\n   * @param {Node} expr             The function expression\n   */\n  function FunctionAssignmentNode(name, params, expr) {\n    if (!(this instanceof FunctionAssignmentNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n    if (typeof name !== 'string') throw new TypeError('String expected for parameter \"name\"');\n    if (!Array.isArray(params)) throw new TypeError('Array containing strings or objects expected for parameter \"params\"');\n    if (!isNode(expr)) throw new TypeError('Node expected for parameter \"expr\"');\n    if (name in keywords) throw new Error('Illegal function name, \"' + name + '\" is a reserved keyword');\n    this.name = name;\n    this.params = params.map(function (param) {\n      return param && param.name || param;\n    });\n    this.types = params.map(function (param) {\n      return param && param.type || 'any';\n    });\n    this.expr = expr;\n  }\n  FunctionAssignmentNode.prototype = new Node();\n  FunctionAssignmentNode.prototype.type = 'FunctionAssignmentNode';\n  FunctionAssignmentNode.prototype.isFunctionAssignmentNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  FunctionAssignmentNode.prototype._compile = function (math, argNames) {\n    var childArgNames = Object.create(argNames);\n    forEach(this.params, function (param) {\n      childArgNames[param] = true;\n    }); // compile the function expression with the child args\n\n    var evalExpr = this.expr._compile(math, childArgNames);\n    var name = this.name;\n    var params = this.params;\n    var signature = join(this.types, ',');\n    var syntax = name + '(' + join(this.params, ', ') + ')';\n    return function evalFunctionAssignmentNode(scope, args, context) {\n      var signatures = {};\n      signatures[signature] = function () {\n        var childArgs = Object.create(args);\n        for (var i = 0; i < params.length; i++) {\n          childArgs[params[i]] = arguments[i];\n        }\n        return evalExpr(scope, childArgs, context);\n      };\n      var fn = typed(name, signatures);\n      fn.syntax = syntax;\n      setSafeProperty(scope, name, fn);\n      return fn;\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n  FunctionAssignmentNode.prototype.forEach = function (callback) {\n    callback(this.expr, 'expr', this);\n  };\n  /**\n   * Create a new FunctionAssignmentNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {FunctionAssignmentNode} Returns a transformed copy of the node\n   */\n\n  FunctionAssignmentNode.prototype.map = function (callback) {\n    var expr = this._ifNode(callback(this.expr, 'expr', this));\n    return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {FunctionAssignmentNode}\n   */\n\n  FunctionAssignmentNode.prototype.clone = function () {\n    return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);\n  };\n  /**\n   * Is parenthesis needed?\n   * @param {Node} node\n   * @param {Object} parenthesis\n   * @private\n   */\n\n  function needParenthesis(node, parenthesis) {\n    var precedence = getPrecedence(node, parenthesis);\n    var exprPrecedence = getPrecedence(node.expr, parenthesis);\n    return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;\n  }\n  /**\n   * get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  FunctionAssignmentNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var expr = this.expr.toString(options);\n    if (needParenthesis(this, parenthesis)) {\n      expr = '(' + expr + ')';\n    }\n    return this.name + '(' + this.params.join(', ') + ') = ' + expr;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n  FunctionAssignmentNode.prototype.toJSON = function () {\n    var types = this.types;\n    return {\n      mathjs: 'FunctionAssignmentNode',\n      name: this.name,\n      params: this.params.map(function (param, index) {\n        return {\n          name: param,\n          type: types[index]\n        };\n      }),\n      expr: this.expr\n    };\n  };\n  /**\n   * Instantiate an FunctionAssignmentNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"FunctionAssignmentNode\", name: ..., params: ..., expr: ...}`,\n   *                       where mathjs is optional\n   * @returns {FunctionAssignmentNode}\n   */\n\n  FunctionAssignmentNode.fromJSON = function (json) {\n    return new FunctionAssignmentNode(json.name, json.params, json.expr);\n  };\n  /**\n   * get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  FunctionAssignmentNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var params = [];\n    for (var i = 0; i < this.params.length; i++) {\n      params.push('<span class=\"math-symbol math-parameter\">' + escape(this.params[i]) + '</span>');\n    }\n    var expr = this.expr.toHTML(options);\n    if (needParenthesis(this, parenthesis)) {\n      expr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + expr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n    return '<span class=\"math-function\">' + escape(this.name) + '</span>' + '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + params.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-round-parenthesis\">)</span><span class=\"math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator\">=</span>' + expr;\n  };\n  /**\n   * get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  FunctionAssignmentNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var expr = this.expr.toTex(options);\n    if (needParenthesis(this, parenthesis)) {\n      expr = \"\\\\left(\".concat(expr, \"\\\\right)\");\n    }\n    return '\\\\mathrm{' + this.name + '}\\\\left(' + this.params.map(toSymbol).join(',') + '\\\\right):=' + expr;\n  };\n  return FunctionAssignmentNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["isNode","keywords","escape","forEach","join","toSymbol","getPrecedence","setSafeProperty","factory","name","dependencies","createFunctionAssignmentNode","_ref","typed","Node","FunctionAssignmentNode","params","expr","SyntaxError","TypeError","Array","isArray","Error","map","param","types","type","prototype","isFunctionAssignmentNode","_compile","math","argNames","childArgNames","Object","create","evalExpr","signature","syntax","evalFunctionAssignmentNode","scope","args","context","signatures","childArgs","i","length","arguments","fn","callback","_ifNode","slice","clone","needParenthesis","node","parenthesis","precedence","exprPrecedence","_toString","options","toString","toJSON","mathjs","index","fromJSON","json","toHTML","push","_toTex","toTex","concat","isClass"],"sources":["F:/extension/SEM 7/NN/Lab/my lab/Project/temp/app/node_modules/mathjs/es/expression/node/FunctionAssignmentNode.js"],"sourcesContent":["import { isNode } from '../../utils/is';\nimport { keywords } from '../keywords';\nimport { escape } from '../../utils/string';\nimport { forEach, join } from '../../utils/array';\nimport { toSymbol } from '../../utils/latex';\nimport { getPrecedence } from '../operators';\nimport { setSafeProperty } from '../../utils/customs';\nimport { factory } from '../../utils/factory';\nvar name = 'FunctionAssignmentNode';\nvar dependencies = ['typed', 'Node'];\nexport var createFunctionAssignmentNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      Node = _ref.Node;\n\n  /**\n   * @constructor FunctionAssignmentNode\n   * @extends {Node}\n   * Function assignment\n   *\n   * @param {string} name           Function name\n   * @param {string[] | Array.<{name: string, type: string}>} params\n   *                                Array with function parameter names, or an\n   *                                array with objects containing the name\n   *                                and type of the parameter\n   * @param {Node} expr             The function expression\n   */\n  function FunctionAssignmentNode(name, params, expr) {\n    if (!(this instanceof FunctionAssignmentNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // validate input\n\n\n    if (typeof name !== 'string') throw new TypeError('String expected for parameter \"name\"');\n    if (!Array.isArray(params)) throw new TypeError('Array containing strings or objects expected for parameter \"params\"');\n    if (!isNode(expr)) throw new TypeError('Node expected for parameter \"expr\"');\n    if (name in keywords) throw new Error('Illegal function name, \"' + name + '\" is a reserved keyword');\n    this.name = name;\n    this.params = params.map(function (param) {\n      return param && param.name || param;\n    });\n    this.types = params.map(function (param) {\n      return param && param.type || 'any';\n    });\n    this.expr = expr;\n  }\n\n  FunctionAssignmentNode.prototype = new Node();\n  FunctionAssignmentNode.prototype.type = 'FunctionAssignmentNode';\n  FunctionAssignmentNode.prototype.isFunctionAssignmentNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  FunctionAssignmentNode.prototype._compile = function (math, argNames) {\n    var childArgNames = Object.create(argNames);\n    forEach(this.params, function (param) {\n      childArgNames[param] = true;\n    }); // compile the function expression with the child args\n\n    var evalExpr = this.expr._compile(math, childArgNames);\n\n    var name = this.name;\n    var params = this.params;\n    var signature = join(this.types, ',');\n    var syntax = name + '(' + join(this.params, ', ') + ')';\n    return function evalFunctionAssignmentNode(scope, args, context) {\n      var signatures = {};\n\n      signatures[signature] = function () {\n        var childArgs = Object.create(args);\n\n        for (var i = 0; i < params.length; i++) {\n          childArgs[params[i]] = arguments[i];\n        }\n\n        return evalExpr(scope, childArgs, context);\n      };\n\n      var fn = typed(name, signatures);\n      fn.syntax = syntax;\n      setSafeProperty(scope, name, fn);\n      return fn;\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  FunctionAssignmentNode.prototype.forEach = function (callback) {\n    callback(this.expr, 'expr', this);\n  };\n  /**\n   * Create a new FunctionAssignmentNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {FunctionAssignmentNode} Returns a transformed copy of the node\n   */\n\n\n  FunctionAssignmentNode.prototype.map = function (callback) {\n    var expr = this._ifNode(callback(this.expr, 'expr', this));\n\n    return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {FunctionAssignmentNode}\n   */\n\n\n  FunctionAssignmentNode.prototype.clone = function () {\n    return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);\n  };\n  /**\n   * Is parenthesis needed?\n   * @param {Node} node\n   * @param {Object} parenthesis\n   * @private\n   */\n\n\n  function needParenthesis(node, parenthesis) {\n    var precedence = getPrecedence(node, parenthesis);\n    var exprPrecedence = getPrecedence(node.expr, parenthesis);\n    return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;\n  }\n  /**\n   * get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionAssignmentNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var expr = this.expr.toString(options);\n\n    if (needParenthesis(this, parenthesis)) {\n      expr = '(' + expr + ')';\n    }\n\n    return this.name + '(' + this.params.join(', ') + ') = ' + expr;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  FunctionAssignmentNode.prototype.toJSON = function () {\n    var types = this.types;\n    return {\n      mathjs: 'FunctionAssignmentNode',\n      name: this.name,\n      params: this.params.map(function (param, index) {\n        return {\n          name: param,\n          type: types[index]\n        };\n      }),\n      expr: this.expr\n    };\n  };\n  /**\n   * Instantiate an FunctionAssignmentNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"FunctionAssignmentNode\", name: ..., params: ..., expr: ...}`,\n   *                       where mathjs is optional\n   * @returns {FunctionAssignmentNode}\n   */\n\n\n  FunctionAssignmentNode.fromJSON = function (json) {\n    return new FunctionAssignmentNode(json.name, json.params, json.expr);\n  };\n  /**\n   * get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionAssignmentNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var params = [];\n\n    for (var i = 0; i < this.params.length; i++) {\n      params.push('<span class=\"math-symbol math-parameter\">' + escape(this.params[i]) + '</span>');\n    }\n\n    var expr = this.expr.toHTML(options);\n\n    if (needParenthesis(this, parenthesis)) {\n      expr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + expr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n    }\n\n    return '<span class=\"math-function\">' + escape(this.name) + '</span>' + '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + params.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-round-parenthesis\">)</span><span class=\"math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator\">=</span>' + expr;\n  };\n  /**\n   * get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  FunctionAssignmentNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var expr = this.expr.toTex(options);\n\n    if (needParenthesis(this, parenthesis)) {\n      expr = \"\\\\left(\".concat(expr, \"\\\\right)\");\n    }\n\n    return '\\\\mathrm{' + this.name + '}\\\\left(' + this.params.map(toSymbol).join(',') + '\\\\right):=' + expr;\n  };\n\n  return FunctionAssignmentNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}