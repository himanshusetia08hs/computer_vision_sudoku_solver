{"ast":null,"code":"import { contains } from './array';\nimport { pickShallow } from './object';\n/**\n * Create a factory function, which can be used to inject dependencies.\n *\n * The created functions are memoized, a consecutive call of the factory\n * with the exact same inputs will return the same function instance.\n * The memoized cache is exposed on `factory.cache` and can be cleared\n * if needed.\n *\n * Example:\n *\n *     const name = 'log'\n *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']\n *\n *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {\n *       // ... create the function log here and return it\n *     }\n *\n * @param {string} name           Name of the function to be created\n * @param {string[]} dependencies The names of all required dependencies\n * @param {function} create       Callback function called with an object with all dependencies\n * @param {Object} [meta]         Optional object with meta information that will be attached\n *                                to the created factory function as property `meta`.\n * @returns {function}\n */\n\nexport function factory(name, dependencies, create, meta) {\n  function assertAndCreate(scope) {\n    // we only pass the requested dependencies to the factory function\n    // to prevent functions to rely on dependencies that are not explicitly\n    // requested.\n    var deps = pickShallow(scope, dependencies.map(stripOptionalNotation));\n    assertDependencies(name, dependencies, scope);\n    return create(deps);\n  }\n  assertAndCreate.isFactory = true;\n  assertAndCreate.fn = name;\n  assertAndCreate.dependencies = dependencies.slice().sort();\n  if (meta) {\n    assertAndCreate.meta = meta;\n  }\n  return assertAndCreate;\n}\n/**\n * Sort all factories such that when loading in order, the dependencies are resolved.\n *\n * @param {Array} factories\n * @returns {Array} Returns a new array with the sorted factories.\n */\n\nexport function sortFactories(factories) {\n  var factoriesByName = {};\n  factories.forEach(function (factory) {\n    factoriesByName[factory.fn] = factory;\n  });\n  function containsDependency(factory, dependency) {\n    // TODO: detect circular references\n    if (isFactory(factory)) {\n      if (contains(factory.dependencies, dependency.fn || dependency.name)) {\n        return true;\n      }\n      if (factory.dependencies.some(function (d) {\n        return containsDependency(factoriesByName[d], dependency);\n      })) {\n        return true;\n      }\n    }\n    return false;\n  }\n  var sorted = [];\n  function addFactory(factory) {\n    var index = 0;\n    while (index < sorted.length && !containsDependency(sorted[index], factory)) {\n      index++;\n    }\n    sorted.splice(index, 0, factory);\n  } // sort regular factory functions\n\n  factories.filter(isFactory).forEach(addFactory); // sort legacy factory functions AFTER the regular factory functions\n\n  factories.filter(function (factory) {\n    return !isFactory(factory);\n  }).forEach(addFactory);\n  return sorted;\n} // TODO: comment or cleanup if unused in the end\n\nexport function create(factories) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  sortFactories(factories).forEach(function (factory) {\n    return factory(scope);\n  });\n  return scope;\n}\n/**\n * Test whether an object is a factory. This is the case when it has\n * properties name, dependencies, and a function create.\n * @param {*} obj\n * @returns {boolean}\n */\n\nexport function isFactory(obj) {\n  return typeof obj === 'function' && typeof obj.fn === 'string' && Array.isArray(obj.dependencies);\n}\n/**\n * Assert that all dependencies of a list with dependencies are available in the provided scope.\n *\n * Will throw an exception when there are dependencies missing.\n *\n * @param {string} name   Name for the function to be created. Used to generate a useful error message\n * @param {string[]} dependencies\n * @param {Object} scope\n */\n\nexport function assertDependencies(name, dependencies, scope) {\n  var allDefined = dependencies.filter(function (dependency) {\n    return !isOptionalDependency(dependency);\n  }) // filter optionals\n  .every(function (dependency) {\n    return scope[dependency] !== undefined;\n  });\n  if (!allDefined) {\n    var missingDependencies = dependencies.filter(function (dependency) {\n      return scope[dependency] === undefined;\n    }); // TODO: create a custom error class for this, a MathjsError or something like that\n\n    throw new Error(\"Cannot create function \\\"\".concat(name, \"\\\", \") + \"some dependencies are missing: \".concat(missingDependencies.map(function (d) {\n      return \"\\\"\".concat(d, \"\\\"\");\n    }).join(', '), \".\"));\n  }\n}\nexport function isOptionalDependency(dependency) {\n  return dependency && dependency[0] === '?';\n}\nexport function stripOptionalNotation(dependency) {\n  return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;\n}","map":{"version":3,"names":["contains","pickShallow","factory","name","dependencies","create","meta","assertAndCreate","scope","deps","map","stripOptionalNotation","assertDependencies","isFactory","fn","slice","sort","sortFactories","factories","factoriesByName","forEach","containsDependency","dependency","some","d","sorted","addFactory","index","length","splice","filter","arguments","undefined","obj","Array","isArray","allDefined","isOptionalDependency","every","missingDependencies","Error","concat","join"],"sources":["F:/extension/SEM 7/NN/Lab/my lab/P/temp/app/node_modules/mathjs/es/utils/factory.js"],"sourcesContent":["import { contains } from './array';\nimport { pickShallow } from './object';\n/**\n * Create a factory function, which can be used to inject dependencies.\n *\n * The created functions are memoized, a consecutive call of the factory\n * with the exact same inputs will return the same function instance.\n * The memoized cache is exposed on `factory.cache` and can be cleared\n * if needed.\n *\n * Example:\n *\n *     const name = 'log'\n *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']\n *\n *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {\n *       // ... create the function log here and return it\n *     }\n *\n * @param {string} name           Name of the function to be created\n * @param {string[]} dependencies The names of all required dependencies\n * @param {function} create       Callback function called with an object with all dependencies\n * @param {Object} [meta]         Optional object with meta information that will be attached\n *                                to the created factory function as property `meta`.\n * @returns {function}\n */\n\nexport function factory(name, dependencies, create, meta) {\n  function assertAndCreate(scope) {\n    // we only pass the requested dependencies to the factory function\n    // to prevent functions to rely on dependencies that are not explicitly\n    // requested.\n    var deps = pickShallow(scope, dependencies.map(stripOptionalNotation));\n    assertDependencies(name, dependencies, scope);\n    return create(deps);\n  }\n\n  assertAndCreate.isFactory = true;\n  assertAndCreate.fn = name;\n  assertAndCreate.dependencies = dependencies.slice().sort();\n\n  if (meta) {\n    assertAndCreate.meta = meta;\n  }\n\n  return assertAndCreate;\n}\n/**\n * Sort all factories such that when loading in order, the dependencies are resolved.\n *\n * @param {Array} factories\n * @returns {Array} Returns a new array with the sorted factories.\n */\n\nexport function sortFactories(factories) {\n  var factoriesByName = {};\n  factories.forEach(function (factory) {\n    factoriesByName[factory.fn] = factory;\n  });\n\n  function containsDependency(factory, dependency) {\n    // TODO: detect circular references\n    if (isFactory(factory)) {\n      if (contains(factory.dependencies, dependency.fn || dependency.name)) {\n        return true;\n      }\n\n      if (factory.dependencies.some(function (d) {\n        return containsDependency(factoriesByName[d], dependency);\n      })) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var sorted = [];\n\n  function addFactory(factory) {\n    var index = 0;\n\n    while (index < sorted.length && !containsDependency(sorted[index], factory)) {\n      index++;\n    }\n\n    sorted.splice(index, 0, factory);\n  } // sort regular factory functions\n\n\n  factories.filter(isFactory).forEach(addFactory); // sort legacy factory functions AFTER the regular factory functions\n\n  factories.filter(function (factory) {\n    return !isFactory(factory);\n  }).forEach(addFactory);\n  return sorted;\n} // TODO: comment or cleanup if unused in the end\n\nexport function create(factories) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  sortFactories(factories).forEach(function (factory) {\n    return factory(scope);\n  });\n  return scope;\n}\n/**\n * Test whether an object is a factory. This is the case when it has\n * properties name, dependencies, and a function create.\n * @param {*} obj\n * @returns {boolean}\n */\n\nexport function isFactory(obj) {\n  return typeof obj === 'function' && typeof obj.fn === 'string' && Array.isArray(obj.dependencies);\n}\n/**\n * Assert that all dependencies of a list with dependencies are available in the provided scope.\n *\n * Will throw an exception when there are dependencies missing.\n *\n * @param {string} name   Name for the function to be created. Used to generate a useful error message\n * @param {string[]} dependencies\n * @param {Object} scope\n */\n\nexport function assertDependencies(name, dependencies, scope) {\n  var allDefined = dependencies.filter(function (dependency) {\n    return !isOptionalDependency(dependency);\n  }) // filter optionals\n  .every(function (dependency) {\n    return scope[dependency] !== undefined;\n  });\n\n  if (!allDefined) {\n    var missingDependencies = dependencies.filter(function (dependency) {\n      return scope[dependency] === undefined;\n    }); // TODO: create a custom error class for this, a MathjsError or something like that\n\n    throw new Error(\"Cannot create function \\\"\".concat(name, \"\\\", \") + \"some dependencies are missing: \".concat(missingDependencies.map(function (d) {\n      return \"\\\"\".concat(d, \"\\\"\");\n    }).join(', '), \".\"));\n  }\n}\nexport function isOptionalDependency(dependency) {\n  return dependency && dependency[0] === '?';\n}\nexport function stripOptionalNotation(dependency) {\n  return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}