{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * LruCache: A mapping from the String to T. If the number of the entries is\n * exceeding the `maxEntries`, the LruCache will delete the least recently\n * used entry.\n */\nexport class LruCache {\n  constructor(maxEntries) {\n    this.maxEntries = maxEntries || 100;\n    this.cache = new Map();\n  }\n  /**\n   * Get the entry for the key and mark it as used recently.\n   */\n  get(key) {\n    let entry;\n    if (this.cache.has(key)) {\n      entry = this.cache.get(key);\n      this.cache.delete(key);\n      this.cache.set(key, entry);\n    }\n    return entry;\n  }\n  /**\n   * Put the entry into the cache. If the key already existed, mark the key as\n   * used recently.\n   */\n  put(key, value) {\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    } else if (this.cache.size >= this.maxEntries) {\n      const keyToDelete = this.cache.keys().next().value;\n      this.cache.delete(keyToDelete);\n    }\n    this.cache.set(key, value);\n  }\n  /**\n   * Get the MaxEntries of the cache.\n   */\n  getMaxEntries() {\n    return this.maxEntries;\n  }\n  /**\n   * Set the MaxEntries of the cache. If the maxEntries is decreased, reduce\n   * entries in the cache.\n   */\n  setMaxEntries(maxEntries) {\n    if (maxEntries < 0) {\n      throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${maxEntries}.`);\n    }\n    if (this.maxEntries > maxEntries) {\n      for (let i = 0; i < this.maxEntries - maxEntries; i++) {\n        const keyToDelete = this.cache.keys().next().value;\n        this.cache.delete(keyToDelete);\n      }\n    }\n    this.maxEntries = maxEntries;\n  }\n}","map":{"version":3,"sources":["../../../../../../tfjs-layers/src/utils/executor_utils.ts"],"names":[],"mappings":"AAAA;;;;;;;;AAQG;AACH;;;;AAIG;AAEH,OAAM,MAAO,QAAQ,CAAA;EAInB,WAAA,CAAY,UAAmB,EAAA;IAC7B,IAAI,CAAC,UAAU,GAAG,UAAU,IAAI,GAAG;IACnC,IAAI,CAAC,KAAK,GAAG,IAAI,GAAG,EAAa;EACnC;EAEA;;AAEG;EACI,GAAG,CAAC,GAAW,EAAA;IACpB,IAAI,KAAQ;IACZ,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;MACvB,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC;MAC3B,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC;MACtB,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC;IAC3B;IACD,OAAO,KAAK;EACd;EAEA;;;AAGG;EACI,GAAG,CAAC,GAAW,EAAE,KAAQ,EAAA;IAC9B,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;MACvB,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC;KACvB,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,IAAI,IAAI,CAAC,UAAU,EAAE;MAC7C,MAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,KAAK;MAClD,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,WAAW,CAAC;IAC/B;IACD,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC;EAC5B;EAEA;;AAEG;EACI,aAAa,GAAA;IAClB,OAAO,IAAI,CAAC,UAAU;EACxB;EAEA;;;AAGG;EACI,aAAa,CAAC,UAAkB,EAAA;IACrC,IAAI,UAAU,GAAG,CAAC,EAAE;MAClB,MAAM,IAAI,KAAK,CACX,4DACI,UAAU,GAAG,CAAC;IACvB;IAED,IAAI,IAAI,CAAC,UAAU,GAAG,UAAU,EAAE;MAChC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,UAAU,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE;QACrD,MAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,KAAK;QAClD,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,WAAW,CAAC;MAC/B;IACF;IAED,IAAI,CAAC,UAAU,GAAG,UAAU;EAC9B;AACD","sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * LruCache: A mapping from the String to T. If the number of the entries is\n * exceeding the `maxEntries`, the LruCache will delete the least recently\n * used entry.\n */\n\nexport class LruCache<T> {\n  private cache: Map<string, T>;\n  private maxEntries: number;\n\n  constructor(maxEntries?: number) {\n    this.maxEntries = maxEntries || 100;\n    this.cache = new Map<string, T>();\n  }\n\n  /**\n   * Get the entry for the key and mark it as used recently.\n   */\n  public get(key: string): T {\n    let entry: T;\n    if (this.cache.has(key)) {\n      entry = this.cache.get(key);\n      this.cache.delete(key);\n      this.cache.set(key, entry);\n    }\n    return entry;\n  }\n\n  /**\n   * Put the entry into the cache. If the key already existed, mark the key as\n   * used recently.\n   */\n  public put(key: string, value: T): void {\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    } else if (this.cache.size >= this.maxEntries) {\n      const keyToDelete = this.cache.keys().next().value;\n      this.cache.delete(keyToDelete);\n    }\n    this.cache.set(key, value);\n  }\n\n  /**\n   * Get the MaxEntries of the cache.\n   */\n  public getMaxEntries(): number {\n    return this.maxEntries;\n  }\n\n  /**\n   * Set the MaxEntries of the cache. If the maxEntries is decreased, reduce\n   * entries in the cache.\n   */\n  public setMaxEntries(maxEntries: number): void {\n    if (maxEntries < 0) {\n      throw new Error(\n          `The maxEntries of LRU caches must be at least 0, but got ${\n              maxEntries}.`);\n    }\n\n    if (this.maxEntries > maxEntries) {\n      for (let i = 0; i < this.maxEntries - maxEntries; i++) {\n        const keyToDelete = this.cache.keys().next().value;\n        this.cache.delete(keyToDelete);\n      }\n    }\n\n    this.maxEntries = maxEntries;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}