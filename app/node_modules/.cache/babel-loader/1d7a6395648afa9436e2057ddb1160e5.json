{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, SparseReshape, util } from '@tensorflow/tfjs-core';\nlet wasmSparseReshape;\nfunction setup(backend) {\n  wasmSparseReshape = backend.wasm.cwrap(SparseReshape, null /*void*/, ['number', 'number', 'number', 'number', 'number', 'number', 'number' // exceptionValuesId\n  ]);\n}\n\nfunction sparseReshape(args) {\n  const {\n    backend,\n    inputs\n  } = args;\n  const {\n    inputIndices,\n    inputShape,\n    newShape\n  } = inputs;\n  if (inputIndices.shape.length !== 2) {\n    throw new Error(`Input indices should be a matrix but received shape\n        ${inputIndices.shape}`);\n  }\n  if (inputShape.shape.length !== 1) {\n    throw new Error(`Input shape should be a vector but received shape\n        ${inputShape.shape}`);\n  }\n  if (newShape.shape.length !== 1) {\n    throw new Error(`Target shape should be a vector but received shape ${newShape.shape}`);\n  }\n  const inputIndicesId = backend.dataIdMap.get(inputIndices.dataId).id;\n  const inputShapeId = backend.dataIdMap.get(inputShape.dataId).id;\n  const newShapeId = backend.dataIdMap.get(newShape.dataId).id;\n  const nnz = inputIndices.shape[0];\n  const outputRank = util.sizeFromShape(newShape.shape);\n  const newIndices = backend.makeOutput([nnz, outputRank], inputIndices.dtype);\n  const newIndicesId = backend.dataIdMap.get(newIndices.dataId).id;\n  const outputShape = backend.makeOutput([outputRank], newShape.dtype);\n  const outputShapeId = backend.dataIdMap.get(outputShape.dataId).id;\n  const exceptionValues = backend.makeOutput([3], 'int32');\n  const exceptionValuesId = backend.dataIdMap.get(exceptionValues.dataId).id;\n  wasmSparseReshape(inputIndicesId, inputShapeId, newShapeId, nnz, newIndicesId, outputShapeId, exceptionValuesId);\n  const exceptionValuesArray = backend.readSync(exceptionValues.dataId);\n  let exceptionMessage;\n  switch (exceptionValuesArray[0]) {\n    case 0:\n      {\n        exceptionMessage = backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(exceptionValuesArray[1], exceptionValuesArray[2]);\n        break;\n      }\n    case 1:\n      {\n        exceptionMessage = backend_util.getSparseReshapeNegativeOutputDimErrorMessage(exceptionValuesArray[1], exceptionValuesArray[2]);\n        break;\n      }\n    case 2:\n      exceptionMessage = backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();\n      break;\n    case 3:\n      {\n        const inputShapeValues = Array.from(backend.readSync(inputShape.dataId)),\n          outputShapeValues = Array.from(backend.readSync(outputShape.dataId));\n        exceptionMessage = backend_util.getSparseReshapeInputOutputMultipleErrorMessage(inputShapeValues, outputShapeValues);\n        break;\n      }\n    case 4:\n      {\n        const inputShapeValues = Array.from(backend.readSync(inputShape.dataId)),\n          outputShapeValues = Array.from(backend.readSync(outputShape.dataId));\n        exceptionMessage = backend_util.getSparseReshapeInputOutputMismatchErrorMessage(inputShapeValues, outputShapeValues);\n        break;\n      }\n    default:\n      exceptionMessage = '';\n  }\n  backend.disposeData(exceptionValues.dataId);\n  if (exceptionMessage) {\n    backend.disposeData(newIndices.dataId);\n    backend.disposeData(outputShape.dataId);\n    throw new Error(exceptionMessage);\n  }\n  return [newIndices, outputShape];\n}\nexport const sparseReshapeConfig = {\n  kernelName: SparseReshape,\n  backendName: 'wasm',\n  setupFunc: setup,\n  kernelFunc: sparseReshape\n};","map":{"version":3,"sources":["../../../../../../tfjs-backend-wasm/src/kernels/SparseReshape.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, KernelFunc, SparseReshape, SparseReshapeInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {BackendWasm} from '../backend_wasm';\n\nlet wasmSparseReshape: (\n    inputIndicesId: number, inputShapeId: number, newShapeId: number,\n    nnz: number, newIndicesId: number, outputShapeId: number,\n    exceptionValuesId: number) => void;\n\nfunction setup(backend: BackendWasm): void {\n  wasmSparseReshape = backend.wasm.cwrap(SparseReshape, null /*void*/, [\n    'number',  // inputIndicesId\n    'number',  // inputShapeId\n    'number',  // newShapeId\n    'number',  // nnz\n    'number',  // newIndicesId\n    'number',  // outputShapeId\n    'number',  // exceptionValuesId\n  ]);\n}\n\nfunction sparseReshape(args: {\n  backend: BackendWasm,\n  inputs: SparseReshapeInputs,\n}): [TensorInfo, TensorInfo] {\n  const {backend, inputs} = args;\n  const {inputIndices, inputShape, newShape} = inputs;\n\n  if (inputIndices.shape.length !== 2) {\n    throw new Error(`Input indices should be a matrix but received shape\n        ${inputIndices.shape}`);\n  }\n  if (inputShape.shape.length !== 1) {\n    throw new Error(`Input shape should be a vector but received shape\n        ${inputShape.shape}`);\n  }\n  if (newShape.shape.length !== 1) {\n    throw new Error(\n        `Target shape should be a vector but received shape ${newShape.shape}`);\n  }\n\n  const inputIndicesId = backend.dataIdMap.get(inputIndices.dataId).id;\n  const inputShapeId = backend.dataIdMap.get(inputShape.dataId).id;\n  const newShapeId = backend.dataIdMap.get(newShape.dataId).id;\n\n  const nnz = inputIndices.shape[0];\n  const outputRank = util.sizeFromShape(newShape.shape);\n\n  const newIndices = backend.makeOutput([nnz, outputRank], inputIndices.dtype);\n  const newIndicesId = backend.dataIdMap.get(newIndices.dataId).id;\n\n  const outputShape = backend.makeOutput([outputRank], newShape.dtype);\n  const outputShapeId = backend.dataIdMap.get(outputShape.dataId).id;\n\n  const exceptionValues = backend.makeOutput([3], 'int32');\n  const exceptionValuesId = backend.dataIdMap.get(exceptionValues.dataId).id;\n\n  wasmSparseReshape(\n      inputIndicesId, inputShapeId, newShapeId, nnz, newIndicesId,\n      outputShapeId, exceptionValuesId);\n\n  const exceptionValuesArray =\n      backend.readSync(exceptionValues.dataId) as Int32Array;\n\n  let exceptionMessage: string;\n  switch (exceptionValuesArray[0]) {\n    case 0: {\n      exceptionMessage =\n          backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(\n              exceptionValuesArray[1], exceptionValuesArray[2]);\n      break;\n    }\n    case 1: {\n      exceptionMessage =\n          backend_util.getSparseReshapeNegativeOutputDimErrorMessage(\n              exceptionValuesArray[1], exceptionValuesArray[2]);\n      break;\n    }\n    case 2:\n      exceptionMessage =\n          backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();\n      break;\n    case 3: {\n      const inputShapeValues =\n          Array.from(backend.readSync(inputShape.dataId) as Int32Array),\n            outputShapeValues =\n                Array.from(backend.readSync(outputShape.dataId) as Int32Array);\n      exceptionMessage =\n          backend_util.getSparseReshapeInputOutputMultipleErrorMessage(\n              inputShapeValues, outputShapeValues);\n      break;\n    }\n    case 4: {\n      const inputShapeValues =\n          Array.from(backend.readSync(inputShape.dataId) as Int32Array),\n            outputShapeValues =\n                Array.from(backend.readSync(outputShape.dataId) as Int32Array);\n      exceptionMessage =\n          backend_util.getSparseReshapeInputOutputMismatchErrorMessage(\n              inputShapeValues, outputShapeValues);\n      break;\n    }\n    default:\n      exceptionMessage = '';\n  }\n\n  backend.disposeData(exceptionValues.dataId);\n  if (exceptionMessage) {\n    backend.disposeData(newIndices.dataId);\n    backend.disposeData(outputShape.dataId);\n    throw new Error(exceptionMessage);\n  }\n\n  return [newIndices, outputShape];\n}\n\nexport const sparseReshapeConfig: KernelConfig = {\n  kernelName: SparseReshape,\n  backendName: 'wasm',\n  setupFunc: setup,\n  kernelFunc: sparseReshape as {} as KernelFunc\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}