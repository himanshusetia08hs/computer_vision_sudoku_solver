{"ast":null,"code":"// cicular linked list element with links up, down, left and right\nclass Data {\n  constructor() {\n    let column = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let guess = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    this.left = void 0;\n    this.right = void 0;\n    this.up = void 0;\n    this.down = void 0;\n    this.column = void 0;\n    this.guess = void 0;\n    this.column = column;\n    this.guess = guess;\n    // start of pointing at ourself\n    this.left = this;\n    this.right = this;\n    this.up = this;\n    this.down = this;\n  }\n  insertRight(node) {\n    node.left = this;\n    node.right = this.right;\n    this.right.left = node;\n    this.right = node;\n  }\n  insertLeft(node) {\n    node.right = this;\n    node.left = this.left;\n    this.left.right = node;\n    this.left = node;\n  }\n  insertUp(node) {\n    node.down = this;\n    node.up = this.up;\n    this.up.down = node;\n    this.up = node;\n  }\n  insertDown(node) {\n    node.up = this;\n    node.down = this.down;\n    this.down.up = node;\n    this.down = node;\n  }\n}\nclass Column extends Data {\n  constructor() {\n    super();\n    this.size = void 0;\n    this.size = 0;\n  }\n}\nclass Guess {\n  // flag to indicate if this was a known value - used when displaying the solution\n\n  constructor(x, y, entry) {\n    this.x = void 0;\n    this.y = void 0;\n    this.entry = void 0;\n    this.isKnown = false;\n    this.x = x;\n    this.y = y;\n    this.entry = entry;\n  }\n}\nexport default class SudokuSolver {\n  // root column object\n\n  // the solution\n\n  // Setup the circular lists for the X algorithm to work on\n  constructor() {\n    this.columnRoot = void 0;\n    this.columnLookup = [];\n    this.rowLookup = [];\n    this.solution = [];\n    // construct the rows and columns\n    // https://en.wikipedia.org/wiki/Exact_cover#Sudoku and https://www.stolaf.edu//people/hansonr/sudoku/exactcovermatrix.htm\n    // https://www.kth.se/social/files/58861771f276547fe1dbf8d1/HLaestanderMHarrysson_dkand14.pdf\n\n    // create a doubly linked list of column headers\n    this.columnRoot = new Column();\n    for (let col = 0; col < 81 * 4; col++) {\n      const column = new Column();\n      this.columnRoot.insertRight(column);\n      // stash the column in a quick lookup\n      this.columnLookup.push(column);\n    }\n    // create a doubly linked list of rows and populate the columns for each row\n    for (let x = 0; x < 9; x++) {\n      for (let y = 0; y < 9; y++) {\n        for (let entry = 0; entry < 9; entry++) {\n          const guess = new Guess(x, y, entry + 1);\n          // create a node for the cell entry\n          const entryColIdx = y * 9 + x;\n          const entryColumn = this.columnLookup[entryColIdx];\n          const entryConstraint = new Data(entryColumn, guess);\n          this.rowLookup[(y * 9 + x) * 9 + entry] = entryConstraint;\n          // put the entry node in the corresponding column\n          entryColumn.insertDown(entryConstraint);\n          entryColumn.size++;\n\n          // create a node for the row constraint\n          const rowColIdx = 81 + y * 9 + entry;\n          const rowColumn = this.columnLookup[rowColIdx];\n          const rowConstraint = new Data(rowColumn, guess);\n          // and add it to the row\n          entryConstraint.insertRight(rowConstraint);\n          // and to the column for this constraint\n          rowColumn.insertDown(rowConstraint);\n          rowColumn.size++;\n\n          // create a node for the column constraint\n          const colColIdx = 81 * 2 + x * 9 + entry;\n          const colCol = this.columnLookup[colColIdx];\n          const columnConstraint = new Data(colCol, guess);\n          // and add it to the row\n          rowConstraint.insertRight(columnConstraint);\n          // and to the column for this constraint\n          colCol.insertDown(columnConstraint);\n          colCol.size++;\n\n          // create a node for the box constraint\n          const boxX = Math.floor(x / 3);\n          const boxY = Math.floor(y / 3);\n          const boxColumnIndex = 81 * 3 + (boxY * 3 + boxX) * 9 + entry;\n          const boxColumn = this.columnLookup[boxColumnIndex];\n          const boxConstraint = new Data(boxColumn, guess);\n          // add it the row\n          columnConstraint.insertRight(boxConstraint);\n          // add it to the column\n          boxColumn.insertDown(boxConstraint);\n          boxColumn.size++;\n        }\n      }\n    }\n  }\n\n  // set a number on the puzzle covering any of the constraints that it satisfies\n  setNumber(x, y, entry) {\n    // find the column\n    const row = this.rowLookup[(y * 9 + x) * 9 + entry];\n    row.guess.isKnown = true;\n    this.solution.push(row);\n    this.cover(row.column);\n    for (let right = row.right; right !== row; right = right.right) {\n      this.cover(right.column);\n    }\n  }\n\n  // get the column with the smallest number of rows - this should give us the quickest solution\n  getSmallestColumn() {\n    let smallestSize = this.columnRoot.right.size;\n    let smallestColumn = this.columnRoot.right;\n    let col = this.columnRoot.right;\n    while (col !== this.columnRoot) {\n      if (col.size < smallestSize) {\n        smallestSize = col.size;\n        smallestColumn = col;\n      }\n      col = col.right;\n    }\n    return smallestColumn;\n  }\n\n  // search for a solution\n  search() {\n    let depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    // give up if weve gone to deep - there probably isn't a solution\n    if (depth > 100) {\n      throw new Error(\"too deep - giving up\");\n    }\n    // we have no more columns - we have succeeded - send back the results\n    if (this.columnRoot.right === this.columnRoot) {\n      return true;\n    }\n    // pick the column with the fewest rows\n    let column = this.getSmallestColumn();\n    this.cover(column);\n    for (let row = column.down; row !== column; row = row.down) {\n      this.solution.push(row);\n      for (let right = row.right; right !== row; right = right.right) {\n        this.cover(right.column);\n      }\n      if (this.search(depth + 1)) {\n        return true;\n      }\n      // need to backtrack\n      for (let left = row.left; left !== row; left = left.left) {\n        this.uncover(left.column);\n      }\n      this.solution.pop();\n    }\n    // we've failed\n    this.uncover(column);\n    return false;\n  }\n\n  // cover a column - basically unlink the column from the list and unlink any rows from other columns\n  cover(column) {\n    column.right.left = column.left;\n    column.left.right = column.right;\n    for (let row = column.down; row !== column; row = row.down) {\n      for (let right = row.right; right !== row; right = right.right) {\n        right.down.up = right.up;\n        right.up.down = right.down;\n        right.column.size--;\n      }\n    }\n  }\n\n  // uncover a column - put the rows back along with the column\n  uncover(column) {\n    for (let row = column.up; row !== column; row = row.up) {\n      for (let left = row.left; left !== row; left = left.left) {\n        left.down.up = left;\n        left.up.down = left;\n        left.column.size++;\n      }\n    }\n    column.right.left = column;\n    column.left.right = column;\n  }\n}","map":{"version":3,"names":["Data","constructor","column","guess","left","right","up","down","insertRight","node","insertLeft","insertUp","insertDown","Column","size","Guess","x","y","entry","isKnown","SudokuSolver","columnRoot","columnLookup","rowLookup","solution","col","push","entryColIdx","entryColumn","entryConstraint","rowColIdx","rowColumn","rowConstraint","colColIdx","colCol","columnConstraint","boxX","Math","floor","boxY","boxColumnIndex","boxColumn","boxConstraint","setNumber","row","cover","getSmallestColumn","smallestSize","smallestColumn","search","depth","Error","uncover","pop"],"sources":["F:/extension/SEM 7/NN/Lab/my lab/P/temp/app/src/setiaSudokuSolver/solver/sudokuSolver.ts"],"sourcesContent":["// cicular linked list element with links up, down, left and right\nclass Data {\n  left: Data;\n  right: Data;\n  up: Data;\n  down: Data;\n  column: Column | null;\n  guess: Guess | null;\n  constructor(column: Column = null, guess: Guess = null) {\n    this.column = column;\n    this.guess = guess;\n    // start of pointing at ourself\n    this.left = this;\n    this.right = this;\n    this.up = this;\n    this.down = this;\n  }\n  insertRight(node: Data) {\n    node.left = this;\n    node.right = this.right;\n    this.right.left = node;\n    this.right = node;\n  }\n  insertLeft(node: Data) {\n    node.right = this;\n    node.left = this.left;\n    this.left.right = node;\n    this.left = node;\n  }\n  insertUp(node: Data) {\n    node.down = this;\n    node.up = this.up;\n    this.up.down = node;\n    this.up = node;\n  }\n  insertDown(node: Data) {\n    node.up = this;\n    node.down = this.down;\n    this.down.up = node;\n    this.down = node;\n  }\n}\n\nclass Column extends Data {\n  size: number;\n  constructor() {\n    super();\n    this.size = 0;\n  }\n}\n\nclass Guess {\n  x: number;\n  y: number;\n  entry: number;\n  // flag to indicate if this was a known value - used when displaying the solution\n  isKnown: boolean = false;\n  constructor(x: number, y: number, entry: number) {\n    this.x = x;\n    this.y = y;\n    this.entry = entry;\n  }\n}\n\nexport default class SudokuSolver {\n  columnRoot: Column; // root column object\n  columnLookup: Column[] = [];\n  rowLookup: Data[] = [];\n  solution: Data[] = []; // the solution\n\n  // Setup the circular lists for the X algorithm to work on\n  public constructor() {\n    // construct the rows and columns\n    // https://en.wikipedia.org/wiki/Exact_cover#Sudoku and https://www.stolaf.edu//people/hansonr/sudoku/exactcovermatrix.htm\n    // https://www.kth.se/social/files/58861771f276547fe1dbf8d1/HLaestanderMHarrysson_dkand14.pdf\n\n    // create a doubly linked list of column headers\n    this.columnRoot = new Column();\n    for (let col = 0; col < 81 * 4; col++) {\n      const column = new Column();\n      this.columnRoot.insertRight(column);\n      // stash the column in a quick lookup\n      this.columnLookup.push(column);\n    }\n    // create a doubly linked list of rows and populate the columns for each row\n    for (let x = 0; x < 9; x++) {\n      for (let y = 0; y < 9; y++) {\n        for (let entry = 0; entry < 9; entry++) {\n          const guess = new Guess(x, y, entry + 1);\n          // create a node for the cell entry\n          const entryColIdx = y * 9 + x;\n          const entryColumn = this.columnLookup[entryColIdx];\n          const entryConstraint = new Data(entryColumn, guess);\n          this.rowLookup[(y * 9 + x) * 9 + entry] = entryConstraint;\n          // put the entry node in the corresponding column\n          entryColumn.insertDown(entryConstraint);\n          entryColumn.size++;\n\n          // create a node for the row constraint\n          const rowColIdx = 81 + y * 9 + entry;\n          const rowColumn = this.columnLookup[rowColIdx];\n          const rowConstraint = new Data(rowColumn, guess);\n          // and add it to the row\n          entryConstraint.insertRight(rowConstraint);\n          // and to the column for this constraint\n          rowColumn.insertDown(rowConstraint);\n          rowColumn.size++;\n\n          // create a node for the column constraint\n          const colColIdx = 81 * 2 + x * 9 + entry;\n          const colCol = this.columnLookup[colColIdx];\n          const columnConstraint = new Data(colCol, guess);\n          // and add it to the row\n          rowConstraint.insertRight(columnConstraint);\n          // and to the column for this constraint\n          colCol.insertDown(columnConstraint);\n          colCol.size++;\n\n          // create a node for the box constraint\n          const boxX = Math.floor(x / 3);\n          const boxY = Math.floor(y / 3);\n          const boxColumnIndex = 81 * 3 + (boxY * 3 + boxX) * 9 + entry;\n          const boxColumn = this.columnLookup[boxColumnIndex];\n          const boxConstraint = new Data(boxColumn, guess);\n          // add it the row\n          columnConstraint.insertRight(boxConstraint);\n          // add it to the column\n          boxColumn.insertDown(boxConstraint);\n          boxColumn.size++;\n        }\n      }\n    }\n  }\n\n  // set a number on the puzzle covering any of the constraints that it satisfies\n  setNumber(x: number, y: number, entry: number) {\n    // find the column\n    const row = this.rowLookup[(y * 9 + x) * 9 + entry];\n    row.guess.isKnown = true;\n    this.solution.push(row);\n    this.cover(row.column);\n    for (let right = row.right; right !== row; right = right.right) {\n      this.cover(right.column);\n    }\n  }\n\n  // get the column with the smallest number of rows - this should give us the quickest solution\n  getSmallestColumn() {\n    let smallestSize = (this.columnRoot.right as Column).size;\n    let smallestColumn = this.columnRoot.right as Column;\n    let col = this.columnRoot.right as Column;\n    while (col !== this.columnRoot) {\n      if (col.size < smallestSize) {\n        smallestSize = col.size;\n        smallestColumn = col;\n      }\n      col = col.right as Column;\n    }\n    return smallestColumn;\n  }\n\n  // search for a solution\n  search(depth: number = 0): boolean {\n    // give up if weve gone to deep - there probably isn't a solution\n    if (depth > 100) {\n      throw new Error(\"too deep - giving up\");\n    }\n    // we have no more columns - we have succeeded - send back the results\n    if (this.columnRoot.right === this.columnRoot) {\n      return true;\n    }\n    // pick the column with the fewest rows\n    let column = this.getSmallestColumn();\n    this.cover(column);\n    for (let row = column.down; row !== column; row = row.down) {\n      this.solution.push(row);\n      for (let right = row.right; right !== row; right = right.right) {\n        this.cover(right.column);\n      }\n      if (this.search(depth + 1)) {\n        return true;\n      }\n      // need to backtrack\n      for (let left = row.left; left !== row; left = left.left) {\n        this.uncover(left.column);\n      }\n      this.solution.pop();\n    }\n    // we've failed\n    this.uncover(column);\n    return false;\n  }\n\n  // cover a column - basically unlink the column from the list and unlink any rows from other columns\n  cover(column: Column) {\n    column.right.left = column.left;\n    column.left.right = column.right;\n    for (let row = column.down; row !== column; row = row.down) {\n      for (let right = row.right; right !== row; right = right.right) {\n        right.down.up = right.up;\n        right.up.down = right.down;\n        right.column.size--;\n      }\n    }\n  }\n\n  // uncover a column - put the rows back along with the column\n  uncover(column: Column) {\n    for (let row = column.up; row !== column; row = row.up) {\n      for (let left = row.left; left !== row; left = left.left) {\n        left.down.up = left;\n        left.up.down = left;\n        left.column.size++;\n      }\n    }\n    column.right.left = column;\n    column.left.right = column;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}