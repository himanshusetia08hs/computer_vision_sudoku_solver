{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nimport Complex from 'complex.js';\nimport { format } from '../../utils/number';\nimport { isNumber, isUnit } from '../../utils/is';\nimport { factory } from '../../utils/factory';\nvar name = 'Complex';\nvar dependencies = [];\nexport var createComplexClass = /* #__PURE__ */factory(name, dependencies, function () {\n  /**\n   * Attach type information\n   */\n  Complex.prototype.type = 'Complex';\n  Complex.prototype.isComplex = true;\n  /**\n   * Get a JSON representation of the complex number\n   * @returns {Object} Returns a JSON object structured as:\n   *                   `{\"mathjs\": \"Complex\", \"re\": 2, \"im\": 3}`\n   */\n\n  Complex.prototype.toJSON = function () {\n    return {\n      mathjs: 'Complex',\n      re: this.re,\n      im: this.im\n    };\n  };\n  /*\n   * Return the value of the complex number in polar notation\n   * The angle phi will be set in the interval of [-pi, pi].\n   * @return {{r: number, phi: number}} Returns and object with properties r and phi.\n   */\n\n  Complex.prototype.toPolar = function () {\n    return {\n      r: this.abs(),\n      phi: this.arg()\n    };\n  };\n  /**\n   * Get a string representation of the complex number,\n   * with optional formatting options.\n   * @param {Object | number | Function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @return {string} str\n   */\n\n  Complex.prototype.format = function (options) {\n    var str = '';\n    var im = this.im;\n    var re = this.re;\n    var strRe = format(this.re, options);\n    var strIm = format(this.im, options); // round either re or im when smaller than the configured precision\n\n    var precision = isNumber(options) ? options : options ? options.precision : null;\n    if (precision !== null) {\n      var epsilon = Math.pow(10, -precision);\n      if (Math.abs(re / im) < epsilon) {\n        re = 0;\n      }\n      if (Math.abs(im / re) < epsilon) {\n        im = 0;\n      }\n    }\n    if (im === 0) {\n      // real value\n      str = strRe;\n    } else if (re === 0) {\n      // purely complex value\n      if (im === 1) {\n        str = 'i';\n      } else if (im === -1) {\n        str = '-i';\n      } else {\n        str = strIm + 'i';\n      }\n    } else {\n      // complex value\n      if (im < 0) {\n        if (im === -1) {\n          str = strRe + ' - i';\n        } else {\n          str = strRe + ' - ' + strIm.substring(1) + 'i';\n        }\n      } else {\n        if (im === 1) {\n          str = strRe + ' + i';\n        } else {\n          str = strRe + ' + ' + strIm + 'i';\n        }\n      }\n    }\n    return str;\n  };\n  /**\n   * Create a complex number from polar coordinates\n   *\n   * Usage:\n   *\n   *     Complex.fromPolar(r: number, phi: number) : Complex\n   *     Complex.fromPolar({r: number, phi: number}) : Complex\n   *\n   * @param {*} args...\n   * @return {Complex}\n   */\n\n  Complex.fromPolar = function (args) {\n    switch (arguments.length) {\n      case 1:\n        {\n          var arg = arguments[0];\n          if (_typeof(arg) === 'object') {\n            return Complex(arg);\n          } else {\n            throw new TypeError('Input has to be an object with r and phi keys.');\n          }\n        }\n      case 2:\n        {\n          var r = arguments[0];\n          var phi = arguments[1];\n          if (isNumber(r)) {\n            if (isUnit(phi) && phi.hasBase('ANGLE')) {\n              // convert unit to a number in radians\n              phi = phi.toNumber('rad');\n            }\n            if (isNumber(phi)) {\n              return new Complex({\n                r: r,\n                phi: phi\n              });\n            }\n            throw new TypeError('Phi is not a number nor an angle unit.');\n          } else {\n            throw new TypeError('Radius r is not a number.');\n          }\n        }\n      default:\n        throw new SyntaxError('Wrong number of arguments in function fromPolar');\n    }\n  };\n  Complex.prototype.valueOf = Complex.prototype.toString;\n  /**\n   * Create a Complex number from a JSON object\n   * @param {Object} json  A JSON Object structured as\n   *                       {\"mathjs\": \"Complex\", \"re\": 2, \"im\": 3}\n   *                       All properties are optional, default values\n   *                       for `re` and `im` are 0.\n   * @return {Complex} Returns a new Complex number\n   */\n\n  Complex.fromJSON = function (json) {\n    return new Complex(json);\n  };\n  /**\n   * Compare two complex numbers, `a` and `b`:\n   *\n   * - Returns 1 when the real part of `a` is larger than the real part of `b`\n   * - Returns -1 when the real part of `a` is smaller than the real part of `b`\n   * - Returns 1 when the real parts are equal\n   *   and the imaginary part of `a` is larger than the imaginary part of `b`\n   * - Returns -1 when the real parts are equal\n   *   and the imaginary part of `a` is smaller than the imaginary part of `b`\n   * - Returns 0 when both real and imaginary parts are equal.\n   *\n   * @params {Complex} a\n   * @params {Complex} b\n   * @returns {number} Returns the comparison result: -1, 0, or 1\n   */\n\n  Complex.compare = function (a, b) {\n    if (a.re > b.re) {\n      return 1;\n    }\n    if (a.re < b.re) {\n      return -1;\n    }\n    if (a.im > b.im) {\n      return 1;\n    }\n    if (a.im < b.im) {\n      return -1;\n    }\n    return 0;\n  };\n  return Complex;\n}, {\n  isClass: true\n});","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","Complex","format","isNumber","isUnit","factory","name","dependencies","createComplexClass","type","isComplex","toJSON","mathjs","re","im","toPolar","r","abs","phi","arg","options","str","strRe","strIm","precision","epsilon","Math","pow","substring","fromPolar","args","arguments","length","TypeError","hasBase","toNumber","SyntaxError","valueOf","toString","fromJSON","json","compare","a","b","isClass"],"sources":["F:/extension/SEM 7/NN/Lab/my lab/Project/temp/app/node_modules/mathjs/es/type/complex/Complex.js"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport Complex from 'complex.js';\nimport { format } from '../../utils/number';\nimport { isNumber, isUnit } from '../../utils/is';\nimport { factory } from '../../utils/factory';\nvar name = 'Complex';\nvar dependencies = [];\nexport var createComplexClass = /* #__PURE__ */factory(name, dependencies, function () {\n  /**\n   * Attach type information\n   */\n  Complex.prototype.type = 'Complex';\n  Complex.prototype.isComplex = true;\n  /**\n   * Get a JSON representation of the complex number\n   * @returns {Object} Returns a JSON object structured as:\n   *                   `{\"mathjs\": \"Complex\", \"re\": 2, \"im\": 3}`\n   */\n\n  Complex.prototype.toJSON = function () {\n    return {\n      mathjs: 'Complex',\n      re: this.re,\n      im: this.im\n    };\n  };\n  /*\n   * Return the value of the complex number in polar notation\n   * The angle phi will be set in the interval of [-pi, pi].\n   * @return {{r: number, phi: number}} Returns and object with properties r and phi.\n   */\n\n\n  Complex.prototype.toPolar = function () {\n    return {\n      r: this.abs(),\n      phi: this.arg()\n    };\n  };\n  /**\n   * Get a string representation of the complex number,\n   * with optional formatting options.\n   * @param {Object | number | Function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @return {string} str\n   */\n\n\n  Complex.prototype.format = function (options) {\n    var str = '';\n    var im = this.im;\n    var re = this.re;\n    var strRe = format(this.re, options);\n    var strIm = format(this.im, options); // round either re or im when smaller than the configured precision\n\n    var precision = isNumber(options) ? options : options ? options.precision : null;\n\n    if (precision !== null) {\n      var epsilon = Math.pow(10, -precision);\n\n      if (Math.abs(re / im) < epsilon) {\n        re = 0;\n      }\n\n      if (Math.abs(im / re) < epsilon) {\n        im = 0;\n      }\n    }\n\n    if (im === 0) {\n      // real value\n      str = strRe;\n    } else if (re === 0) {\n      // purely complex value\n      if (im === 1) {\n        str = 'i';\n      } else if (im === -1) {\n        str = '-i';\n      } else {\n        str = strIm + 'i';\n      }\n    } else {\n      // complex value\n      if (im < 0) {\n        if (im === -1) {\n          str = strRe + ' - i';\n        } else {\n          str = strRe + ' - ' + strIm.substring(1) + 'i';\n        }\n      } else {\n        if (im === 1) {\n          str = strRe + ' + i';\n        } else {\n          str = strRe + ' + ' + strIm + 'i';\n        }\n      }\n    }\n\n    return str;\n  };\n  /**\n   * Create a complex number from polar coordinates\n   *\n   * Usage:\n   *\n   *     Complex.fromPolar(r: number, phi: number) : Complex\n   *     Complex.fromPolar({r: number, phi: number}) : Complex\n   *\n   * @param {*} args...\n   * @return {Complex}\n   */\n\n\n  Complex.fromPolar = function (args) {\n    switch (arguments.length) {\n      case 1:\n        {\n          var arg = arguments[0];\n\n          if (_typeof(arg) === 'object') {\n            return Complex(arg);\n          } else {\n            throw new TypeError('Input has to be an object with r and phi keys.');\n          }\n        }\n\n      case 2:\n        {\n          var r = arguments[0];\n          var phi = arguments[1];\n\n          if (isNumber(r)) {\n            if (isUnit(phi) && phi.hasBase('ANGLE')) {\n              // convert unit to a number in radians\n              phi = phi.toNumber('rad');\n            }\n\n            if (isNumber(phi)) {\n              return new Complex({\n                r: r,\n                phi: phi\n              });\n            }\n\n            throw new TypeError('Phi is not a number nor an angle unit.');\n          } else {\n            throw new TypeError('Radius r is not a number.');\n          }\n        }\n\n      default:\n        throw new SyntaxError('Wrong number of arguments in function fromPolar');\n    }\n  };\n\n  Complex.prototype.valueOf = Complex.prototype.toString;\n  /**\n   * Create a Complex number from a JSON object\n   * @param {Object} json  A JSON Object structured as\n   *                       {\"mathjs\": \"Complex\", \"re\": 2, \"im\": 3}\n   *                       All properties are optional, default values\n   *                       for `re` and `im` are 0.\n   * @return {Complex} Returns a new Complex number\n   */\n\n  Complex.fromJSON = function (json) {\n    return new Complex(json);\n  };\n  /**\n   * Compare two complex numbers, `a` and `b`:\n   *\n   * - Returns 1 when the real part of `a` is larger than the real part of `b`\n   * - Returns -1 when the real part of `a` is smaller than the real part of `b`\n   * - Returns 1 when the real parts are equal\n   *   and the imaginary part of `a` is larger than the imaginary part of `b`\n   * - Returns -1 when the real parts are equal\n   *   and the imaginary part of `a` is smaller than the imaginary part of `b`\n   * - Returns 0 when both real and imaginary parts are equal.\n   *\n   * @params {Complex} a\n   * @params {Complex} b\n   * @returns {number} Returns the comparison result: -1, 0, or 1\n   */\n\n\n  Complex.compare = function (a, b) {\n    if (a.re > b.re) {\n      return 1;\n    }\n\n    if (a.re < b.re) {\n      return -1;\n    }\n\n    if (a.im > b.im) {\n      return 1;\n    }\n\n    if (a.im < b.im) {\n      return -1;\n    }\n\n    return 0;\n  };\n\n  return Complex;\n}, {\n  isClass: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}