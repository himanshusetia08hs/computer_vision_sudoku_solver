{"ast":null,"code":"/**\n * @license\n * Copyright 2022 CodeSmith LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { denseBincount, mul } from '@tensorflow/tfjs-core';\nimport { getExactlyOneTensor } from '../../utils/types_utils';\nimport { expandDims } from '@tensorflow/tfjs-core';\nimport { ValueError } from '../../errors';\nimport * as K from '../../backend/tfjs_backend';\nexport function encodeCategoricalInputs(inputs, outputMode, depth, weights) {\n  let input = getExactlyOneTensor(inputs);\n  if (input.dtype !== 'int32') {\n    input = K.cast(input, 'int32');\n  }\n  if (outputMode === 'int') {\n    return input;\n  }\n  const originalShape = input.shape;\n  if (input.rank === 0) {\n    input = expandDims(input, -1);\n  }\n  if (outputMode === 'oneHot') {\n    if (input.shape[input.shape.length - 1] !== 1) {\n      input = expandDims(input, -1);\n    }\n  }\n  if (input.rank > 2) {\n    throw new ValueError(`When outputMode is not int, maximum output rank is 2` + ` Received outputMode ${outputMode} and input shape ${originalShape}` + ` which would result in output rank ${input.rank}.`);\n  }\n  const binaryOutput = ['multiHot', 'oneHot'].includes(outputMode);\n  const denseBincountInput = input;\n  let binCounts;\n  if (typeof weights !== 'undefined' && outputMode === 'count') {\n    binCounts = denseBincount(denseBincountInput, weights, depth, binaryOutput);\n  } else {\n    binCounts = denseBincount(denseBincountInput, [], depth, binaryOutput);\n  }\n  if (outputMode !== 'tfIdf') {\n    return binCounts;\n  }\n  if (weights) {\n    return mul(binCounts, weights);\n  } else {\n    throw new ValueError(`When outputMode is 'tfIdf', weights must be provided.`);\n  }\n}","map":{"version":3,"sources":["../../../../../../../tfjs-layers/src/layers/preprocessing/preprocessing_utils.ts"],"names":[],"mappings":"AAAA;;;;;;;;AAQG;AAEH,SAAiB,aAAa,EAAkC,GAAG,QAAO,uBAAuB;AACjG,SAAS,mBAAmB,QAAQ,yBAAyB;AAC7D,SAAS,UAAU,QAAO,uBAAuB;AACjD,SAAS,UAAU,QAAQ,cAAc;AACzC,OAAO,KAAK,CAAC,MAAM,4BAA4B;AAI/C,OAAM,SAAU,uBAAuB,CAAC,MAAuB,EACvB,UAAsB,EACtB,KAAa,EACb,OAAsC,EAAA;EAG5E,IAAI,KAAK,GAAG,mBAAmB,CAAC,MAAM,CAAC;EAEvC,IAAG,KAAK,CAAC,KAAK,KAAK,OAAO,EAAE;IAC1B,KAAK,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,OAAO,CAAC;EAC7B;EAEH,IAAG,UAAU,KAAK,KAAK,EAAE;IACvB,OAAO,KAAK;EACb;EAED,MAAM,aAAa,GAAG,KAAK,CAAC,KAAK;EAEjC,IAAG,KAAK,CAAC,IAAI,KAAK,CAAC,EAAE;IACnB,KAAK,GAAG,UAAU,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;EAC9B;EAED,IAAG,UAAU,KAAK,QAAQ,EAAE;IAC1B,IAAG,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,CAAC,EAAE;MAC5C,KAAK,GAAG,UAAU,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;IAC9B;EACF;EAED,IAAG,KAAK,CAAC,IAAI,GAAG,CAAC,EAAE;IACjB,MAAM,IAAI,UAAU,CAAC,sDAAsD,GACzE,wBAAwB,UAAU,oBAAoB,aAAa,EAAE,GACrE,sCAAsC,KAAK,CAAC,IAAI,GAAG,CAAC;EACvD;EAED,MAAM,YAAY,GAAG,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC,QAAQ,CAAC,UAAU,CAAC;EAEhE,MAAM,kBAAkB,GAAG,KAA4B;EAEvD,IAAI,SAA8B;EAElC,IAAK,OAAO,OAAO,KAAM,WAAW,IAAI,UAAU,KAAK,OAAO,EAAE;IAC9D,SAAS,GAAG,aAAa,CAAC,kBAAkB,EAAE,OAAO,EAAE,KAAK,EAAE,YAAY,CAAC;GAC3E,MAAM;IACN,SAAS,GAAG,aAAa,CAAC,kBAAkB,EAAE,EAAE,EAAE,KAAK,EAAE,YAAY,CAAC;EACtE;EAEF,IAAG,UAAU,KAAK,OAAO,EAAE;IACzB,OAAO,SAAS;EACjB;EAED,IAAI,OAAO,EAAE;IACX,OAAO,GAAG,CAAC,SAAS,EAAE,OAAO,CAAC;GAC/B,MAAM;IACH,MAAM,IAAI,UAAU,CAClB,uDAAuD,CACxD;EACJ;AACH","sourcesContent":["/**\n * @license\n * Copyright 2022 CodeSmith LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\nimport { Tensor, denseBincount, Tensor1D, Tensor2D, TensorLike, mul} from '@tensorflow/tfjs-core';\nimport { getExactlyOneTensor } from '../../utils/types_utils';\nimport { expandDims} from '@tensorflow/tfjs-core';\nimport { ValueError } from '../../errors';\nimport * as K from '../../backend/tfjs_backend';\n\nexport type OutputMode = 'int' | 'oneHot' | 'multiHot' | 'count' | 'tfIdf';\n\nexport function encodeCategoricalInputs(inputs: Tensor|Tensor[],\n                                        outputMode: OutputMode,\n                                        depth: number,\n                                        weights?: Tensor1D|Tensor2D|TensorLike):\n                                        Tensor|Tensor[] {\n\n  let input = getExactlyOneTensor(inputs);\n\n  if(input.dtype !== 'int32') {\n    input = K.cast(input, 'int32');\n    }\n\n  if(outputMode === 'int') {\n    return input;\n  }\n\n  const originalShape = input.shape;\n\n  if(input.rank === 0) {\n    input = expandDims(input, -1);\n  }\n\n  if(outputMode === 'oneHot') {\n    if(input.shape[input.shape.length - 1] !== 1) {\n      input = expandDims(input, -1);\n    }\n  }\n\n  if(input.rank > 2) {\n    throw new ValueError(`When outputMode is not int, maximum output rank is 2`\n    + ` Received outputMode ${outputMode} and input shape ${originalShape}`\n    + ` which would result in output rank ${input.rank}.`);\n  }\n\n  const binaryOutput = ['multiHot', 'oneHot'].includes(outputMode);\n\n  const denseBincountInput = input as Tensor1D | Tensor2D;\n\n  let binCounts: Tensor1D | Tensor2D;\n\n  if ((typeof weights) !== 'undefined' && outputMode === 'count') {\n    binCounts = denseBincount(denseBincountInput, weights, depth, binaryOutput);\n   } else {\n    binCounts = denseBincount(denseBincountInput, [], depth, binaryOutput);\n   }\n\n  if(outputMode !== 'tfIdf') {\n    return binCounts;\n  }\n\n  if (weights) {\n    return mul(binCounts, weights);\n  } else {\n      throw new ValueError(\n        `When outputMode is 'tfIdf', weights must be provided.`\n      );\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}