{"ast":null,"code":"import { isArray, isBigNumber, isCollection, isIndex, isMatrix, isNumber, isString, typeOf } from '../../utils/is';\nimport { arraySize, getArrayDataType, reshape, resize, unsqueeze, validate, validateIndex } from '../../utils/array';\nimport { format } from '../../utils/string';\nimport { isInteger } from '../../utils/number';\nimport { clone, deepStrictEqual } from '../../utils/object';\nimport { DimensionError } from '../../error/DimensionError';\nimport { factory } from '../../utils/factory';\nvar name = 'DenseMatrix';\nvar dependencies = ['Matrix'];\nexport var createDenseMatrixClass = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Matrix = _ref.Matrix;\n\n  /**\n   * Dense Matrix implementation. A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.\n   * @class DenseMatrix\n   */\n  function DenseMatrix(data, datatype) {\n    if (!(this instanceof DenseMatrix)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n    if (datatype && !isString(datatype)) {\n      throw new Error('Invalid datatype: ' + datatype);\n    }\n    if (isMatrix(data)) {\n      // check data is a DenseMatrix\n      if (data.type === 'DenseMatrix') {\n        // clone data & size\n        this._data = clone(data._data);\n        this._size = clone(data._size);\n        this._datatype = datatype || data._datatype;\n      } else {\n        // build data from existing matrix\n        this._data = data.toArray();\n        this._size = data.size();\n        this._datatype = datatype || data._datatype;\n      }\n    } else if (data && isArray(data.data) && isArray(data.size)) {\n      // initialize fields from JSON representation\n      this._data = data.data;\n      this._size = data.size; // verify the dimensions of the array\n\n      validate(this._data, this._size);\n      this._datatype = datatype || data.datatype;\n    } else if (isArray(data)) {\n      // replace nested Matrices with Arrays\n      this._data = preprocess(data); // get the dimensions of the array\n\n      this._size = arraySize(this._data); // verify the dimensions of the array, TODO: compute size while processing array\n\n      validate(this._data, this._size); // data type unknown\n\n      this._datatype = datatype;\n    } else if (data) {\n      // unsupported type\n      throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');\n    } else {\n      // nothing provided\n      this._data = [];\n      this._size = [0];\n      this._datatype = datatype;\n    }\n  }\n  DenseMatrix.prototype = new Matrix();\n  /**\n   * Create a new DenseMatrix\n   */\n\n  DenseMatrix.prototype.createDenseMatrix = function (data, datatype) {\n    return new DenseMatrix(data, datatype);\n  };\n  /**\n   * Attach type information\n   */\n\n  DenseMatrix.prototype.type = 'DenseMatrix';\n  DenseMatrix.prototype.isDenseMatrix = true;\n  /**\n   * Get the matrix type\n   *\n   * Usage:\n   *    const matrixType = matrix.getDataType()  // retrieves the matrix type\n   *\n   * @memberOf DenseMatrix\n   * @return {string}   type information; if multiple types are found from the Matrix, it will return \"mixed\"\n   */\n\n  DenseMatrix.prototype.getDataType = function () {\n    return getArrayDataType(this._data, typeOf);\n  };\n  /**\n   * Get the storage format used by the matrix.\n   *\n   * Usage:\n   *     const format = matrix.storage()  // retrieve storage format\n   *\n   * @memberof DenseMatrix\n   * @return {string}           The storage format.\n   */\n\n  DenseMatrix.prototype.storage = function () {\n    return 'dense';\n  };\n  /**\n   * Get the datatype of the data stored in the matrix.\n   *\n   * Usage:\n   *     const format = matrix.datatype()   // retrieve matrix datatype\n   *\n   * @memberof DenseMatrix\n   * @return {string}           The datatype.\n   */\n\n  DenseMatrix.prototype.datatype = function () {\n    return this._datatype;\n  };\n  /**\n   * Create a new DenseMatrix\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @param {string} [datatype]\n   */\n\n  DenseMatrix.prototype.create = function (data, datatype) {\n    return new DenseMatrix(data, datatype);\n  };\n  /**\n   * Get a subset of the matrix, or replace a subset of the matrix.\n   *\n   * Usage:\n   *     const subset = matrix.subset(index)               // retrieve subset\n   *     const value = matrix.subset(index, replacement)   // replace subset\n   *\n   * @memberof DenseMatrix\n   * @param {Index} index\n   * @param {Array | Matrix | *} [replacement]\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be filled with zeros.\n   */\n\n  DenseMatrix.prototype.subset = function (index, replacement, defaultValue) {\n    switch (arguments.length) {\n      case 1:\n        return _get(this, index);\n      // intentional fall through\n\n      case 2:\n      case 3:\n        return _set(this, index, replacement, defaultValue);\n      default:\n        throw new SyntaxError('Wrong number of arguments');\n    }\n  };\n  /**\n   * Get a single element from the matrix.\n   * @memberof DenseMatrix\n   * @param {number[]} index   Zero-based index\n   * @return {*} value\n   */\n\n  DenseMatrix.prototype.get = function (index) {\n    if (!isArray(index)) {\n      throw new TypeError('Array expected');\n    }\n    if (index.length !== this._size.length) {\n      throw new DimensionError(index.length, this._size.length);\n    } // check index\n\n    for (var x = 0; x < index.length; x++) {\n      validateIndex(index[x], this._size[x]);\n    }\n    var data = this._data;\n    for (var i = 0, ii = index.length; i < ii; i++) {\n      var indexI = index[i];\n      validateIndex(indexI, data.length);\n      data = data[indexI];\n    }\n    return data;\n  };\n  /**\n   * Replace a single element in the matrix.\n   * @memberof DenseMatrix\n   * @param {number[]} index   Zero-based index\n   * @param {*} value\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be left undefined.\n   * @return {DenseMatrix} self\n   */\n\n  DenseMatrix.prototype.set = function (index, value, defaultValue) {\n    if (!isArray(index)) {\n      throw new TypeError('Array expected');\n    }\n    if (index.length < this._size.length) {\n      throw new DimensionError(index.length, this._size.length, '<');\n    }\n    var i, ii, indexI; // enlarge matrix when needed\n\n    var size = index.map(function (i) {\n      return i + 1;\n    });\n    _fit(this, size, defaultValue); // traverse over the dimensions\n\n    var data = this._data;\n    for (i = 0, ii = index.length - 1; i < ii; i++) {\n      indexI = index[i];\n      validateIndex(indexI, data.length);\n      data = data[indexI];\n    } // set new value\n\n    indexI = index[index.length - 1];\n    validateIndex(indexI, data.length);\n    data[indexI] = value;\n    return this;\n  };\n  /**\n   * Get a submatrix of this matrix\n   * @memberof DenseMatrix\n   * @param {DenseMatrix} matrix\n   * @param {Index} index   Zero-based index\n   * @private\n   */\n\n  function _get(matrix, index) {\n    if (!isIndex(index)) {\n      throw new TypeError('Invalid index');\n    }\n    var isScalar = index.isScalar();\n    if (isScalar) {\n      // return a scalar\n      return matrix.get(index.min());\n    } else {\n      // validate dimensions\n      var size = index.size();\n      if (size.length !== matrix._size.length) {\n        throw new DimensionError(size.length, matrix._size.length);\n      } // validate if any of the ranges in the index is out of range\n\n      var min = index.min();\n      var max = index.max();\n      for (var i = 0, ii = matrix._size.length; i < ii; i++) {\n        validateIndex(min[i], matrix._size[i]);\n        validateIndex(max[i], matrix._size[i]);\n      } // retrieve submatrix\n      // TODO: more efficient when creating an empty matrix and setting _data and _size manually\n\n      return new DenseMatrix(_getSubmatrix(matrix._data, index, size.length, 0), matrix._datatype);\n    }\n  }\n  /**\n   * Recursively get a submatrix of a multi dimensional matrix.\n   * Index is not checked for correct number or length of dimensions.\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @param {Index} index\n   * @param {number} dims   Total number of dimensions\n   * @param {number} dim    Current dimension\n   * @return {Array} submatrix\n   * @private\n   */\n\n  function _getSubmatrix(data, index, dims, dim) {\n    var last = dim === dims - 1;\n    var range = index.dimension(dim);\n    if (last) {\n      return range.map(function (i) {\n        validateIndex(i, data.length);\n        return data[i];\n      }).valueOf();\n    } else {\n      return range.map(function (i) {\n        validateIndex(i, data.length);\n        var child = data[i];\n        return _getSubmatrix(child, index, dims, dim + 1);\n      }).valueOf();\n    }\n  }\n  /**\n   * Replace a submatrix in this matrix\n   * Indexes are zero-based.\n   * @memberof DenseMatrix\n   * @param {DenseMatrix} matrix\n   * @param {Index} index\n   * @param {DenseMatrix | Array | *} submatrix\n   * @param {*} defaultValue          Default value, filled in on new entries when\n   *                                  the matrix is resized.\n   * @return {DenseMatrix} matrix\n   * @private\n   */\n\n  function _set(matrix, index, submatrix, defaultValue) {\n    if (!index || index.isIndex !== true) {\n      throw new TypeError('Invalid index');\n    } // get index size and check whether the index contains a single value\n\n    var iSize = index.size();\n    var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed\n\n    var sSize;\n    if (isMatrix(submatrix)) {\n      sSize = submatrix.size();\n      submatrix = submatrix.valueOf();\n    } else {\n      sSize = arraySize(submatrix);\n    }\n    if (isScalar) {\n      // set a scalar\n      // check whether submatrix is a scalar\n      if (sSize.length !== 0) {\n        throw new TypeError('Scalar expected');\n      }\n      matrix.set(index.min(), submatrix, defaultValue);\n    } else {\n      // set a submatrix\n      // validate dimensions\n      if (iSize.length < matrix._size.length) {\n        throw new DimensionError(iSize.length, matrix._size.length, '<');\n      }\n      if (sSize.length < iSize.length) {\n        // calculate number of missing outer dimensions\n        var i = 0;\n        var outer = 0;\n        while (iSize[i] === 1 && sSize[i] === 1) {\n          i++;\n        }\n        while (iSize[i] === 1) {\n          outer++;\n          i++;\n        } // unsqueeze both outer and inner dimensions\n\n        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);\n      } // check whether the size of the submatrix matches the index size\n\n      if (!deepStrictEqual(iSize, sSize)) {\n        throw new DimensionError(iSize, sSize, '>');\n      } // enlarge matrix when needed\n\n      var size = index.max().map(function (i) {\n        return i + 1;\n      });\n      _fit(matrix, size, defaultValue); // insert the sub matrix\n\n      var dims = iSize.length;\n      var dim = 0;\n      _setSubmatrix(matrix._data, index, submatrix, dims, dim);\n    }\n    return matrix;\n  }\n  /**\n   * Replace a submatrix of a multi dimensional matrix.\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @param {Index} index\n   * @param {Array} submatrix\n   * @param {number} dims   Total number of dimensions\n   * @param {number} dim\n   * @private\n   */\n\n  function _setSubmatrix(data, index, submatrix, dims, dim) {\n    var last = dim === dims - 1;\n    var range = index.dimension(dim);\n    if (last) {\n      range.forEach(function (dataIndex, subIndex) {\n        validateIndex(dataIndex);\n        data[dataIndex] = submatrix[subIndex[0]];\n      });\n    } else {\n      range.forEach(function (dataIndex, subIndex) {\n        validateIndex(dataIndex);\n        _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);\n      });\n    }\n  }\n  /**\n   * Resize the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (resize in place).\n   *\n   * @memberof DenseMatrix\n   * @param {number[] || Matrix} size The new size the matrix should have.\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\n   *                                  If not provided, the matrix elements will\n   *                                  be filled with zeros.\n   * @param {boolean} [copy]          Return a resized copy of the matrix\n   *\n   * @return {Matrix}                 The resized matrix\n   */\n\n  DenseMatrix.prototype.resize = function (size, defaultValue, copy) {\n    // validate arguments\n    if (!isCollection(size)) {\n      throw new TypeError('Array or Matrix expected');\n    } // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector\n\n    var sizeArray = size.valueOf().map(function (value) {\n      return Array.isArray(value) && value.length === 1 ? value[0] : value;\n    }); // matrix to resize\n\n    var m = copy ? this.clone() : this; // resize matrix\n\n    return _resize(m, sizeArray, defaultValue);\n  };\n  function _resize(matrix, size, defaultValue) {\n    // check size\n    if (size.length === 0) {\n      // first value in matrix\n      var v = matrix._data; // go deep\n\n      while (isArray(v)) {\n        v = v[0];\n      }\n      return v;\n    } // resize matrix\n\n    matrix._size = size.slice(0); // copy the array\n\n    matrix._data = resize(matrix._data, matrix._size, defaultValue); // return matrix\n\n    return matrix;\n  }\n  /**\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\n   *\n   * NOTE: This might be better suited to copy by default, instead of modifying\n   *       in place. For now, it operates in place to remain consistent with\n   *       resize().\n   *\n   * @memberof DenseMatrix\n   * @param {number[]} size           The new size the matrix should have.\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\n   *\n   * @return {Matrix}                 The reshaped matrix\n   */\n\n  DenseMatrix.prototype.reshape = function (size, copy) {\n    var m = copy ? this.clone() : this;\n    m._data = reshape(m._data, size);\n    m._size = size.slice(0);\n    return m;\n  };\n  /**\n   * Enlarge the matrix when it is smaller than given size.\n   * If the matrix is larger or equal sized, nothing is done.\n   * @memberof DenseMatrix\n   * @param {DenseMatrix} matrix           The matrix to be resized\n   * @param {number[]} size\n   * @param {*} defaultValue          Default value, filled in on new entries.\n   * @private\n   */\n\n  function _fit(matrix, size, defaultValue) {\n    var\n    // copy the array\n    newSize = matrix._size.slice(0);\n    var changed = false; // add dimensions when needed\n\n    while (newSize.length < size.length) {\n      newSize.push(0);\n      changed = true;\n    } // enlarge size when needed\n\n    for (var i = 0, ii = size.length; i < ii; i++) {\n      if (size[i] > newSize[i]) {\n        newSize[i] = size[i];\n        changed = true;\n      }\n    }\n    if (changed) {\n      // resize only when size is changed\n      _resize(matrix, newSize, defaultValue);\n    }\n  }\n  /**\n   * Create a clone of the matrix\n   * @memberof DenseMatrix\n   * @return {DenseMatrix} clone\n   */\n\n  DenseMatrix.prototype.clone = function () {\n    var m = new DenseMatrix({\n      data: clone(this._data),\n      size: clone(this._size),\n      datatype: this._datatype\n    });\n    return m;\n  };\n  /**\n   * Retrieve the size of the matrix.\n   * @memberof DenseMatrix\n   * @returns {number[]} size\n   */\n\n  DenseMatrix.prototype.size = function () {\n    return this._size.slice(0); // return a clone of _size\n  };\n  /**\n   * Create a new matrix with the results of the callback function executed on\n   * each entry of the matrix.\n   * @memberof DenseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   *\n   * @return {DenseMatrix} matrix\n   */\n\n  DenseMatrix.prototype.map = function (callback) {\n    // matrix instance\n    var me = this;\n    var recurse = function recurse(value, index) {\n      if (isArray(value)) {\n        return value.map(function (child, i) {\n          return recurse(child, index.concat(i));\n        });\n      } else {\n        return callback(value, index, me);\n      }\n    }; // determine the new datatype when the original matrix has datatype defined\n    // TODO: should be done in matrix constructor instead\n\n    var data = recurse(this._data, []);\n    var datatype = this._datatype !== undefined ? getArrayDataType(data, typeOf) : undefined;\n    return new DenseMatrix(data, datatype);\n  };\n  /**\n   * Execute a callback function on each entry of the matrix.\n   * @memberof DenseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   */\n\n  DenseMatrix.prototype.forEach = function (callback) {\n    // matrix instance\n    var me = this;\n    var recurse = function recurse(value, index) {\n      if (isArray(value)) {\n        value.forEach(function (child, i) {\n          recurse(child, index.concat(i));\n        });\n      } else {\n        callback(value, index, me);\n      }\n    };\n    recurse(this._data, []);\n  };\n  /**\n   * Create an Array with a copy of the data of the DenseMatrix\n   * @memberof DenseMatrix\n   * @returns {Array} array\n   */\n\n  DenseMatrix.prototype.toArray = function () {\n    return clone(this._data);\n  };\n  /**\n   * Get the primitive value of the DenseMatrix: a multidimensional array\n   * @memberof DenseMatrix\n   * @returns {Array} array\n   */\n\n  DenseMatrix.prototype.valueOf = function () {\n    return this._data;\n  };\n  /**\n   * Get a string representation of the matrix, with optional formatting options.\n   * @memberof DenseMatrix\n   * @param {Object | number | Function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @returns {string} str\n   */\n\n  DenseMatrix.prototype.format = function (options) {\n    return format(this._data, options);\n  };\n  /**\n   * Get a string representation of the matrix\n   * @memberof DenseMatrix\n   * @returns {string} str\n   */\n\n  DenseMatrix.prototype.toString = function () {\n    return format(this._data);\n  };\n  /**\n   * Get a JSON representation of the matrix\n   * @memberof DenseMatrix\n   * @returns {Object}\n   */\n\n  DenseMatrix.prototype.toJSON = function () {\n    return {\n      mathjs: 'DenseMatrix',\n      data: this._data,\n      size: this._size,\n      datatype: this._datatype\n    };\n  };\n  /**\n   * Get the kth Matrix diagonal.\n   *\n   * @memberof DenseMatrix\n   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.\n   *\n   * @returns {Matrix}                     The matrix with the diagonal values.\n   */\n\n  DenseMatrix.prototype.diagonal = function (k) {\n    // validate k if any\n    if (k) {\n      // convert BigNumber to a number\n      if (isBigNumber(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n      if (!isNumber(k) || !isInteger(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows & columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // number diagonal values\n\n    var n = Math.min(rows - kSub, columns - kSuper); // x is a matrix get diagonal from matrix\n\n    var data = []; // loop rows\n\n    for (var i = 0; i < n; i++) {\n      data[i] = this._data[i + kSub][i + kSuper];\n    } // create DenseMatrix\n\n    return new DenseMatrix({\n      data: data,\n      size: [n],\n      datatype: this._datatype\n    });\n  };\n  /**\n   * Create a diagonal matrix.\n   *\n   * @memberof DenseMatrix\n   * @param {Array} size                     The matrix size.\n   * @param {number | Matrix | Array } value The values for the diagonal.\n   * @param {number | BigNumber} [k=0]       The kth diagonal where the vector will be filled in.\n   * @param {number} [defaultValue]          The default value for non-diagonal\n   * @param {string} [datatype]              The datatype for the diagonal\n   *\n   * @returns {DenseMatrix}\n   */\n\n  DenseMatrix.diagonal = function (size, value, k, defaultValue) {\n    if (!isArray(size)) {\n      throw new TypeError('Array expected, size parameter');\n    }\n    if (size.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    } // map size & validate\n\n    size = size.map(function (s) {\n      // check it is a big number\n      if (isBigNumber(s)) {\n        // convert it\n        s = s.toNumber();\n      } // validate arguments\n\n      if (!isNumber(s) || !isInteger(s) || s < 1) {\n        throw new Error('Size values must be positive integers');\n      }\n      return s;\n    }); // validate k if any\n\n    if (k) {\n      // convert BigNumber to a number\n      if (isBigNumber(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n      if (!isNumber(k) || !isInteger(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows and columns\n\n    var rows = size[0];\n    var columns = size[1]; // number of non-zero items\n\n    var n = Math.min(rows - kSub, columns - kSuper); // value extraction function\n\n    var _value; // check value\n\n    if (isArray(value)) {\n      // validate array\n      if (value.length !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid value array length');\n      } // define function\n\n      _value = function _value(i) {\n        // return value @ i\n        return value[i];\n      };\n    } else if (isMatrix(value)) {\n      // matrix size\n      var ms = value.size(); // validate matrix\n\n      if (ms.length !== 1 || ms[0] !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid matrix length');\n      } // define function\n\n      _value = function _value(i) {\n        // return value @ i\n        return value.get([i]);\n      };\n    } else {\n      // define function\n      _value = function _value() {\n        // return value\n        return value;\n      };\n    } // discover default value if needed\n\n    if (!defaultValue) {\n      // check first value in array\n      defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) // trick to create a BigNumber with value zero\n      : 0;\n    } // empty array\n\n    var data = []; // check we need to resize array\n\n    if (size.length > 0) {\n      // resize array\n      data = resize(data, size, defaultValue); // fill diagonal\n\n      for (var d = 0; d < n; d++) {\n        data[d + kSub][d + kSuper] = _value(d);\n      }\n    } // create DenseMatrix\n\n    return new DenseMatrix({\n      data: data,\n      size: [rows, columns]\n    });\n  };\n  /**\n   * Generate a matrix from a JSON object\n   * @memberof DenseMatrix\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"DenseMatrix\", data: [], size: []}`,\n   *                       where mathjs is optional\n   * @returns {DenseMatrix}\n   */\n\n  DenseMatrix.fromJSON = function (json) {\n    return new DenseMatrix(json);\n  };\n  /**\n   * Swap rows i and j in Matrix.\n   *\n   * @memberof DenseMatrix\n   * @param {number} i       Matrix row index 1\n   * @param {number} j       Matrix row index 2\n   *\n   * @return {Matrix}        The matrix reference\n   */\n\n  DenseMatrix.prototype.swapRows = function (i, j) {\n    // check index\n    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {\n      throw new Error('Row index must be positive integers');\n    } // check dimensions\n\n    if (this._size.length !== 2) {\n      throw new Error('Only two dimensional matrix is supported');\n    } // validate index\n\n    validateIndex(i, this._size[0]);\n    validateIndex(j, this._size[0]); // swap rows\n\n    DenseMatrix._swapRows(i, j, this._data); // return current instance\n\n    return this;\n  };\n  /**\n   * Swap rows i and j in Dense Matrix data structure.\n   *\n   * @param {number} i       Matrix row index 1\n   * @param {number} j       Matrix row index 2\n   * @param {Array} data     Matrix data\n   */\n\n  DenseMatrix._swapRows = function (i, j, data) {\n    // swap values i <-> j\n    var vi = data[i];\n    data[i] = data[j];\n    data[j] = vi;\n  };\n  /**\n   * Preprocess data, which can be an Array or DenseMatrix with nested Arrays and\n   * Matrices. Replaces all nested Matrices with Arrays\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @return {Array} data\n   */\n\n  function preprocess(data) {\n    for (var i = 0, ii = data.length; i < ii; i++) {\n      var elem = data[i];\n      if (isArray(elem)) {\n        data[i] = preprocess(elem);\n      } else if (elem && elem.isMatrix === true) {\n        data[i] = preprocess(elem.valueOf());\n      }\n    }\n    return data;\n  }\n  return DenseMatrix;\n}, {\n  isClass: true\n});","map":{"version":3,"names":["isArray","isBigNumber","isCollection","isIndex","isMatrix","isNumber","isString","typeOf","arraySize","getArrayDataType","reshape","resize","unsqueeze","validate","validateIndex","format","isInteger","clone","deepStrictEqual","DimensionError","factory","name","dependencies","createDenseMatrixClass","_ref","Matrix","DenseMatrix","data","datatype","SyntaxError","Error","type","_data","_size","_datatype","toArray","size","preprocess","TypeError","prototype","createDenseMatrix","isDenseMatrix","getDataType","storage","create","subset","index","replacement","defaultValue","arguments","length","_get","_set","get","x","i","ii","indexI","set","value","map","_fit","matrix","isScalar","min","max","_getSubmatrix","dims","dim","last","range","dimension","valueOf","child","submatrix","iSize","sSize","outer","_setSubmatrix","forEach","dataIndex","subIndex","copy","sizeArray","Array","m","_resize","v","slice","newSize","changed","push","callback","me","recurse","concat","undefined","options","toString","toJSON","mathjs","diagonal","k","toNumber","kSuper","kSub","rows","columns","n","Math","s","_value","ms","mul","d","fromJSON","json","swapRows","j","_swapRows","vi","elem","isClass"],"sources":["F:/extension/SEM 7/NN/Lab/my lab/Project/temp/app/node_modules/mathjs/es/type/matrix/DenseMatrix.js"],"sourcesContent":["import { isArray, isBigNumber, isCollection, isIndex, isMatrix, isNumber, isString, typeOf } from '../../utils/is';\nimport { arraySize, getArrayDataType, reshape, resize, unsqueeze, validate, validateIndex } from '../../utils/array';\nimport { format } from '../../utils/string';\nimport { isInteger } from '../../utils/number';\nimport { clone, deepStrictEqual } from '../../utils/object';\nimport { DimensionError } from '../../error/DimensionError';\nimport { factory } from '../../utils/factory';\nvar name = 'DenseMatrix';\nvar dependencies = ['Matrix'];\nexport var createDenseMatrixClass = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Matrix = _ref.Matrix;\n\n  /**\n   * Dense Matrix implementation. A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.\n   * @class DenseMatrix\n   */\n  function DenseMatrix(data, datatype) {\n    if (!(this instanceof DenseMatrix)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (datatype && !isString(datatype)) {\n      throw new Error('Invalid datatype: ' + datatype);\n    }\n\n    if (isMatrix(data)) {\n      // check data is a DenseMatrix\n      if (data.type === 'DenseMatrix') {\n        // clone data & size\n        this._data = clone(data._data);\n        this._size = clone(data._size);\n        this._datatype = datatype || data._datatype;\n      } else {\n        // build data from existing matrix\n        this._data = data.toArray();\n        this._size = data.size();\n        this._datatype = datatype || data._datatype;\n      }\n    } else if (data && isArray(data.data) && isArray(data.size)) {\n      // initialize fields from JSON representation\n      this._data = data.data;\n      this._size = data.size; // verify the dimensions of the array\n\n      validate(this._data, this._size);\n      this._datatype = datatype || data.datatype;\n    } else if (isArray(data)) {\n      // replace nested Matrices with Arrays\n      this._data = preprocess(data); // get the dimensions of the array\n\n      this._size = arraySize(this._data); // verify the dimensions of the array, TODO: compute size while processing array\n\n      validate(this._data, this._size); // data type unknown\n\n      this._datatype = datatype;\n    } else if (data) {\n      // unsupported type\n      throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');\n    } else {\n      // nothing provided\n      this._data = [];\n      this._size = [0];\n      this._datatype = datatype;\n    }\n  }\n\n  DenseMatrix.prototype = new Matrix();\n  /**\n   * Create a new DenseMatrix\n   */\n\n  DenseMatrix.prototype.createDenseMatrix = function (data, datatype) {\n    return new DenseMatrix(data, datatype);\n  };\n  /**\n   * Attach type information\n   */\n\n\n  DenseMatrix.prototype.type = 'DenseMatrix';\n  DenseMatrix.prototype.isDenseMatrix = true;\n  /**\n   * Get the matrix type\n   *\n   * Usage:\n   *    const matrixType = matrix.getDataType()  // retrieves the matrix type\n   *\n   * @memberOf DenseMatrix\n   * @return {string}   type information; if multiple types are found from the Matrix, it will return \"mixed\"\n   */\n\n  DenseMatrix.prototype.getDataType = function () {\n    return getArrayDataType(this._data, typeOf);\n  };\n  /**\n   * Get the storage format used by the matrix.\n   *\n   * Usage:\n   *     const format = matrix.storage()  // retrieve storage format\n   *\n   * @memberof DenseMatrix\n   * @return {string}           The storage format.\n   */\n\n\n  DenseMatrix.prototype.storage = function () {\n    return 'dense';\n  };\n  /**\n   * Get the datatype of the data stored in the matrix.\n   *\n   * Usage:\n   *     const format = matrix.datatype()   // retrieve matrix datatype\n   *\n   * @memberof DenseMatrix\n   * @return {string}           The datatype.\n   */\n\n\n  DenseMatrix.prototype.datatype = function () {\n    return this._datatype;\n  };\n  /**\n   * Create a new DenseMatrix\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @param {string} [datatype]\n   */\n\n\n  DenseMatrix.prototype.create = function (data, datatype) {\n    return new DenseMatrix(data, datatype);\n  };\n  /**\n   * Get a subset of the matrix, or replace a subset of the matrix.\n   *\n   * Usage:\n   *     const subset = matrix.subset(index)               // retrieve subset\n   *     const value = matrix.subset(index, replacement)   // replace subset\n   *\n   * @memberof DenseMatrix\n   * @param {Index} index\n   * @param {Array | Matrix | *} [replacement]\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be filled with zeros.\n   */\n\n\n  DenseMatrix.prototype.subset = function (index, replacement, defaultValue) {\n    switch (arguments.length) {\n      case 1:\n        return _get(this, index);\n      // intentional fall through\n\n      case 2:\n      case 3:\n        return _set(this, index, replacement, defaultValue);\n\n      default:\n        throw new SyntaxError('Wrong number of arguments');\n    }\n  };\n  /**\n   * Get a single element from the matrix.\n   * @memberof DenseMatrix\n   * @param {number[]} index   Zero-based index\n   * @return {*} value\n   */\n\n\n  DenseMatrix.prototype.get = function (index) {\n    if (!isArray(index)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (index.length !== this._size.length) {\n      throw new DimensionError(index.length, this._size.length);\n    } // check index\n\n\n    for (var x = 0; x < index.length; x++) {\n      validateIndex(index[x], this._size[x]);\n    }\n\n    var data = this._data;\n\n    for (var i = 0, ii = index.length; i < ii; i++) {\n      var indexI = index[i];\n      validateIndex(indexI, data.length);\n      data = data[indexI];\n    }\n\n    return data;\n  };\n  /**\n   * Replace a single element in the matrix.\n   * @memberof DenseMatrix\n   * @param {number[]} index   Zero-based index\n   * @param {*} value\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\n   *                                  the matrix is resized. If not provided,\n   *                                  new matrix elements will be left undefined.\n   * @return {DenseMatrix} self\n   */\n\n\n  DenseMatrix.prototype.set = function (index, value, defaultValue) {\n    if (!isArray(index)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (index.length < this._size.length) {\n      throw new DimensionError(index.length, this._size.length, '<');\n    }\n\n    var i, ii, indexI; // enlarge matrix when needed\n\n    var size = index.map(function (i) {\n      return i + 1;\n    });\n\n    _fit(this, size, defaultValue); // traverse over the dimensions\n\n\n    var data = this._data;\n\n    for (i = 0, ii = index.length - 1; i < ii; i++) {\n      indexI = index[i];\n      validateIndex(indexI, data.length);\n      data = data[indexI];\n    } // set new value\n\n\n    indexI = index[index.length - 1];\n    validateIndex(indexI, data.length);\n    data[indexI] = value;\n    return this;\n  };\n  /**\n   * Get a submatrix of this matrix\n   * @memberof DenseMatrix\n   * @param {DenseMatrix} matrix\n   * @param {Index} index   Zero-based index\n   * @private\n   */\n\n\n  function _get(matrix, index) {\n    if (!isIndex(index)) {\n      throw new TypeError('Invalid index');\n    }\n\n    var isScalar = index.isScalar();\n\n    if (isScalar) {\n      // return a scalar\n      return matrix.get(index.min());\n    } else {\n      // validate dimensions\n      var size = index.size();\n\n      if (size.length !== matrix._size.length) {\n        throw new DimensionError(size.length, matrix._size.length);\n      } // validate if any of the ranges in the index is out of range\n\n\n      var min = index.min();\n      var max = index.max();\n\n      for (var i = 0, ii = matrix._size.length; i < ii; i++) {\n        validateIndex(min[i], matrix._size[i]);\n        validateIndex(max[i], matrix._size[i]);\n      } // retrieve submatrix\n      // TODO: more efficient when creating an empty matrix and setting _data and _size manually\n\n\n      return new DenseMatrix(_getSubmatrix(matrix._data, index, size.length, 0), matrix._datatype);\n    }\n  }\n  /**\n   * Recursively get a submatrix of a multi dimensional matrix.\n   * Index is not checked for correct number or length of dimensions.\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @param {Index} index\n   * @param {number} dims   Total number of dimensions\n   * @param {number} dim    Current dimension\n   * @return {Array} submatrix\n   * @private\n   */\n\n\n  function _getSubmatrix(data, index, dims, dim) {\n    var last = dim === dims - 1;\n    var range = index.dimension(dim);\n\n    if (last) {\n      return range.map(function (i) {\n        validateIndex(i, data.length);\n        return data[i];\n      }).valueOf();\n    } else {\n      return range.map(function (i) {\n        validateIndex(i, data.length);\n        var child = data[i];\n        return _getSubmatrix(child, index, dims, dim + 1);\n      }).valueOf();\n    }\n  }\n  /**\n   * Replace a submatrix in this matrix\n   * Indexes are zero-based.\n   * @memberof DenseMatrix\n   * @param {DenseMatrix} matrix\n   * @param {Index} index\n   * @param {DenseMatrix | Array | *} submatrix\n   * @param {*} defaultValue          Default value, filled in on new entries when\n   *                                  the matrix is resized.\n   * @return {DenseMatrix} matrix\n   * @private\n   */\n\n\n  function _set(matrix, index, submatrix, defaultValue) {\n    if (!index || index.isIndex !== true) {\n      throw new TypeError('Invalid index');\n    } // get index size and check whether the index contains a single value\n\n\n    var iSize = index.size();\n    var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed\n\n    var sSize;\n\n    if (isMatrix(submatrix)) {\n      sSize = submatrix.size();\n      submatrix = submatrix.valueOf();\n    } else {\n      sSize = arraySize(submatrix);\n    }\n\n    if (isScalar) {\n      // set a scalar\n      // check whether submatrix is a scalar\n      if (sSize.length !== 0) {\n        throw new TypeError('Scalar expected');\n      }\n\n      matrix.set(index.min(), submatrix, defaultValue);\n    } else {\n      // set a submatrix\n      // validate dimensions\n      if (iSize.length < matrix._size.length) {\n        throw new DimensionError(iSize.length, matrix._size.length, '<');\n      }\n\n      if (sSize.length < iSize.length) {\n        // calculate number of missing outer dimensions\n        var i = 0;\n        var outer = 0;\n\n        while (iSize[i] === 1 && sSize[i] === 1) {\n          i++;\n        }\n\n        while (iSize[i] === 1) {\n          outer++;\n          i++;\n        } // unsqueeze both outer and inner dimensions\n\n\n        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);\n      } // check whether the size of the submatrix matches the index size\n\n\n      if (!deepStrictEqual(iSize, sSize)) {\n        throw new DimensionError(iSize, sSize, '>');\n      } // enlarge matrix when needed\n\n\n      var size = index.max().map(function (i) {\n        return i + 1;\n      });\n\n      _fit(matrix, size, defaultValue); // insert the sub matrix\n\n\n      var dims = iSize.length;\n      var dim = 0;\n\n      _setSubmatrix(matrix._data, index, submatrix, dims, dim);\n    }\n\n    return matrix;\n  }\n  /**\n   * Replace a submatrix of a multi dimensional matrix.\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @param {Index} index\n   * @param {Array} submatrix\n   * @param {number} dims   Total number of dimensions\n   * @param {number} dim\n   * @private\n   */\n\n\n  function _setSubmatrix(data, index, submatrix, dims, dim) {\n    var last = dim === dims - 1;\n    var range = index.dimension(dim);\n\n    if (last) {\n      range.forEach(function (dataIndex, subIndex) {\n        validateIndex(dataIndex);\n        data[dataIndex] = submatrix[subIndex[0]];\n      });\n    } else {\n      range.forEach(function (dataIndex, subIndex) {\n        validateIndex(dataIndex);\n\n        _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);\n      });\n    }\n  }\n  /**\n   * Resize the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (resize in place).\n   *\n   * @memberof DenseMatrix\n   * @param {number[] || Matrix} size The new size the matrix should have.\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\n   *                                  If not provided, the matrix elements will\n   *                                  be filled with zeros.\n   * @param {boolean} [copy]          Return a resized copy of the matrix\n   *\n   * @return {Matrix}                 The resized matrix\n   */\n\n\n  DenseMatrix.prototype.resize = function (size, defaultValue, copy) {\n    // validate arguments\n    if (!isCollection(size)) {\n      throw new TypeError('Array or Matrix expected');\n    } // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector\n\n\n    var sizeArray = size.valueOf().map(function (value) {\n      return Array.isArray(value) && value.length === 1 ? value[0] : value;\n    }); // matrix to resize\n\n    var m = copy ? this.clone() : this; // resize matrix\n\n    return _resize(m, sizeArray, defaultValue);\n  };\n\n  function _resize(matrix, size, defaultValue) {\n    // check size\n    if (size.length === 0) {\n      // first value in matrix\n      var v = matrix._data; // go deep\n\n      while (isArray(v)) {\n        v = v[0];\n      }\n\n      return v;\n    } // resize matrix\n\n\n    matrix._size = size.slice(0); // copy the array\n\n    matrix._data = resize(matrix._data, matrix._size, defaultValue); // return matrix\n\n    return matrix;\n  }\n  /**\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\n   *\n   * NOTE: This might be better suited to copy by default, instead of modifying\n   *       in place. For now, it operates in place to remain consistent with\n   *       resize().\n   *\n   * @memberof DenseMatrix\n   * @param {number[]} size           The new size the matrix should have.\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\n   *\n   * @return {Matrix}                 The reshaped matrix\n   */\n\n\n  DenseMatrix.prototype.reshape = function (size, copy) {\n    var m = copy ? this.clone() : this;\n    m._data = reshape(m._data, size);\n    m._size = size.slice(0);\n    return m;\n  };\n  /**\n   * Enlarge the matrix when it is smaller than given size.\n   * If the matrix is larger or equal sized, nothing is done.\n   * @memberof DenseMatrix\n   * @param {DenseMatrix} matrix           The matrix to be resized\n   * @param {number[]} size\n   * @param {*} defaultValue          Default value, filled in on new entries.\n   * @private\n   */\n\n\n  function _fit(matrix, size, defaultValue) {\n    var // copy the array\n    newSize = matrix._size.slice(0);\n\n    var changed = false; // add dimensions when needed\n\n    while (newSize.length < size.length) {\n      newSize.push(0);\n      changed = true;\n    } // enlarge size when needed\n\n\n    for (var i = 0, ii = size.length; i < ii; i++) {\n      if (size[i] > newSize[i]) {\n        newSize[i] = size[i];\n        changed = true;\n      }\n    }\n\n    if (changed) {\n      // resize only when size is changed\n      _resize(matrix, newSize, defaultValue);\n    }\n  }\n  /**\n   * Create a clone of the matrix\n   * @memberof DenseMatrix\n   * @return {DenseMatrix} clone\n   */\n\n\n  DenseMatrix.prototype.clone = function () {\n    var m = new DenseMatrix({\n      data: clone(this._data),\n      size: clone(this._size),\n      datatype: this._datatype\n    });\n    return m;\n  };\n  /**\n   * Retrieve the size of the matrix.\n   * @memberof DenseMatrix\n   * @returns {number[]} size\n   */\n\n\n  DenseMatrix.prototype.size = function () {\n    return this._size.slice(0); // return a clone of _size\n  };\n  /**\n   * Create a new matrix with the results of the callback function executed on\n   * each entry of the matrix.\n   * @memberof DenseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   *\n   * @return {DenseMatrix} matrix\n   */\n\n\n  DenseMatrix.prototype.map = function (callback) {\n    // matrix instance\n    var me = this;\n\n    var recurse = function recurse(value, index) {\n      if (isArray(value)) {\n        return value.map(function (child, i) {\n          return recurse(child, index.concat(i));\n        });\n      } else {\n        return callback(value, index, me);\n      }\n    }; // determine the new datatype when the original matrix has datatype defined\n    // TODO: should be done in matrix constructor instead\n\n\n    var data = recurse(this._data, []);\n    var datatype = this._datatype !== undefined ? getArrayDataType(data, typeOf) : undefined;\n    return new DenseMatrix(data, datatype);\n  };\n  /**\n   * Execute a callback function on each entry of the matrix.\n   * @memberof DenseMatrix\n   * @param {Function} callback   The callback function is invoked with three\n   *                              parameters: the value of the element, the index\n   *                              of the element, and the Matrix being traversed.\n   */\n\n\n  DenseMatrix.prototype.forEach = function (callback) {\n    // matrix instance\n    var me = this;\n\n    var recurse = function recurse(value, index) {\n      if (isArray(value)) {\n        value.forEach(function (child, i) {\n          recurse(child, index.concat(i));\n        });\n      } else {\n        callback(value, index, me);\n      }\n    };\n\n    recurse(this._data, []);\n  };\n  /**\n   * Create an Array with a copy of the data of the DenseMatrix\n   * @memberof DenseMatrix\n   * @returns {Array} array\n   */\n\n\n  DenseMatrix.prototype.toArray = function () {\n    return clone(this._data);\n  };\n  /**\n   * Get the primitive value of the DenseMatrix: a multidimensional array\n   * @memberof DenseMatrix\n   * @returns {Array} array\n   */\n\n\n  DenseMatrix.prototype.valueOf = function () {\n    return this._data;\n  };\n  /**\n   * Get a string representation of the matrix, with optional formatting options.\n   * @memberof DenseMatrix\n   * @param {Object | number | Function} [options]  Formatting options. See\n   *                                                lib/utils/number:format for a\n   *                                                description of the available\n   *                                                options.\n   * @returns {string} str\n   */\n\n\n  DenseMatrix.prototype.format = function (options) {\n    return format(this._data, options);\n  };\n  /**\n   * Get a string representation of the matrix\n   * @memberof DenseMatrix\n   * @returns {string} str\n   */\n\n\n  DenseMatrix.prototype.toString = function () {\n    return format(this._data);\n  };\n  /**\n   * Get a JSON representation of the matrix\n   * @memberof DenseMatrix\n   * @returns {Object}\n   */\n\n\n  DenseMatrix.prototype.toJSON = function () {\n    return {\n      mathjs: 'DenseMatrix',\n      data: this._data,\n      size: this._size,\n      datatype: this._datatype\n    };\n  };\n  /**\n   * Get the kth Matrix diagonal.\n   *\n   * @memberof DenseMatrix\n   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.\n   *\n   * @returns {Matrix}                     The matrix with the diagonal values.\n   */\n\n\n  DenseMatrix.prototype.diagonal = function (k) {\n    // validate k if any\n    if (k) {\n      // convert BigNumber to a number\n      if (isBigNumber(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n\n      if (!isNumber(k) || !isInteger(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows & columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // number diagonal values\n\n    var n = Math.min(rows - kSub, columns - kSuper); // x is a matrix get diagonal from matrix\n\n    var data = []; // loop rows\n\n    for (var i = 0; i < n; i++) {\n      data[i] = this._data[i + kSub][i + kSuper];\n    } // create DenseMatrix\n\n\n    return new DenseMatrix({\n      data: data,\n      size: [n],\n      datatype: this._datatype\n    });\n  };\n  /**\n   * Create a diagonal matrix.\n   *\n   * @memberof DenseMatrix\n   * @param {Array} size                     The matrix size.\n   * @param {number | Matrix | Array } value The values for the diagonal.\n   * @param {number | BigNumber} [k=0]       The kth diagonal where the vector will be filled in.\n   * @param {number} [defaultValue]          The default value for non-diagonal\n   * @param {string} [datatype]              The datatype for the diagonal\n   *\n   * @returns {DenseMatrix}\n   */\n\n\n  DenseMatrix.diagonal = function (size, value, k, defaultValue) {\n    if (!isArray(size)) {\n      throw new TypeError('Array expected, size parameter');\n    }\n\n    if (size.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    } // map size & validate\n\n\n    size = size.map(function (s) {\n      // check it is a big number\n      if (isBigNumber(s)) {\n        // convert it\n        s = s.toNumber();\n      } // validate arguments\n\n\n      if (!isNumber(s) || !isInteger(s) || s < 1) {\n        throw new Error('Size values must be positive integers');\n      }\n\n      return s;\n    }); // validate k if any\n\n    if (k) {\n      // convert BigNumber to a number\n      if (isBigNumber(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n\n      if (!isNumber(k) || !isInteger(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows and columns\n\n    var rows = size[0];\n    var columns = size[1]; // number of non-zero items\n\n    var n = Math.min(rows - kSub, columns - kSuper); // value extraction function\n\n    var _value; // check value\n\n\n    if (isArray(value)) {\n      // validate array\n      if (value.length !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid value array length');\n      } // define function\n\n\n      _value = function _value(i) {\n        // return value @ i\n        return value[i];\n      };\n    } else if (isMatrix(value)) {\n      // matrix size\n      var ms = value.size(); // validate matrix\n\n      if (ms.length !== 1 || ms[0] !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid matrix length');\n      } // define function\n\n\n      _value = function _value(i) {\n        // return value @ i\n        return value.get([i]);\n      };\n    } else {\n      // define function\n      _value = function _value() {\n        // return value\n        return value;\n      };\n    } // discover default value if needed\n\n\n    if (!defaultValue) {\n      // check first value in array\n      defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) // trick to create a BigNumber with value zero\n      : 0;\n    } // empty array\n\n\n    var data = []; // check we need to resize array\n\n    if (size.length > 0) {\n      // resize array\n      data = resize(data, size, defaultValue); // fill diagonal\n\n      for (var d = 0; d < n; d++) {\n        data[d + kSub][d + kSuper] = _value(d);\n      }\n    } // create DenseMatrix\n\n\n    return new DenseMatrix({\n      data: data,\n      size: [rows, columns]\n    });\n  };\n  /**\n   * Generate a matrix from a JSON object\n   * @memberof DenseMatrix\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"DenseMatrix\", data: [], size: []}`,\n   *                       where mathjs is optional\n   * @returns {DenseMatrix}\n   */\n\n\n  DenseMatrix.fromJSON = function (json) {\n    return new DenseMatrix(json);\n  };\n  /**\n   * Swap rows i and j in Matrix.\n   *\n   * @memberof DenseMatrix\n   * @param {number} i       Matrix row index 1\n   * @param {number} j       Matrix row index 2\n   *\n   * @return {Matrix}        The matrix reference\n   */\n\n\n  DenseMatrix.prototype.swapRows = function (i, j) {\n    // check index\n    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {\n      throw new Error('Row index must be positive integers');\n    } // check dimensions\n\n\n    if (this._size.length !== 2) {\n      throw new Error('Only two dimensional matrix is supported');\n    } // validate index\n\n\n    validateIndex(i, this._size[0]);\n    validateIndex(j, this._size[0]); // swap rows\n\n    DenseMatrix._swapRows(i, j, this._data); // return current instance\n\n\n    return this;\n  };\n  /**\n   * Swap rows i and j in Dense Matrix data structure.\n   *\n   * @param {number} i       Matrix row index 1\n   * @param {number} j       Matrix row index 2\n   * @param {Array} data     Matrix data\n   */\n\n\n  DenseMatrix._swapRows = function (i, j, data) {\n    // swap values i <-> j\n    var vi = data[i];\n    data[i] = data[j];\n    data[j] = vi;\n  };\n  /**\n   * Preprocess data, which can be an Array or DenseMatrix with nested Arrays and\n   * Matrices. Replaces all nested Matrices with Arrays\n   * @memberof DenseMatrix\n   * @param {Array} data\n   * @return {Array} data\n   */\n\n\n  function preprocess(data) {\n    for (var i = 0, ii = data.length; i < ii; i++) {\n      var elem = data[i];\n\n      if (isArray(elem)) {\n        data[i] = preprocess(elem);\n      } else if (elem && elem.isMatrix === true) {\n        data[i] = preprocess(elem.valueOf());\n      }\n    }\n\n    return data;\n  }\n\n  return DenseMatrix;\n}, {\n  isClass: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}