{"ast":null,"code":"/**\n * @license\n * Copyright 2022 CodeSmith LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { serialization, unstack, stack, tensor, tidy, range, image } from '@tensorflow/tfjs-core';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../../utils/types_utils';\nimport { Layer } from '../../engine/topology';\nimport * as K from '../../backend/tfjs_backend';\nconst {\n  resizeBilinear,\n  cropAndResize\n} = image;\nexport class CenterCrop extends Layer {\n  constructor(args) {\n    super(args);\n    this.height = args.height;\n    this.width = args.width;\n  }\n  centerCrop(inputs, hBuffer, wBuffer, height, width, inputHeight, inputWidth, dtype) {\n    return tidy(() => {\n      let input;\n      let isRank3 = false;\n      const top = hBuffer / inputHeight;\n      const left = wBuffer / inputWidth;\n      const bottom = (height + hBuffer) / inputHeight;\n      const right = (width + wBuffer) / inputWidth;\n      const bound = [top, left, bottom, right];\n      const boxesArr = [];\n      if (inputs.rank === 3) {\n        isRank3 = true;\n        input = stack([inputs]);\n      } else {\n        input = inputs;\n      }\n      for (let i = 0; i < input.shape[0]; i++) {\n        boxesArr.push(bound);\n      }\n      const boxes = tensor(boxesArr, [boxesArr.length, 4]);\n      const boxInd = range(0, boxesArr.length, 1, 'int32');\n      const cropSize = [height, width];\n      const cropped = cropAndResize(input, boxes, boxInd, cropSize, 'nearest');\n      if (isRank3) {\n        return K.cast(getExactlyOneTensor(unstack(cropped)), dtype);\n      }\n      return K.cast(cropped, dtype);\n    });\n  }\n  upsize(inputs, height, width, dtype) {\n    return tidy(() => {\n      const outputs = resizeBilinear(inputs, [height, width]);\n      return K.cast(outputs, dtype);\n    });\n  }\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const rankedInputs = getExactlyOneTensor(inputs);\n      const dtype = rankedInputs.dtype;\n      const inputShape = rankedInputs.shape;\n      const inputHeight = inputShape[inputShape.length - 3];\n      const inputWidth = inputShape[inputShape.length - 2];\n      let hBuffer = 0;\n      if (inputHeight !== this.height) {\n        hBuffer = Math.floor((inputHeight - this.height) / 2);\n      }\n      let wBuffer = 0;\n      if (inputWidth !== this.width) {\n        wBuffer = Math.floor((inputWidth - this.width) / 2);\n        if (wBuffer === 0) {\n          wBuffer = 1;\n        }\n      }\n      if (hBuffer >= 0 && wBuffer >= 0) {\n        return this.centerCrop(rankedInputs, hBuffer, wBuffer, this.height, this.width, inputHeight, inputWidth, dtype);\n      } else {\n        return this.upsize(inputs, this.height, this.width, dtype);\n      }\n    });\n  }\n  getConfig() {\n    const config = {\n      'height': this.height,\n      'width': this.width\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    const hAxis = inputShape.length - 3;\n    const wAxis = inputShape.length - 2;\n    inputShape[hAxis] = this.height;\n    inputShape[wAxis] = this.width;\n    return inputShape;\n  }\n}\n/** @nocollapse */\nCenterCrop.className = 'CenterCrop';\nserialization.registerClass(CenterCrop);","map":{"version":3,"sources":["../../../../../../../tfjs-layers/src/layers/preprocessing/center_crop.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2022 CodeSmith LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\nimport {serialization,DataType,unstack,stack,tensor,Tensor,Tensor1D,Tensor2D, Tensor3D, Tensor4D, tidy, range, image} from '@tensorflow/tfjs-core';\nimport {getExactlyOneShape, getExactlyOneTensor} from '../../utils/types_utils';\nimport {LayerArgs, Layer} from '../../engine/topology';\nimport {Kwargs} from '../../types';\nimport {Shape} from '../../keras_format/common';\nimport * as K from '../../backend/tfjs_backend';\n\nconst {resizeBilinear, cropAndResize} = image;\n\nexport declare interface CenterCropArgs extends LayerArgs{\n  height: number;\n  width: number;\n}\n\nexport class CenterCrop extends Layer {\n  /** @nocollapse */\n  static className = 'CenterCrop';\n  private readonly height: number;\n  private readonly width: number;\n  constructor(args: CenterCropArgs) {\n    super(args);\n    this.height = args.height;\n    this.width = args.width;\n  }\n\n  centerCrop(inputs: Tensor3D | Tensor4D, hBuffer: number, wBuffer: number,\n            height: number, width: number, inputHeight: number,\n            inputWidth: number, dtype: DataType): Tensor | Tensor[] {\n\n    return tidy(() => {\n      let input: Tensor4D;\n      let isRank3      = false;\n      const top      = hBuffer / inputHeight;\n      const left     = wBuffer / inputWidth;\n      const bottom   = ((height) + hBuffer) / inputHeight;\n      const right    = ((width) + wBuffer) / inputWidth;\n      const bound    = [top, left, bottom, right];\n      const boxesArr = [];\n\n      if(inputs.rank === 3) {\n        isRank3  = true;\n        input  = stack([inputs]) as Tensor4D;\n      } else {\n        input = inputs as Tensor4D;\n      }\n\n      for (let i = 0; i < input.shape[0]; i++) {\n        boxesArr.push(bound);\n      }\n\n      const boxes: Tensor2D  = tensor(boxesArr, [boxesArr.length, 4]);\n      const boxInd: Tensor1D = range(0, boxesArr.length, 1, 'int32');\n\n      const cropSize: [number, number] = [height, width];\n      const cropped = cropAndResize(input, boxes, boxInd, cropSize, 'nearest');\n\n      if(isRank3) {\n        return K.cast(getExactlyOneTensor(unstack(cropped)), dtype);\n      }\n      return K.cast(cropped, dtype);\n   });\n\n  }\n\n  upsize(inputs : Tensor3D | Tensor4D, height: number,\n         width: number, dtype: DataType): Tensor | Tensor[] {\n\n    return tidy(() => {\n      const outputs = resizeBilinear(inputs, [height, width]);\n      return K.cast(outputs, dtype);\n  });\n\n}\n\n  override call(inputs: Tensor3D | Tensor4D , kwargs: Kwargs):\n      Tensor[] | Tensor {\n    return tidy(() => {\n      const rankedInputs = getExactlyOneTensor(inputs) as Tensor3D | Tensor4D;\n      const dtype       = rankedInputs.dtype;\n      const inputShape  = rankedInputs.shape;\n      const inputHeight = inputShape[inputShape.length - 3];\n      const inputWidth  =  inputShape[inputShape.length - 2];\n\n      let hBuffer = 0;\n      if (inputHeight !== this.height) {\n        hBuffer =  Math.floor((inputHeight - this.height) / 2);\n      }\n\n      let wBuffer = 0;\n      if (inputWidth !== this.width) {\n        wBuffer = Math.floor((inputWidth - this.width) / 2);\n\n        if (wBuffer === 0) {\n          wBuffer = 1;\n        }\n      }\n\n      if(hBuffer >= 0 && wBuffer >= 0) {\n        return this.centerCrop(rankedInputs, hBuffer, wBuffer,\n                              this.height, this.width, inputHeight,\n                              inputWidth, dtype);\n      } else {\n        return this.upsize(inputs, this.height, this.width, dtype);\n      }\n   });\n\n  }\n\n  override getConfig(): serialization.ConfigDict{\n\n    const config: serialization.ConfigDict = {\n      'height' : this.height,\n      'width' : this.width\n    };\n\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n  override computeOutputShape(inputShape: Shape | Shape[]): Shape | Shape[] {\n    inputShape = getExactlyOneShape(inputShape);\n    const hAxis = inputShape.length - 3;\n    const wAxis = inputShape.length - 2;\n    inputShape[hAxis] = this.height;\n    inputShape[wAxis] = this.width;\n    return inputShape;\n  }\n}\n\nserialization.registerClass(CenterCrop);\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}