{"ast":null,"code":"import { EventEmitter } from \"events\";\nimport fillInPrediction from \"./imageRecognition/tensorflow\";\nimport SudokuSolver from \"./solver/sudokuSolver\";\nimport getLargestConnectedComponent from \"./imageProcessing/getLargestConnectedComponent\";\nimport findHomographicTransform, { transformPoint } from \"./imageProcessing/findHomographicTransform\";\nimport captureImage from \"./imageProcessing/captureImage\";\nimport adaptiveThreshold from \"./imageProcessing/adaptiveThreshold\";\nimport getCornerPoints from \"./imageProcessing/getCornerPoints\";\nimport extractSquareFromRegion from \"./imageProcessing/applyHomographicTransform\";\nimport extractBoxes from \"./imageProcessing/extractBoxes\";\nconst MIN_BOXES = 15;\nconst PROCESSING_SIZE = 900;\nexport default class Processor extends EventEmitter {\n  constructor() {\n    super(...arguments);\n    this.video = void 0;\n    this.isVideoRunning = false;\n    this.isProcessing = false;\n    this.corners = void 0;\n    this.gridLines = void 0;\n    this.solvedPuzzle = void 0;\n    this.captureTime = 0;\n    this.thresholdTime = 0;\n    this.connectedComponentTime = 0;\n    this.cornerPointTime = 0;\n    this.extractPuzzleTime = 0;\n    this.extractBoxesTime = 0;\n    this.neuralNetTime = 0;\n    this.solveTime = 0;\n  }\n  async startVideo(video) {\n    this.video = video;\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: {\n        facingMode: \"environment\",\n        width: 640\n      },\n      audio: false\n    });\n    const canPlayListener = () => {\n      this.video.removeEventListener(\"canplay\", canPlayListener);\n      this.emit(\"videoReady\", {\n        width: this.video.videoWidth,\n        height: this.video.videoHeight\n      });\n      this.isVideoRunning = true;\n      this.processFrame();\n    };\n    this.video.addEventListener(\"canplay\", canPlayListener);\n    this.video.srcObject = stream;\n    this.video.play();\n  }\n  createGridLines(transform) {\n    const boxSize = PROCESSING_SIZE / 9;\n    const gridLines = [];\n    for (let l = 1; l < 9; l++) {\n      gridLines.push({\n        p1: transformPoint({\n          x: 0,\n          y: l * boxSize\n        }, transform),\n        p2: transformPoint({\n          x: PROCESSING_SIZE,\n          y: l * boxSize\n        }, transform)\n      });\n      gridLines.push({\n        p1: transformPoint({\n          y: 0,\n          x: l * boxSize\n        }, transform),\n        p2: transformPoint({\n          y: PROCESSING_SIZE,\n          x: l * boxSize\n        }, transform)\n      });\n    }\n    return gridLines;\n  }\n  getTextDetailsForBox(x, y, digit, isKnown, transform) {\n    const boxSize = PROCESSING_SIZE / 9;\n    const p1 = transformPoint({\n      x: (x + 0.5) * boxSize,\n      y: y * boxSize\n    }, transform);\n    const p2 = transformPoint({\n      x: (x + 0.5) * boxSize,\n      y: (y + 1) * boxSize\n    }, transform);\n    const textPosition = transformPoint({\n      x: (x + 0.5) * boxSize,\n      y: (y + 0.5) * boxSize\n    }, transform);\n    const dx = p1.x - p2.x;\n    const dy = p1.y - p2.y;\n    const digitRotation = Math.atan2(dx, dy);\n    const digitHeight = 0.8 * Math.sqrt(dx * dx + dy * dy);\n    return {\n      digit,\n      digitHeight,\n      digitRotation,\n      isKnown: isKnown,\n      position: textPosition\n    };\n  }\n  createSolvedPuzzle(solver, transform) {\n    const results = new Array(9);\n    for (let y = 0; y < 9; y++) {\n      results[y] = new Array(9);\n    }\n    solver.solution.forEach(sol => {\n      const {\n        x,\n        y,\n        entry,\n        isKnown\n      } = sol.guess;\n      results[y][x] = this.getTextDetailsForBox(x, y, entry, isKnown, transform);\n    });\n    return results;\n  }\n  sanityCheckCorners(_ref) {\n    let {\n      topLeft,\n      topRight,\n      bottomLeft,\n      bottomRight\n    } = _ref;\n    function length(p1, p2) {\n      const dx = p1.x - p2.x;\n      const dy = p1.y - p2.y;\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n    const topLineLength = length(topLeft, topRight);\n    const leftLineLength = length(topLeft, bottomLeft);\n    const rightLineLength = length(topRight, bottomRight);\n    const bottomLineLength = length(bottomLeft, bottomRight);\n    if (topLineLength < 0.5 * bottomLineLength || topLineLength > 1.5 * bottomLineLength) return false;\n    if (leftLineLength < 0.7 * rightLineLength || leftLineLength > 1.3 * rightLineLength) return false;\n    if (leftLineLength < 0.5 * bottomLineLength || leftLineLength > 1.5 * bottomLineLength) return false;\n    return true;\n  }\n  async processFrame() {\n    if (!this.isVideoRunning) {\n      return;\n    }\n    if (this.isProcessing) {\n      return;\n    }\n    try {\n      let startTime = performance.now();\n      const image = captureImage(this.video);\n      this.captureTime = 0.1 * (performance.now() - startTime) + this.captureTime * 0.9;\n      startTime = performance.now();\n      const thresholded = adaptiveThreshold(image.clone(), 20, 20);\n      this.thresholdTime = 0.1 * (performance.now() - startTime) + this.thresholdTime * 0.9;\n      startTime = performance.now();\n      const largestConnectedComponent = getLargestConnectedComponent(thresholded, {\n        minAspectRatio: 0.5,\n        maxAspectRatio: 1.5,\n        minSize: Math.min(this.video.videoWidth, this.video.videoHeight) * 0.3,\n        maxSize: Math.min(this.video.videoWidth, this.video.videoHeight) * 0.9\n      });\n      this.connectedComponentTime = 0.1 * (performance.now() - startTime) + this.connectedComponentTime * 0.9;\n\n      // if we actually found something\n      if (largestConnectedComponent) {\n        // make a guess at where the corner points are using manhattan distance\n        startTime = performance.now();\n        const potentialCorners = getCornerPoints(largestConnectedComponent);\n        this.cornerPointTime = 0.1 * (performance.now() - startTime) + this.cornerPointTime * 0.9;\n        if (this.sanityCheckCorners(potentialCorners)) {\n          this.corners = potentialCorners;\n\n          // compute the transform to go from a square puzzle of size PROCESSING_SIZE to the detected corner points\n          startTime = performance.now();\n          const transform = findHomographicTransform(PROCESSING_SIZE, this.corners);\n\n          // we've got the transform so we can show where the gridlines are\n          this.gridLines = this.createGridLines(transform);\n\n          // extract the square puzzle from the original grey image\n          const extractedImageGreyScale = extractSquareFromRegion(image, PROCESSING_SIZE, transform);\n          // extract the square puzzle from the thresholded image - we'll use the thresholded image for determining where the digits are in the cells\n          const extractedImageThresholded = extractSquareFromRegion(thresholded, PROCESSING_SIZE, transform);\n          this.extractPuzzleTime = 0.1 * (performance.now() - startTime) + this.extractPuzzleTime * 0.9;\n\n          // extract the boxes that should contain the numbers\n          startTime = performance.now();\n          const boxes = extractBoxes(extractedImageGreyScale, extractedImageThresholded);\n          this.extractBoxesTime = 0.1 * (performance.now() - startTime) + this.extractBoxesTime * 0.9;\n\n          // did we find sufficient boxes for a potentially valid sudoku puzzle?\n          if (boxes.length > MIN_BOXES) {\n            // apply the neural network to the found boxes and work out what the digits are\n            startTime = performance.now();\n            await fillInPrediction(boxes);\n            this.neuralNetTime = 0.1 * (performance.now() - startTime) + this.neuralNetTime * 0.9;\n\n            // solve the suoku puzzle using the dancing links and algorithm X - https://en.wikipedia.org/wiki/Knuth%27s_Algorithm_X\n            startTime = performance.now();\n            const solver = new SudokuSolver();\n            // set the known values\n            boxes.forEach(box => {\n              if (box.contents !== 0) {\n                solver.setNumber(box.x, box.y, box.contents - 1);\n              }\n            });\n            // search for a solution\n            if (solver.search(0)) {\n              this.solvedPuzzle = this.createSolvedPuzzle(solver, transform);\n            } else {\n              this.solvedPuzzle = null;\n            }\n            this.solveTime = 0.1 * (performance.now() - startTime) + this.solveTime * 0.9;\n          }\n        } else {\n          this.corners = null;\n          this.gridLines = null;\n          this.solvedPuzzle = null;\n        }\n      } else {\n        this.corners = null;\n        this.gridLines = null;\n        this.solvedPuzzle = null;\n      }\n    } catch (error) {\n      console.error(error);\n    }\n    this.isProcessing = false;\n    // process again\n    setTimeout(() => this.processFrame(), 20);\n  }\n}","map":{"version":3,"names":["EventEmitter","fillInPrediction","SudokuSolver","getLargestConnectedComponent","findHomographicTransform","transformPoint","captureImage","adaptiveThreshold","getCornerPoints","extractSquareFromRegion","extractBoxes","MIN_BOXES","PROCESSING_SIZE","Processor","video","isVideoRunning","isProcessing","corners","gridLines","solvedPuzzle","captureTime","thresholdTime","connectedComponentTime","cornerPointTime","extractPuzzleTime","extractBoxesTime","neuralNetTime","solveTime","startVideo","stream","navigator","mediaDevices","getUserMedia","facingMode","width","audio","canPlayListener","removeEventListener","emit","videoWidth","height","videoHeight","processFrame","addEventListener","srcObject","play","createGridLines","transform","boxSize","l","push","p1","x","y","p2","getTextDetailsForBox","digit","isKnown","textPosition","dx","dy","digitRotation","Math","atan2","digitHeight","sqrt","position","createSolvedPuzzle","solver","results","Array","solution","forEach","sol","entry","guess","sanityCheckCorners","topLeft","topRight","bottomLeft","bottomRight","length","topLineLength","leftLineLength","rightLineLength","bottomLineLength","startTime","performance","now","image","thresholded","clone","largestConnectedComponent","minAspectRatio","maxAspectRatio","minSize","min","maxSize","potentialCorners","extractedImageGreyScale","extractedImageThresholded","boxes","box","contents","setNumber","search","error","console","setTimeout"],"sources":["F:/extension/SEM 7/NN/Lab/my lab/P/temp/app/src/setiaSudokuSolver/Processor.ts"],"sourcesContent":["import StrictEventEmitter from \"strict-event-emitter-types\";\nimport { EventEmitter } from \"events\";\nimport fillInPrediction from \"./imageRecognition/tensorflow\";\nimport SudokuSolver from \"./solver/sudokuSolver\";\nimport getLargestConnectedComponent, {\n  Point,\n} from \"./imageProcessing/getLargestConnectedComponent\";\nimport findHomographicTransform, {\n  Transform,\n  transformPoint,\n} from \"./imageProcessing/findHomographicTransform\";\nimport captureImage from \"./imageProcessing/captureImage\";\nimport adaptiveThreshold from \"./imageProcessing/adaptiveThreshold\";\nimport getCornerPoints from \"./imageProcessing/getCornerPoints\";\nimport extractSquareFromRegion from \"./imageProcessing/applyHomographicTransform\";\nimport extractBoxes from \"./imageProcessing/extractBoxes\";\n\nconst MIN_BOXES = 15;\nconst PROCESSING_SIZE = 900;\n\nexport type VideoReadyPayload = { width: number; height: number };\n\ninterface ProcessorEvents {\n  videoReady: VideoReadyPayload;\n}\n\ntype ProcessorEventEmitter = StrictEventEmitter<EventEmitter, ProcessorEvents>;\n\ntype SolvedBox = {\n  isKnown: boolean;\n  digit: number;\n  digitHeight: number;\n  digitRotation: number;\n  position: Point;\n};\n\nexport default class Processor extends (EventEmitter as {\n  new(): ProcessorEventEmitter;\n}) {\n  video: HTMLVideoElement;\n  isVideoRunning: boolean = false;\n  isProcessing: boolean = false;\n  corners: {\n    topLeft: Point;\n    topRight: Point;\n    bottomLeft: Point;\n    bottomRight: Point;\n  };\n  gridLines: { p1: Point; p2: Point }[];\n  solvedPuzzle: SolvedBox[][];\n  captureTime: number = 0;\n  thresholdTime: number = 0;\n  connectedComponentTime: number = 0;\n  cornerPointTime: number = 0;\n  extractPuzzleTime: number = 0;\n  extractBoxesTime: number = 0;\n  neuralNetTime: number = 0;\n  solveTime: number = 0;\n\n  async startVideo(video: HTMLVideoElement) {\n    this.video = video;\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: { facingMode: \"environment\", width: 640 },\n      audio: false,\n    });\n    const canPlayListener = () => {\n      this.video.removeEventListener(\"canplay\", canPlayListener);\n      this.emit(\"videoReady\", {\n        width: this.video.videoWidth,\n        height: this.video.videoHeight,\n      });\n      this.isVideoRunning = true;\n      this.processFrame();\n    };\n    this.video.addEventListener(\"canplay\", canPlayListener);\n    this.video.srcObject = stream;\n    this.video.play();\n  }\n\n  createGridLines(transform: Transform) {\n    const boxSize = PROCESSING_SIZE / 9;\n    const gridLines = [];\n    for (let l = 1; l < 9; l++) {\n\n      gridLines.push({\n        p1: transformPoint({ x: 0, y: l * boxSize }, transform),\n        p2: transformPoint({ x: PROCESSING_SIZE, y: l * boxSize }, transform),\n      });\n\n      gridLines.push({\n        p1: transformPoint({ y: 0, x: l * boxSize }, transform),\n        p2: transformPoint({ y: PROCESSING_SIZE, x: l * boxSize }, transform),\n      });\n    }\n    return gridLines;\n  }\n\n  getTextDetailsForBox(\n    x: number,\n    y: number,\n    digit: number,\n    isKnown: boolean,\n    transform: Transform\n  ): SolvedBox {\n    const boxSize = PROCESSING_SIZE / 9;\n    const p1 = transformPoint(\n      { x: (x + 0.5) * boxSize, y: y * boxSize },\n      transform\n    );\n    const p2 = transformPoint(\n      { x: (x + 0.5) * boxSize, y: (y + 1) * boxSize },\n      transform\n    );\n\n    const textPosition = transformPoint(\n      { x: (x + 0.5) * boxSize, y: (y + 0.5) * boxSize },\n      transform\n    );\n\n    const dx = p1.x - p2.x;\n    const dy = p1.y - p2.y;\n    const digitRotation = Math.atan2(dx, dy);\n\n    const digitHeight = 0.8 * Math.sqrt(dx * dx + dy * dy);\n\n    return {\n      digit,\n      digitHeight,\n      digitRotation,\n      isKnown: isKnown,\n      position: textPosition,\n    };\n  }\n\n  createSolvedPuzzle(solver: SudokuSolver, transform: Transform) {\n    const results: SolvedBox[][] = new Array(9);\n    for (let y = 0; y < 9; y++) {\n      results[y] = new Array(9);\n    }\n    solver.solution.forEach((sol) => {\n      const { x, y, entry, isKnown } = sol.guess;\n      results[y][x] = this.getTextDetailsForBox(\n        x,\n        y,\n        entry,\n        isKnown,\n        transform\n      );\n    });\n    return results;\n  }\n\n  sanityCheckCorners({\n    topLeft,\n    topRight,\n    bottomLeft,\n    bottomRight,\n  }: {\n    topLeft: Point;\n    topRight: Point;\n    bottomLeft: Point;\n    bottomRight: Point;\n  }) {\n    function length(p1: Point, p2: Point) {\n      const dx = p1.x - p2.x;\n      const dy = p1.y - p2.y;\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n    const topLineLength = length(topLeft, topRight);\n    const leftLineLength = length(topLeft, bottomLeft);\n    const rightLineLength = length(topRight, bottomRight);\n    const bottomLineLength = length(bottomLeft, bottomRight);\n    if (\n      topLineLength < 0.5 * bottomLineLength ||\n      topLineLength > 1.5 * bottomLineLength\n    )\n      return false;\n    if (\n      leftLineLength < 0.7 * rightLineLength ||\n      leftLineLength > 1.3 * rightLineLength\n    )\n      return false;\n    if (\n      leftLineLength < 0.5 * bottomLineLength ||\n      leftLineLength > 1.5 * bottomLineLength\n    )\n      return false;\n    return true;\n  }\n\n  async processFrame() {\n    if (!this.isVideoRunning) {\n      return;\n    }\n    if (this.isProcessing) {\n      return;\n    }\n    try {\n      let startTime = performance.now();\n      const image = captureImage(this.video);\n      this.captureTime =\n        0.1 * (performance.now() - startTime) + this.captureTime * 0.9;\n\n      startTime = performance.now();\n      const thresholded = adaptiveThreshold(image.clone(), 20, 20);\n      this.thresholdTime =\n        0.1 * (performance.now() - startTime) + this.thresholdTime * 0.9;\n\n      startTime = performance.now();\n      const largestConnectedComponent = getLargestConnectedComponent(\n        thresholded,\n        {\n          minAspectRatio: 0.5,\n          maxAspectRatio: 1.5,\n          minSize:\n            Math.min(this.video.videoWidth, this.video.videoHeight) * 0.3,\n          maxSize:\n            Math.min(this.video.videoWidth, this.video.videoHeight) * 0.9,\n        }\n      );\n      this.connectedComponentTime =\n        0.1 * (performance.now() - startTime) +\n        this.connectedComponentTime * 0.9;\n\n      // if we actually found something\n      if (largestConnectedComponent) {\n        // make a guess at where the corner points are using manhattan distance\n        startTime = performance.now();\n        const potentialCorners = getCornerPoints(largestConnectedComponent);\n        this.cornerPointTime =\n          0.1 * (performance.now() - startTime) + this.cornerPointTime * 0.9;\n\n        if (this.sanityCheckCorners(potentialCorners)) {\n          this.corners = potentialCorners;\n\n          // compute the transform to go from a square puzzle of size PROCESSING_SIZE to the detected corner points\n          startTime = performance.now();\n          const transform = findHomographicTransform(\n            PROCESSING_SIZE,\n            this.corners\n          );\n\n          // we've got the transform so we can show where the gridlines are\n          this.gridLines = this.createGridLines(transform);\n\n          // extract the square puzzle from the original grey image\n          const extractedImageGreyScale = extractSquareFromRegion(\n            image,\n            PROCESSING_SIZE,\n            transform\n          );\n          // extract the square puzzle from the thresholded image - we'll use the thresholded image for determining where the digits are in the cells\n          const extractedImageThresholded = extractSquareFromRegion(\n            thresholded,\n            PROCESSING_SIZE,\n            transform\n          );\n          this.extractPuzzleTime =\n            0.1 * (performance.now() - startTime) +\n            this.extractPuzzleTime * 0.9;\n\n          // extract the boxes that should contain the numbers\n          startTime = performance.now();\n          const boxes = extractBoxes(\n            extractedImageGreyScale,\n            extractedImageThresholded\n          );\n          this.extractBoxesTime =\n            0.1 * (performance.now() - startTime) + this.extractBoxesTime * 0.9;\n\n          // did we find sufficient boxes for a potentially valid sudoku puzzle?\n          if (boxes.length > MIN_BOXES) {\n            // apply the neural network to the found boxes and work out what the digits are\n            startTime = performance.now();\n            await fillInPrediction(boxes);\n            this.neuralNetTime =\n              0.1 * (performance.now() - startTime) + this.neuralNetTime * 0.9;\n\n            // solve the suoku puzzle using the dancing links and algorithm X - https://en.wikipedia.org/wiki/Knuth%27s_Algorithm_X\n            startTime = performance.now();\n            const solver = new SudokuSolver();\n            // set the known values\n            boxes.forEach((box) => {\n              if (box.contents !== 0) {\n                solver.setNumber(box.x, box.y, box.contents - 1);\n              }\n            });\n            // search for a solution\n            if (solver.search(0)) {\n              this.solvedPuzzle = this.createSolvedPuzzle(solver, transform);\n            } else {\n              this.solvedPuzzle = null;\n            }\n            this.solveTime =\n              0.1 * (performance.now() - startTime) + this.solveTime * 0.9;\n          }\n        } else {\n          this.corners = null;\n          this.gridLines = null;\n          this.solvedPuzzle = null;\n        }\n      } else {\n        this.corners = null;\n        this.gridLines = null;\n        this.solvedPuzzle = null;\n      }\n    } catch (error) {\n      console.error(error);\n    }\n    this.isProcessing = false;\n    // process again\n    setTimeout(() => this.processFrame(), 20);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}