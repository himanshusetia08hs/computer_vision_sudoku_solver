{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\nexport function assertParamsValid(input, begin, size) {\n  const inputRank = input.shape.length;\n  util.assert(inputRank === begin.length, () => `Error in slice${inputRank}D: Length of begin ${begin} must ` + `match the rank of the array (${inputRank}).`);\n  util.assert(inputRank === size.length, () => `Error in slice${inputRank}D: Length of size ${size} must ` + `match the rank of the array (${inputRank}).`);\n  for (let i = 0; i < inputRank; ++i) {\n    util.assert(begin[i] + size[i] <= input.shape[i], () => `Error in slice${inputRank}D: begin[${i}] + size[${i}] ` + `(${begin[i] + size[i]}) would overflow input.shape[${i}] (${input.shape[i]})`);\n  }\n}\n/** Converts a binary mask to an array of axes. Used in stridedSlice(). */\nexport function maskToAxes(mask) {\n  const axes = [];\n  let axis = 0;\n  while (mask > 0) {\n    if (mask & 1) {\n      axes.push(axis);\n    }\n    mask /= 2;\n    axis++;\n  }\n  return axes;\n}\n/** Computes the output shape given the strided slice params. */\nexport function computeOutShape(begin, end, strides) {\n  const size = [];\n  for (let axis = 0; axis < begin.length; axis++) {\n    size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);\n  }\n  return size;\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stride value. Otherwise, insert.\nexport function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {\n  const newStrides = [...strides];\n  for (let i = newStrides.length; i < inputShape.length; i++) {\n    newStrides.push(1);\n  }\n  for (let i = 0; i < numElidedAxes; i++) {\n    if (i === 0) {\n      newStrides[ellipsisInsertionIndex] = 1;\n    } else {\n      newStrides.splice(ellipsisInsertionIndex, 0 /* num elements to delete */, 1 /* element to add */);\n      newStrides.pop();\n    }\n  }\n  return newStrides;\n}\nfunction unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {\n  if (normalizedAxis <= ellipsisInsertionIndex) {\n    return normalizedAxis;\n  }\n  return normalizedAxis - (numElidedAxes - 1);\n}\nfunction getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {\n  const elidedAxes = [];\n  for (let i = 0; i < numElidedAxes; i++) {\n    elidedAxes.push(ellipsisInsertionIndex + i);\n  }\n  return elidedAxes;\n}\n// Normalize the start, end and strides.\nexport function getNormalizedAxes(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {\n  const inputRank = inputShape.length;\n  let normalizedBegin = new Array(inputRank),\n    normalizedEnd = new Array(inputRank),\n    normalizedStrides = new Array(inputRank);\n  if (ellipsisAxes.length && numInterpolatedAxes > 0) {\n    const fullIndex = ellipsisAxes[0];\n    // The ellipsis applies to the masked index as well as any dimensions\n    // that are interpolated.\n    const numElidedAxes = numInterpolatedAxes + 1;\n    normalizedBegin = startIndicesWithElidedDims(beginMask, fullIndex, numElidedAxes, begin, inputShape);\n    normalizedEnd = stopIndicesWithElidedDims(endMask, fullIndex, numElidedAxes, end, inputShape);\n    normalizedStrides = stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);\n  } else {\n    for (let axis = 0; axis < inputRank; axis++) {\n      normalizedBegin[axis] = startForAxis(beginMask, begin, strides, inputShape, axis, ellipsisMask);\n      normalizedEnd[axis] = stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);\n      normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);\n    }\n  }\n  return {\n    begin: normalizedBegin,\n    end: normalizedEnd,\n    strides: normalizedStrides\n  };\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current start value. Otherwise, insert.\nexport function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {\n  const newIndices = [...inputShape];\n  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n  for (let axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = 0;\n    } else {\n      const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      let originalValue = originalBegin[originalAxis];\n      if (beginMask & 1 << originalAxis) {\n        originalValue = 0;\n      }\n      newIndices[axis] = originalValue;\n    }\n  }\n  return newIndices;\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stop value. Otherwise, insert.\nexport function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {\n  const newIndices = [...inputShape];\n  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n  for (let axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = Number.MAX_SAFE_INTEGER;\n    } else {\n      const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      let originalValue = originalEnd[originalAxis];\n      if (endMask & 1 << originalAxis) {\n        originalValue = Number.MAX_SAFE_INTEGER;\n      }\n      newIndices[axis] = originalValue;\n    }\n  }\n  for (let i = 0; i < newIndices.length; i++) {\n    // Handle negative indices\n    const axisSize = inputShape[i];\n    if (newIndices[i] < 0) {\n      newIndices[i] += axisSize;\n    }\n    newIndices[i] = util.clamp(0, newIndices[i], inputShape[i]);\n  }\n  return newIndices;\n}\nexport function stridesForAxis(strides, axis, ellipsisMask) {\n  let stride = strides[axis];\n  if (ellipsisMask & 1 << axis || stride == null) {\n    stride = 1;\n  }\n  return stride;\n}\nexport function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {\n  // Begin with the specified index\n  let start = startIndices[axis];\n  const stride = strides[axis] || 1;\n  // Check the axis bit from right of masked axes, or the begin index is not set\n  // for the axis.\n  if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {\n    if (stride > 0) {\n      // Forward iteration - use the first element. These values will get\n      // clamped below (Note: We could have set them to 0 and axis_size-1, but\n      // use lowest() and max() to maintain symmetry with StopForAxis())\n      start = Number.MIN_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the last element.\n      start = Number.MAX_SAFE_INTEGER;\n    }\n  }\n  // Handle negative indices\n  const axisSize = inputShape[axis];\n  if (start < 0) {\n    start += axisSize;\n  }\n  // Clamping\n  start = util.clamp(0, start, axisSize - 1);\n  return start;\n}\nexport function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {\n  // Begin with the specified index\n  let stop = stopIndices[axis];\n  const stride = strides[axis] || 1;\n  // Check the axis bit from right of masked axes, or if the stop index is not\n  // set for this axis.\n  if (endMask & 1 << axis || ellipsisMask & 1 << axis || stop == null) {\n    if (stride > 0) {\n      // Forward iteration - use the last element. These values will get\n      // clamped below\n      stop = Number.MAX_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the first element.\n      stop = Number.MIN_SAFE_INTEGER;\n    }\n  }\n  // Handle negative indices\n  const axisSize = inputShape[axis];\n  if (stop < 0) {\n    stop += axisSize;\n  }\n  // Clamping\n  // Because the end index points one past the last element, we need slightly\n  // different clamping ranges depending on the direction.\n  if (stride > 0) {\n    // Forward iteration\n    stop = util.clamp(0, stop, axisSize);\n  } else {\n    // Backward iteration\n    stop = util.clamp(-1, stop, axisSize - 1);\n  }\n  return stop;\n}\n/**\n * Returns true if the slice occupies a continous set of elements in the\n * 'flat' space.\n */\nexport function isSliceContinous(shape, begin, size) {\n  // Index of the first axis that has size > 1.\n  let firstNonOneAxis = size.length;\n  for (let i = 0; i < size.length; i++) {\n    if (size[i] > 1) {\n      firstNonOneAxis = i;\n      break;\n    }\n  }\n  for (let i = firstNonOneAxis + 1; i < size.length; i++) {\n    if (begin[i] > 0 || size[i] !== shape[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function computeFlatOffset(begin, strides) {\n  let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;\n  for (let i = 0; i < begin.length - 1; i++) {\n    flatOffset += begin[i] * strides[i];\n  }\n  return flatOffset;\n}\nexport function parseSliceParams(x, begin, size) {\n  // The following logic allows for more ergonomic calls.\n  let begin_;\n  const xRank = x.shape.length;\n  if (typeof begin === 'number') {\n    begin_ = [begin, ...new Array(xRank - 1).fill(0)];\n  } else if (begin.length < xRank) {\n    begin_ = begin.concat(new Array(xRank - begin.length).fill(0));\n  } else {\n    begin_ = begin.slice();\n  }\n  begin_.forEach(d => {\n    util.assert(d !== -1, () => 'slice() does not support negative begin indexing.');\n  });\n  let size_;\n  if (size == null) {\n    size_ = new Array(xRank).fill(-1);\n  } else if (typeof size === 'number') {\n    size_ = [size, ...new Array(xRank - 1).fill(-1)];\n  } else if (size.length < xRank) {\n    size_ = size.concat(new Array(xRank - size.length).fill(-1));\n  } else {\n    size_ = size;\n  }\n  size_ = size_.map((d, i) => {\n    if (d >= 0) {\n      return d;\n    } else {\n      util.assert(d === -1, () => `Negative size values should be exactly -1 but got ` + `${d} for the slice() size at index ${i}.`);\n      return x.shape[i] - begin_[i];\n    }\n  });\n  return [begin_, size_];\n}\nexport function sliceInfo(xShape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {\n  // make a copy because it may be modified further down.\n  let $begin = begin.slice();\n  let $end = end.slice();\n  let $strides = strides;\n  if (strides == null) {\n    $strides = new Array($begin.length);\n  }\n  const ellipsisAxes = maskToAxes(ellipsisMask);\n  if (ellipsisAxes.length > 1) {\n    throw new Error('Multiple ellipses in slice is not allowed.');\n  }\n  if (ellipsisMask !== 0 && newAxisMask !== 0) {\n    throw new Error('Using both ellipsisMask and newAxisMask is not yet supported.');\n  }\n  if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {\n    throw new Error('Using both ellipsisMask and shrinkAxisMask is not yet supported.');\n  }\n  const numInterpolatedAxes = xShape.length - $begin.length;\n  // Expand the dims of x based on the newAxisMask.\n  const expandAxes = maskToAxes(newAxisMask);\n  const newShape = xShape.slice();\n  expandAxes.forEach(axis => {\n    $begin[axis] = 0;\n    $end[axis] = 1;\n    newShape.splice(axis, 0, 1);\n  });\n  const {\n    begin: normalizedBegin,\n    end: normalizedEnd,\n    strides: normalizedStrides\n  } = getNormalizedAxes(newShape, ellipsisAxes, numInterpolatedAxes, $begin, $end, $strides, beginMask, endMask, ellipsisMask);\n  $begin = normalizedBegin;\n  $end = normalizedEnd;\n  $strides = normalizedStrides;\n  const shrinkAxes = maskToAxes(shrinkAxisMask);\n  // Adjust the ends based on the shrink mask.\n  shrinkAxes.forEach(axis => {\n    $end[axis] = $begin[axis] + 1;\n    $strides[axis] = 1;\n  });\n  // Figure out the output shape.\n  const size = computeOutShape($begin, $end, $strides);\n  // Remove the axes based on shrinkMask.\n  const outShape = size.filter((_, axis) => shrinkAxes.indexOf(axis) === -1);\n  const nonStrided = $strides.every(v => v === 1);\n  return {\n    nonStrided,\n    $begin,\n    $end,\n    $strides,\n    size,\n    newShape,\n    outShape\n  };\n}","map":{"version":3,"sources":["../../src/ops/slice_util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\nexport function assertParamsValid(input, begin, size) {\n    const inputRank = input.shape.length;\n    util.assert(inputRank === begin.length, () => `Error in slice${inputRank}D: Length of begin ${begin} must ` +\n        `match the rank of the array (${inputRank}).`);\n    util.assert(inputRank === size.length, () => `Error in slice${inputRank}D: Length of size ${size} must ` +\n        `match the rank of the array (${inputRank}).`);\n    for (let i = 0; i < inputRank; ++i) {\n        util.assert(begin[i] + size[i] <= input.shape[i], () => `Error in slice${inputRank}D: begin[${i}] + size[${i}] ` +\n            `(${begin[i] + size[i]}) would overflow input.shape[${i}] (${input.shape[i]})`);\n    }\n}\n/** Converts a binary mask to an array of axes. Used in stridedSlice(). */\nexport function maskToAxes(mask) {\n    const axes = [];\n    let axis = 0;\n    while (mask > 0) {\n        if (mask & 1) {\n            axes.push(axis);\n        }\n        mask /= 2;\n        axis++;\n    }\n    return axes;\n}\n/** Computes the output shape given the strided slice params. */\nexport function computeOutShape(begin, end, strides) {\n    const size = [];\n    for (let axis = 0; axis < begin.length; axis++) {\n        size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);\n    }\n    return size;\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stride value. Otherwise, insert.\nexport function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {\n    const newStrides = [...strides];\n    for (let i = newStrides.length; i < inputShape.length; i++) {\n        newStrides.push(1);\n    }\n    for (let i = 0; i < numElidedAxes; i++) {\n        if (i === 0) {\n            newStrides[ellipsisInsertionIndex] = 1;\n        }\n        else {\n            newStrides.splice(ellipsisInsertionIndex, 0 /* num elements to delete */, 1 /* element to add */);\n            newStrides.pop();\n        }\n    }\n    return newStrides;\n}\nfunction unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {\n    if (normalizedAxis <= ellipsisInsertionIndex) {\n        return normalizedAxis;\n    }\n    return normalizedAxis - (numElidedAxes - 1);\n}\nfunction getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {\n    const elidedAxes = [];\n    for (let i = 0; i < numElidedAxes; i++) {\n        elidedAxes.push(ellipsisInsertionIndex + i);\n    }\n    return elidedAxes;\n}\n// Normalize the start, end and strides.\nexport function getNormalizedAxes(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {\n    const inputRank = inputShape.length;\n    let normalizedBegin = new Array(inputRank), normalizedEnd = new Array(inputRank), normalizedStrides = new Array(inputRank);\n    if (ellipsisAxes.length && numInterpolatedAxes > 0) {\n        const fullIndex = ellipsisAxes[0];\n        // The ellipsis applies to the masked index as well as any dimensions\n        // that are interpolated.\n        const numElidedAxes = numInterpolatedAxes + 1;\n        normalizedBegin = startIndicesWithElidedDims(beginMask, fullIndex, numElidedAxes, begin, inputShape);\n        normalizedEnd = stopIndicesWithElidedDims(endMask, fullIndex, numElidedAxes, end, inputShape);\n        normalizedStrides =\n            stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);\n    }\n    else {\n        for (let axis = 0; axis < inputRank; axis++) {\n            normalizedBegin[axis] = startForAxis(beginMask, begin, strides, inputShape, axis, ellipsisMask);\n            normalizedEnd[axis] =\n                stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);\n            normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);\n        }\n    }\n    return {\n        begin: normalizedBegin,\n        end: normalizedEnd,\n        strides: normalizedStrides\n    };\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current start value. Otherwise, insert.\nexport function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {\n    const newIndices = [...inputShape];\n    const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n    for (let axis = 0; axis < newIndices.length; axis++) {\n        if (elidedAxes.indexOf(axis) > -1) {\n            newIndices[axis] = 0;\n        }\n        else {\n            const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n            let originalValue = originalBegin[originalAxis];\n            if (beginMask & 1 << originalAxis) {\n                originalValue = 0;\n            }\n            newIndices[axis] = originalValue;\n        }\n    }\n    return newIndices;\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stop value. Otherwise, insert.\nexport function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {\n    const newIndices = [...inputShape];\n    const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n    for (let axis = 0; axis < newIndices.length; axis++) {\n        if (elidedAxes.indexOf(axis) > -1) {\n            newIndices[axis] = Number.MAX_SAFE_INTEGER;\n        }\n        else {\n            const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n            let originalValue = originalEnd[originalAxis];\n            if (endMask & 1 << originalAxis) {\n                originalValue = Number.MAX_SAFE_INTEGER;\n            }\n            newIndices[axis] = originalValue;\n        }\n    }\n    for (let i = 0; i < newIndices.length; i++) {\n        // Handle negative indices\n        const axisSize = inputShape[i];\n        if (newIndices[i] < 0) {\n            newIndices[i] += axisSize;\n        }\n        newIndices[i] = util.clamp(0, newIndices[i], inputShape[i]);\n    }\n    return newIndices;\n}\nexport function stridesForAxis(strides, axis, ellipsisMask) {\n    let stride = strides[axis];\n    if (ellipsisMask & (1 << axis) || stride == null) {\n        stride = 1;\n    }\n    return stride;\n}\nexport function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {\n    // Begin with the specified index\n    let start = startIndices[axis];\n    const stride = strides[axis] || 1;\n    // Check the axis bit from right of masked axes, or the begin index is not set\n    // for the axis.\n    if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {\n        if (stride > 0) {\n            // Forward iteration - use the first element. These values will get\n            // clamped below (Note: We could have set them to 0 and axis_size-1, but\n            // use lowest() and max() to maintain symmetry with StopForAxis())\n            start = Number.MIN_SAFE_INTEGER;\n        }\n        else {\n            // Backward iteration - use the last element.\n            start = Number.MAX_SAFE_INTEGER;\n        }\n    }\n    // Handle negative indices\n    const axisSize = inputShape[axis];\n    if (start < 0) {\n        start += axisSize;\n    }\n    // Clamping\n    start = util.clamp(0, start, axisSize - 1);\n    return start;\n}\nexport function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {\n    // Begin with the specified index\n    let stop = stopIndices[axis];\n    const stride = strides[axis] || 1;\n    // Check the axis bit from right of masked axes, or if the stop index is not\n    // set for this axis.\n    if (endMask & (1 << axis) || ellipsisMask & (1 << axis) || stop == null) {\n        if (stride > 0) {\n            // Forward iteration - use the last element. These values will get\n            // clamped below\n            stop = Number.MAX_SAFE_INTEGER;\n        }\n        else {\n            // Backward iteration - use the first element.\n            stop = Number.MIN_SAFE_INTEGER;\n        }\n    }\n    // Handle negative indices\n    const axisSize = inputShape[axis];\n    if (stop < 0) {\n        stop += axisSize;\n    }\n    // Clamping\n    // Because the end index points one past the last element, we need slightly\n    // different clamping ranges depending on the direction.\n    if (stride > 0) {\n        // Forward iteration\n        stop = util.clamp(0, stop, axisSize);\n    }\n    else {\n        // Backward iteration\n        stop = util.clamp(-1, stop, axisSize - 1);\n    }\n    return stop;\n}\n/**\n * Returns true if the slice occupies a continous set of elements in the\n * 'flat' space.\n */\nexport function isSliceContinous(shape, begin, size) {\n    // Index of the first axis that has size > 1.\n    let firstNonOneAxis = size.length;\n    for (let i = 0; i < size.length; i++) {\n        if (size[i] > 1) {\n            firstNonOneAxis = i;\n            break;\n        }\n    }\n    for (let i = firstNonOneAxis + 1; i < size.length; i++) {\n        if (begin[i] > 0 || size[i] !== shape[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function computeFlatOffset(begin, strides) {\n    let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;\n    for (let i = 0; i < begin.length - 1; i++) {\n        flatOffset += begin[i] * strides[i];\n    }\n    return flatOffset;\n}\nexport function parseSliceParams(x, begin, size) {\n    // The following logic allows for more ergonomic calls.\n    let begin_;\n    const xRank = x.shape.length;\n    if (typeof begin === 'number') {\n        begin_ = [begin, ...new Array(xRank - 1).fill(0)];\n    }\n    else if (begin.length < xRank) {\n        begin_ = begin.concat(new Array(xRank - begin.length).fill(0));\n    }\n    else {\n        begin_ = begin.slice();\n    }\n    begin_.forEach(d => {\n        util.assert(d !== -1, () => 'slice() does not support negative begin indexing.');\n    });\n    let size_;\n    if (size == null) {\n        size_ = new Array(xRank).fill(-1);\n    }\n    else if (typeof size === 'number') {\n        size_ = [size, ...new Array(xRank - 1).fill(-1)];\n    }\n    else if (size.length < xRank) {\n        size_ = size.concat(new Array(xRank - size.length).fill(-1));\n    }\n    else {\n        size_ = size;\n    }\n    size_ = size_.map((d, i) => {\n        if (d >= 0) {\n            return d;\n        }\n        else {\n            util.assert(d === -1, () => `Negative size values should be exactly -1 but got ` +\n                `${d} for the slice() size at index ${i}.`);\n            return x.shape[i] - begin_[i];\n        }\n    });\n    return [begin_, size_];\n}\nexport function sliceInfo(xShape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {\n    // make a copy because it may be modified further down.\n    let $begin = begin.slice();\n    let $end = end.slice();\n    let $strides = strides;\n    if (strides == null) {\n        $strides = new Array($begin.length);\n    }\n    const ellipsisAxes = maskToAxes(ellipsisMask);\n    if (ellipsisAxes.length > 1) {\n        throw new Error('Multiple ellipses in slice is not allowed.');\n    }\n    if (ellipsisMask !== 0 && newAxisMask !== 0) {\n        throw new Error('Using both ellipsisMask and newAxisMask is not yet supported.');\n    }\n    if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {\n        throw new Error('Using both ellipsisMask and shrinkAxisMask is not yet supported.');\n    }\n    const numInterpolatedAxes = xShape.length - $begin.length;\n    // Expand the dims of x based on the newAxisMask.\n    const expandAxes = maskToAxes(newAxisMask);\n    const newShape = xShape.slice();\n    expandAxes.forEach(axis => {\n        $begin[axis] = 0;\n        $end[axis] = 1;\n        newShape.splice(axis, 0, 1);\n    });\n    const { begin: normalizedBegin, end: normalizedEnd, strides: normalizedStrides } = getNormalizedAxes(newShape, ellipsisAxes, numInterpolatedAxes, $begin, $end, $strides, beginMask, endMask, ellipsisMask);\n    $begin = normalizedBegin;\n    $end = normalizedEnd;\n    $strides = normalizedStrides;\n    const shrinkAxes = maskToAxes(shrinkAxisMask);\n    // Adjust the ends based on the shrink mask.\n    shrinkAxes.forEach(axis => {\n        $end[axis] = $begin[axis] + 1;\n        $strides[axis] = 1;\n    });\n    // Figure out the output shape.\n    const size = computeOutShape($begin, $end, $strides);\n    // Remove the axes based on shrinkMask.\n    const outShape = size.filter((_, axis) => shrinkAxes.indexOf(axis) === -1);\n    const nonStrided = $strides.every(v => v === 1);\n    return { nonStrided, $begin, $end, $strides, size, newShape, outShape };\n}\n//# sourceMappingURL=slice_util.js.map"]},"metadata":{},"sourceType":"module"}