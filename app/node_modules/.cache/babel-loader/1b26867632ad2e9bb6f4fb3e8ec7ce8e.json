{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { tidy, util } from '@tensorflow/tfjs-core';\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { getParamValue } from './utils';\nexport const executeOp = (node, tensorMap, context) => {\n  switch (node.op) {\n    case 'ConcatV2':\n    case 'Concat':\n      {\n        const n = getParamValue('n', node, tensorMap, context);\n        const axis = getParamValue('axis', node, tensorMap, context);\n        let inputs = getParamValue('tensors', node, tensorMap, context);\n        inputs = inputs.slice(0, n);\n        return [tfOps.concat(inputs, axis)];\n      }\n    case 'Gather':\n      {\n        const input = getParamValue('x', node, tensorMap, context);\n        const indices = getParamValue('indices', node, tensorMap, context);\n        return [tfOps.gather(input, tfOps.cast(indices, 'int32'), 0)];\n      }\n    case 'GatherV2':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const batchDims = getParamValue('batchDims', node, tensorMap, context);\n        const input = getParamValue('x', node, tensorMap, context);\n        const indices = getParamValue('indices', node, tensorMap, context);\n        return [tfOps.gather(input, tfOps.cast(indices, 'int32'), axis, batchDims)];\n      }\n    case 'Reverse':\n      {\n        const dims = getParamValue('dims', node, tensorMap, context);\n        const axis = [];\n        for (let i = 0; i < dims.length; i++) {\n          if (dims[i]) {\n            axis.push(i);\n          }\n        }\n        const input = getParamValue('x', node, tensorMap, context);\n        return [tfOps.reverse(input, axis)];\n      }\n    case 'ReverseV2':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const input = getParamValue('x', node, tensorMap, context);\n        return [tfOps.reverse(input, axis)];\n      }\n    case 'Slice':\n      {\n        // tslint:disable-next-line:no-any\n        const begin = getParamValue('begin', node, tensorMap, context);\n        // tslint:disable-next-line:no-any\n        const size = getParamValue('size', node, tensorMap, context);\n        return [tfOps.slice(getParamValue('x', node, tensorMap, context), begin, size)];\n      }\n    case 'StridedSlice':\n      {\n        const begin = getParamValue('begin', node, tensorMap, context);\n        const end = getParamValue('end', node, tensorMap, context);\n        const strides = getParamValue('strides', node, tensorMap, context);\n        const beginMask = getParamValue('beginMask', node, tensorMap, context);\n        const endMask = getParamValue('endMask', node, tensorMap, context);\n        const ellipsisMask = getParamValue('ellipsisMask', node, tensorMap, context);\n        const newAxisMask = getParamValue('newAxisMask', node, tensorMap, context);\n        const shrinkAxisMask = getParamValue('shrinkAxisMask', node, tensorMap, context);\n        const tensor = getParamValue('x', node, tensorMap, context);\n        return [tfOps.stridedSlice(tensor, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask)];\n      }\n    case 'Pack':\n      {\n        return tidy(() => {\n          const axis = getParamValue('axis', node, tensorMap, context);\n          const tensors = getParamValue('tensors', node, tensorMap, context);\n          // Reshape the tensors to the first tensor's shape if they don't\n          // match.\n          const shape = tensors[0].shape;\n          const squeezedShape = tfOps.squeeze(tensors[0]).shape;\n          const mapped = tensors.map(tensor => {\n            const sameShape = util.arraysEqual(tensor.shape, shape);\n            if (!sameShape && !util.arraysEqual(tfOps.squeeze(tensor).shape, squeezedShape)) {\n              throw new Error('the input tensors shape does not match');\n            }\n            return sameShape ? tensor : tfOps.reshape(tensor, shape);\n          });\n          return [tfOps.stack(mapped, axis)];\n        });\n      }\n    case 'Unpack':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const tensor = getParamValue('tensor', node, tensorMap, context);\n        return tfOps.unstack(tensor, axis);\n      }\n    case 'Tile':\n      {\n        const reps = getParamValue('reps', node, tensorMap, context);\n        return [tfOps.tile(getParamValue('x', node, tensorMap, context), reps)];\n      }\n    case 'Split':\n    case 'SplitV':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const numOrSizeSplits = getParamValue('numOrSizeSplits', node, tensorMap, context);\n        const tensor = getParamValue('x', node, tensorMap, context);\n        return tfOps.split(tensor, numOrSizeSplits, axis);\n      }\n    case 'ScatterNd':\n      {\n        const indices = getParamValue('indices', node, tensorMap, context);\n        const values = getParamValue('values', node, tensorMap, context);\n        const shape = getParamValue('shape', node, tensorMap, context);\n        return [tfOps.scatterND(indices, values, shape)];\n      }\n    case 'GatherNd':\n      {\n        const x = getParamValue('x', node, tensorMap, context);\n        const indices = getParamValue('indices', node, tensorMap, context);\n        return [tfOps.gatherND(x, indices)];\n      }\n    case 'SparseToDense':\n      {\n        const indices = getParamValue('sparseIndices', node, tensorMap, context);\n        const shape = getParamValue('outputShape', node, tensorMap, context);\n        const sparseValues = getParamValue('sparseValues', node, tensorMap, context);\n        const defaultValue = getParamValue('defaultValue', node, tensorMap, context);\n        return [tfOps.sparseToDense(indices, sparseValues, shape, sparseValues.dtype === defaultValue.dtype ? defaultValue : tfOps.cast(defaultValue, sparseValues.dtype))];\n      }\n    default:\n      throw TypeError(`Node type ${node.op} is not implemented`);\n  }\n};\nexport const CATEGORY = 'slice_join';","map":{"version":3,"sources":["../../../src/operations/executors/slice_join_executor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { tidy, util } from '@tensorflow/tfjs-core';\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { getParamValue } from './utils';\nexport const executeOp = (node, tensorMap, context) => {\n    switch (node.op) {\n        case 'ConcatV2':\n        case 'Concat': {\n            const n = getParamValue('n', node, tensorMap, context);\n            const axis = getParamValue('axis', node, tensorMap, context);\n            let inputs = getParamValue('tensors', node, tensorMap, context);\n            inputs = inputs.slice(0, n);\n            return [tfOps.concat(inputs, axis)];\n        }\n        case 'Gather': {\n            const input = getParamValue('x', node, tensorMap, context);\n            const indices = getParamValue('indices', node, tensorMap, context);\n            return [tfOps.gather(input, tfOps.cast(indices, 'int32'), 0)];\n        }\n        case 'GatherV2': {\n            const axis = getParamValue('axis', node, tensorMap, context);\n            const batchDims = getParamValue('batchDims', node, tensorMap, context);\n            const input = getParamValue('x', node, tensorMap, context);\n            const indices = getParamValue('indices', node, tensorMap, context);\n            return [tfOps.gather(input, tfOps.cast(indices, 'int32'), axis, batchDims)];\n        }\n        case 'Reverse': {\n            const dims = getParamValue('dims', node, tensorMap, context);\n            const axis = [];\n            for (let i = 0; i < dims.length; i++) {\n                if (dims[i]) {\n                    axis.push(i);\n                }\n            }\n            const input = getParamValue('x', node, tensorMap, context);\n            return [tfOps.reverse(input, axis)];\n        }\n        case 'ReverseV2': {\n            const axis = getParamValue('axis', node, tensorMap, context);\n            const input = getParamValue('x', node, tensorMap, context);\n            return [tfOps.reverse(input, axis)];\n        }\n        case 'Slice': {\n            // tslint:disable-next-line:no-any\n            const begin = getParamValue('begin', node, tensorMap, context);\n            // tslint:disable-next-line:no-any\n            const size = getParamValue('size', node, tensorMap, context);\n            return [tfOps.slice(getParamValue('x', node, tensorMap, context), begin, size)];\n        }\n        case 'StridedSlice': {\n            const begin = getParamValue('begin', node, tensorMap, context);\n            const end = getParamValue('end', node, tensorMap, context);\n            const strides = getParamValue('strides', node, tensorMap, context);\n            const beginMask = getParamValue('beginMask', node, tensorMap, context);\n            const endMask = getParamValue('endMask', node, tensorMap, context);\n            const ellipsisMask = getParamValue('ellipsisMask', node, tensorMap, context);\n            const newAxisMask = getParamValue('newAxisMask', node, tensorMap, context);\n            const shrinkAxisMask = getParamValue('shrinkAxisMask', node, tensorMap, context);\n            const tensor = getParamValue('x', node, tensorMap, context);\n            return [tfOps.stridedSlice(tensor, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask)];\n        }\n        case 'Pack': {\n            return tidy(() => {\n                const axis = getParamValue('axis', node, tensorMap, context);\n                const tensors = getParamValue('tensors', node, tensorMap, context);\n                // Reshape the tensors to the first tensor's shape if they don't\n                // match.\n                const shape = tensors[0].shape;\n                const squeezedShape = tfOps.squeeze(tensors[0]).shape;\n                const mapped = tensors.map(tensor => {\n                    const sameShape = util.arraysEqual(tensor.shape, shape);\n                    if (!sameShape &&\n                        !util.arraysEqual(tfOps.squeeze(tensor).shape, squeezedShape)) {\n                        throw new Error('the input tensors shape does not match');\n                    }\n                    return sameShape ? tensor : tfOps.reshape(tensor, shape);\n                });\n                return [tfOps.stack(mapped, axis)];\n            });\n        }\n        case 'Unpack': {\n            const axis = getParamValue('axis', node, tensorMap, context);\n            const tensor = getParamValue('tensor', node, tensorMap, context);\n            return tfOps.unstack(tensor, axis);\n        }\n        case 'Tile': {\n            const reps = getParamValue('reps', node, tensorMap, context);\n            return [tfOps.tile(getParamValue('x', node, tensorMap, context), reps)];\n        }\n        case 'Split':\n        case 'SplitV': {\n            const axis = getParamValue('axis', node, tensorMap, context);\n            const numOrSizeSplits = getParamValue('numOrSizeSplits', node, tensorMap, context);\n            const tensor = getParamValue('x', node, tensorMap, context);\n            return tfOps.split(tensor, numOrSizeSplits, axis);\n        }\n        case 'ScatterNd': {\n            const indices = getParamValue('indices', node, tensorMap, context);\n            const values = getParamValue('values', node, tensorMap, context);\n            const shape = getParamValue('shape', node, tensorMap, context);\n            return [tfOps.scatterND(indices, values, shape)];\n        }\n        case 'GatherNd': {\n            const x = getParamValue('x', node, tensorMap, context);\n            const indices = getParamValue('indices', node, tensorMap, context);\n            return [tfOps.gatherND(x, indices)];\n        }\n        case 'SparseToDense': {\n            const indices = getParamValue('sparseIndices', node, tensorMap, context);\n            const shape = getParamValue('outputShape', node, tensorMap, context);\n            const sparseValues = getParamValue('sparseValues', node, tensorMap, context);\n            const defaultValue = getParamValue('defaultValue', node, tensorMap, context);\n            return [tfOps.sparseToDense(indices, sparseValues, shape, sparseValues.dtype === defaultValue.dtype ?\n                    defaultValue :\n                    tfOps.cast(defaultValue, sparseValues.dtype))];\n        }\n        default:\n            throw TypeError(`Node type ${node.op} is not implemented`);\n    }\n};\nexport const CATEGORY = 'slice_join';\n//# sourceMappingURL=slice_join_executor.js.map"]},"metadata":{},"sourceType":"module"}