{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Mean, util } from '@tensorflow/tfjs-core';\nimport { cast } from './Cast';\nimport { permuteAxesAndTranspose } from './kernel_utils';\nlet wasmMean;\nfunction setup(backend) {\n  wasmMean = backend.wasm.cwrap(Mean, null /*void*/, ['number, number, number']);\n}\nexport function mean(args) {\n  const {\n    backend,\n    inputs,\n    attrs\n  } = args;\n  const {\n    axis,\n    keepDims\n  } = attrs;\n  const {\n    x\n  } = inputs;\n  const xId = backend.dataIdMap.get(x.dataId).id;\n  let inputId = xId;\n  let input = x;\n  const {\n    transposed,\n    axes,\n    originalAxes,\n    inputWasTransposed\n  } = permuteAxesAndTranspose(x, axis, backend);\n  let reductionAxes = axes;\n  if (inputWasTransposed) {\n    const transposedId = backend.dataIdMap.get(transposed.dataId).id;\n    if (transposedId !== xId) {\n      // transpose was not a no-op. We will need to dispose of this\n      // once we are done.\n      input = transposed;\n      inputId = transposedId;\n      reductionAxes = backend_util.getInnerMostAxes(reductionAxes.length, input.shape.length);\n    }\n  }\n  backend_util.assertAxesAreInnerMostDims('mean', reductionAxes, input.shape.length);\n  const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(input.shape, reductionAxes);\n  const reduceSize = util.sizeFromShape(reduceShape);\n  let castedInput = input;\n  if (input.dtype !== 'float32') {\n    castedInput = cast({\n      backend,\n      inputs: {\n        x: input\n      },\n      attrs: {\n        dtype: 'float32'\n      }\n    });\n    inputId = backend.dataIdMap.get(castedInput.dataId).id;\n  }\n  const out = backend.makeOutput(outShape, 'float32');\n  if (util.sizeFromShape(input.shape) !== 0) {\n    const outId = backend.dataIdMap.get(out.dataId).id;\n    wasmMean(inputId, reduceSize, outId);\n  }\n  if (inputWasTransposed) {\n    // dispose of the transposed tensor.\n    backend.disposeData(transposed.dataId);\n  }\n  if (keepDims) {\n    // reshape\n    const newShape = backend_util.expandShapeToKeepDim(out.shape, originalAxes);\n    out.shape = newShape;\n  }\n  if (input.dtype !== 'float32') {\n    backend.disposeData(castedInput.dataId);\n  }\n  return out;\n}\nexport const meanConfig = {\n  kernelName: Mean,\n  backendName: 'wasm',\n  setupFunc: setup,\n  kernelFunc: mean\n};","map":{"version":3,"sources":["../../../../../../tfjs-backend-wasm/src/kernels/Mean.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,YAAY,EAA4B,IAAI,EAAqC,IAAI,QAAO,uBAAuB;AAG3H,SAAQ,IAAI,QAAO,QAAQ;AAE3B,SAAQ,uBAAuB,QAAO,gBAAgB;AAEtD,IAAI,QAAkE;AAEtE,SAAS,KAAK,CAAC,OAAoB,EAAA;EACjC,QAAQ,GACJ,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,wBAAwB,CAAC,CAAC;AACzE;AAEA,OAAM,SAAU,IAAI,CAChB,IAAkE,EAAA;EAEpE,MAAM;IAAC,OAAO;IAAE,MAAM;IAAE;EAAK,CAAC,GAAG,IAAI;EACrC,MAAM;IAAC,IAAI;IAAE;EAAQ,CAAC,GAAG,KAAK;EAC9B,MAAM;IAAC;EAAC,CAAC,GAAG,MAAM;EAClB,MAAM,GAAG,GAAG,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE;EAC9C,IAAI,OAAO,GAAG,GAAG;EACjB,IAAI,KAAK,GAAG,CAAC;EAEb,MAAM;IAAC,UAAU;IAAE,IAAI;IAAE,YAAY;IAAE;EAAkB,CAAC,GACtD,uBAAuB,CAAC,CAAC,EAAE,IAAI,EAAE,OAAO,CAAC;EAE7C,IAAI,aAAa,GAAG,IAAI;EACxB,IAAI,kBAAkB,EAAE;IACtB,MAAM,YAAY,GAAG,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,EAAE;IAChE,IAAI,YAAY,KAAK,GAAG,EAAE;MACxB;MACA;MACA,KAAK,GAAG,UAAU;MAClB,OAAO,GAAG,YAAY;MACtB,aAAa,GAAG,YAAY,CAAC,gBAAgB,CACzC,aAAa,CAAC,MAAM,EAAE,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC;IAC9C;EACF;EAED,YAAY,CAAC,0BAA0B,CACnC,MAAM,EAAE,aAAa,EAAE,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC;EAC9C,MAAM,CAAC,QAAQ,EAAE,WAAW,CAAC,GACzB,YAAY,CAAC,yBAAyB,CAAC,KAAK,CAAC,KAAK,EAAE,aAAa,CAAC;EACtE,MAAM,UAAU,GAAG,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC;EAClD,IAAI,WAAW,GAAG,KAAK;EACvB,IAAI,KAAK,CAAC,KAAK,KAAK,SAAS,EAAE;IAC7B,WAAW,GACP,IAAI,CAAC;MAAC,OAAO;MAAE,MAAM,EAAE;QAAC,CAAC,EAAE;MAAK,CAAC;MAAE,KAAK,EAAE;QAAC,KAAK,EAAE;MAAS;IAAC,CAAC,CAAC;IAClE,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,EAAE;EACvD;EAED,MAAM,GAAG,GAAG,OAAO,CAAC,UAAU,CAAC,QAAQ,EAAE,SAAS,CAAC;EACnD,IAAI,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;IACzC,MAAM,KAAK,GAAG,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,EAAE;IAClD,QAAQ,CAAC,OAAO,EAAE,UAAU,EAAE,KAAK,CAAC;EACrC;EAED,IAAI,kBAAkB,EAAE;IACtB;IACA,OAAO,CAAC,WAAW,CAAC,UAAU,CAAC,MAAM,CAAC;EACvC;EAED,IAAI,QAAQ,EAAE;IACZ;IACA,MAAM,QAAQ,GAAG,YAAY,CAAC,oBAAoB,CAAC,GAAG,CAAC,KAAK,EAAE,YAAY,CAAC;IAC3E,GAAG,CAAC,KAAK,GAAG,QAAQ;EACrB;EAED,IAAI,KAAK,CAAC,KAAK,KAAK,SAAS,EAAE;IAC7B,OAAO,CAAC,WAAW,CAAC,WAAW,CAAC,MAAM,CAAC;EACxC;EAED,OAAO,GAAG;AACZ;AAEA,OAAO,MAAM,UAAU,GAAiB;EACtC,UAAU,EAAE,IAAI;EAChB,WAAW,EAAE,MAAM;EACnB,SAAS,EAAE,KAAK;EAChB,UAAU,EAAE;CACb","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, KernelFunc, Mean, MeanAttrs, MeanInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {BackendWasm} from '../backend_wasm';\nimport {cast} from './Cast';\n\nimport {permuteAxesAndTranspose} from './kernel_utils';\n\nlet wasmMean: (xId: number, reduceSize: number, outId: number) => void;\n\nfunction setup(backend: BackendWasm): void {\n  wasmMean =\n      backend.wasm.cwrap(Mean, null /*void*/, ['number, number, number']);\n}\n\nexport function mean(\n    args: {backend: BackendWasm, inputs: MeanInputs, attrs: MeanAttrs}):\n    TensorInfo {\n  const {backend, inputs, attrs} = args;\n  const {axis, keepDims} = attrs;\n  const {x} = inputs;\n  const xId = backend.dataIdMap.get(x.dataId).id;\n  let inputId = xId;\n  let input = x;\n\n  const {transposed, axes, originalAxes, inputWasTransposed} =\n      permuteAxesAndTranspose(x, axis, backend);\n\n  let reductionAxes = axes;\n  if (inputWasTransposed) {\n    const transposedId = backend.dataIdMap.get(transposed.dataId).id;\n    if (transposedId !== xId) {\n      // transpose was not a no-op. We will need to dispose of this\n      // once we are done.\n      input = transposed;\n      inputId = transposedId;\n      reductionAxes = backend_util.getInnerMostAxes(\n          reductionAxes.length, input.shape.length);\n    }\n  }\n\n  backend_util.assertAxesAreInnerMostDims(\n      'mean', reductionAxes, input.shape.length);\n  const [outShape, reduceShape] =\n      backend_util.computeOutAndReduceShapes(input.shape, reductionAxes);\n  const reduceSize = util.sizeFromShape(reduceShape);\n  let castedInput = input;\n  if (input.dtype !== 'float32') {\n    castedInput =\n        cast({backend, inputs: {x: input}, attrs: {dtype: 'float32'}});\n    inputId = backend.dataIdMap.get(castedInput.dataId).id;\n  }\n\n  const out = backend.makeOutput(outShape, 'float32');\n  if (util.sizeFromShape(input.shape) !== 0) {\n    const outId = backend.dataIdMap.get(out.dataId).id;\n    wasmMean(inputId, reduceSize, outId);\n  }\n\n  if (inputWasTransposed) {\n    // dispose of the transposed tensor.\n    backend.disposeData(transposed.dataId);\n  }\n\n  if (keepDims) {\n    // reshape\n    const newShape = backend_util.expandShapeToKeepDim(out.shape, originalAxes);\n    out.shape = newShape;\n  }\n\n  if (input.dtype !== 'float32') {\n    backend.disposeData(castedInput.dataId);\n  }\n\n  return out;\n}\n\nexport const meanConfig: KernelConfig = {\n  kernelName: Mean,\n  backendName: 'wasm',\n  setupFunc: setup,\n  kernelFunc: mean as {} as KernelFunc\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}