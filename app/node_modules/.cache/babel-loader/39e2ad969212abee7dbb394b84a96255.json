{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { clone, util } from '@tensorflow/tfjs-core';\nexport function getParamValue(paramName, node, tensorMap, context, resourceManager) {\n  const inputParam = node.inputParams[paramName];\n  if (inputParam && inputParam.inputIndexStart !== undefined) {\n    const start = inputParam.inputIndexStart;\n    const end = inputParam.inputIndexEnd === 0 ? undefined : inputParam.inputIndexEnd === undefined ? start + 1 : inputParam.inputIndexEnd;\n    if (inputParam.type === 'tensor') {\n      return getTensor(node.inputNames[inputParam.inputIndexStart], tensorMap, context, resourceManager);\n    }\n    if (inputParam.type === 'tensors') {\n      const inputs = node.inputNames.slice(start, end);\n      return inputs.map(name => getTensor(name, tensorMap, context, resourceManager));\n    }\n    const tensor = getTensor(node.inputNames.slice(start)[0], tensorMap, context, resourceManager);\n    const data = tensor.dataSync();\n    return inputParam.type === 'number' ? data[0] : util.toNestedArray(tensor.shape, data);\n  }\n  const attrParam = node.attrParams[paramName];\n  return attrParam && attrParam.value;\n}\n/**\n * Retrieve the tensor from tensorsMap based on input name.\n * @param name Node input name\n * @param tensorsMap Tensors map keyed by the node\n * @param context contains tensors and information for running the current node.\n * @param resourceManager Optional. Contains global resources of the model.\n */\nexport function getTensor(name, tensorsMap, context, resourceManager) {\n  const [nodeName, index] = parseNodeName(name);\n  if (resourceManager != null) {\n    const tensor = resourceManager.getHashTableHandleByName(nodeName);\n    if (tensor != null) {\n      return tensor;\n    }\n  }\n  const contextId = context.currentContextIds.find(contextId => {\n    return !!tensorsMap[getNodeNameWithContextId(nodeName, contextId)];\n  });\n  return contextId !== undefined ? tensorsMap[getNodeNameWithContextId(nodeName, contextId)][index] : undefined;\n}\n/**\n * Retrieve the tensors based on input name for current context.\n * @param name Node input name\n * @param tensorsMap Tensors map keyed by the node\n */\nexport function getTensorsForCurrentContenxt(name, tensorsMap, context) {\n  return tensorsMap[getNodeNameWithContextId(name, context.currentContextId)];\n}\n/**\n * Returns the node name, outputName and index from the Node input name.\n * @param inputName The input name of the node, in format of\n * node_name:output_index, i.e. MatMul:0, if the output_index is not set, it is\n * default to 0.\n * If the input name contains output name i.e. StringSplit:indices:0, it will\n * return ['StringSplit', 0, 'indices'].\n */\nexport function getNodeNameAndIndex(inputName, context) {\n  const [nodeName, index, outputName] = parseNodeName(inputName);\n  return [getNodeNameWithContextId(nodeName, context && context.currentContextId), index, outputName];\n}\nfunction getNodeNameWithContextId(name, contextId) {\n  return !!contextId ? `${name}-${contextId}` : name;\n}\nexport function parseNodeName(name) {\n  const parts = name.split(':');\n  if (parts.length === 1) {\n    return [name, 0, undefined];\n  }\n  const nodeName = parts[0];\n  const outputName = parts.length === 3 ? parts[1] : undefined;\n  const index = Number(parts[parts.length - 1]);\n  return [nodeName, index, outputName];\n}\nexport function split(arr, size) {\n  const res = [];\n  for (let i = 0; i < arr.length; i += size) {\n    res.push(arr.slice(i, i + size));\n  }\n  return res;\n}\nexport function getPadding(node, tensorMap, context) {\n  let pad = getParamValue('pad', node, tensorMap, context);\n  if (pad === 'explicit') {\n    // This is 1d array, we need to convert it to 2d array\n    pad = getParamValue('explicitPaddings', node, tensorMap, context);\n    const explicitPadding = [[0, 0], [0, 0], [0, 0], [0, 0]];\n    for (let i = 0; i < 4; i++) {\n      explicitPadding[i][0] = pad[i * 2];\n      explicitPadding[i][1] = pad[i * 2 + 1];\n    }\n    return explicitPadding;\n  }\n  return pad;\n}\n/**\n *  Reuse the tensor if it is marked as keep, otherwise clone the tensor to\n *  avoid disposal. This is important for TensorArray and TensorList ops, since\n *  internally they use a tensor as the id for TensorArray and TensorList, and\n * to simplify lookup, they also use Tensor.id as the key to the internal map.\n * These id tensors have been marked as kept in the backend, we need avoid clone\n * them in order to create new Tensor.id.\n * @param tensor\n */\nexport function cloneTensor(tensor) {\n  return tensor.kept ? tensor : clone(tensor);\n}","map":{"version":3,"sources":["../../../../../../../tfjs-converter/src/operations/executors/utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {clone, Tensor, util} from '@tensorflow/tfjs-core';\n\nimport {NamedTensorsMap} from '../../data/types';\nimport {ExecutionContext} from '../../executor/execution_context';\nimport {ResourceManager} from '../../executor/resource_manager';\nimport {Node, ValueType} from '../types';\n\nexport function getParamValue(\n    paramName: string, node: Node, tensorMap: NamedTensorsMap,\n    context: ExecutionContext, resourceManager?: ResourceManager): ValueType {\n  const inputParam = node.inputParams[paramName];\n  if (inputParam && inputParam.inputIndexStart !== undefined) {\n    const start = inputParam.inputIndexStart;\n    const end = inputParam.inputIndexEnd === 0 ?\n        undefined :\n        (inputParam.inputIndexEnd === undefined ? start + 1 :\n                                                  inputParam.inputIndexEnd);\n    if (inputParam.type === 'tensor') {\n      return getTensor(\n          node.inputNames[inputParam.inputIndexStart], tensorMap, context,\n          resourceManager);\n    }\n    if (inputParam.type === 'tensors') {\n      const inputs = node.inputNames.slice(start, end);\n\n      return inputs.map(\n          name => getTensor(name, tensorMap, context, resourceManager));\n    }\n    const tensor = getTensor(\n        node.inputNames.slice(start)[0], tensorMap, context, resourceManager);\n    const data = tensor.dataSync();\n    return inputParam.type === 'number' ?\n        data[0] :\n        util.toNestedArray(tensor.shape, data);\n  }\n  const attrParam = node.attrParams[paramName];\n  return attrParam && attrParam.value;\n}\n\n/**\n * Retrieve the tensor from tensorsMap based on input name.\n * @param name Node input name\n * @param tensorsMap Tensors map keyed by the node\n * @param context contains tensors and information for running the current node.\n * @param resourceManager Optional. Contains global resources of the model.\n */\nexport function getTensor(\n    name: string, tensorsMap: NamedTensorsMap, context: ExecutionContext,\n    resourceManager?: ResourceManager): Tensor {\n  const [nodeName, index] = parseNodeName(name);\n\n  if (resourceManager != null) {\n    const tensor = resourceManager.getHashTableHandleByName(nodeName);\n    if (tensor != null) {\n      return tensor;\n    }\n  }\n\n  const contextId = context.currentContextIds.find(contextId => {\n    return !!tensorsMap[getNodeNameWithContextId(nodeName, contextId)];\n  });\n\n  return contextId !== undefined ?\n      tensorsMap[getNodeNameWithContextId(nodeName, contextId)][index] :\n      undefined;\n}\n\n/**\n * Retrieve the tensors based on input name for current context.\n * @param name Node input name\n * @param tensorsMap Tensors map keyed by the node\n */\nexport function getTensorsForCurrentContenxt(\n    name: string, tensorsMap: NamedTensorsMap,\n    context: ExecutionContext): Tensor[] {\n  return tensorsMap[getNodeNameWithContextId(name, context.currentContextId)];\n}\n\n/**\n * Returns the node name, outputName and index from the Node input name.\n * @param inputName The input name of the node, in format of\n * node_name:output_index, i.e. MatMul:0, if the output_index is not set, it is\n * default to 0.\n * If the input name contains output name i.e. StringSplit:indices:0, it will\n * return ['StringSplit', 0, 'indices'].\n */\nexport function getNodeNameAndIndex(\n    inputName: string, context?: ExecutionContext): [string, number, string] {\n  const [nodeName, index, outputName] = parseNodeName(inputName);\n\n  return [\n    getNodeNameWithContextId(nodeName, context && context.currentContextId),\n    index, outputName\n  ];\n}\n\nfunction getNodeNameWithContextId(name: string, contextId?: string): string {\n  return !!contextId ? `${name}-${contextId}` : name;\n}\n\nexport function parseNodeName(name: string): [string, number, string] {\n  const parts = name.split(':');\n  if (parts.length === 1) {\n    return [name, 0, undefined];\n  }\n\n  const nodeName = parts[0];\n  const outputName = parts.length === 3 ? parts[1] : undefined;\n  const index = Number(parts[parts.length - 1]);\n  return [nodeName, index, outputName];\n}\n\nexport function split(arr: number[], size: number) {\n  const res = [];\n  for (let i = 0; i < arr.length; i += size) {\n    res.push(arr.slice(i, i + size));\n  }\n  return res;\n}\nexport function getPadding(\n    node: Node, tensorMap: NamedTensorsMap,\n    context: ExecutionContext): ValueType {\n  let pad = getParamValue('pad', node, tensorMap, context);\n  if (pad === 'explicit') {\n    // This is 1d array, we need to convert it to 2d array\n    pad = getParamValue('explicitPaddings', node, tensorMap, context);\n    const explicitPadding: [\n      [number, number], [number, number], [number, number], [number, number]\n    ] = [[0, 0], [0, 0], [0, 0], [0, 0]];\n    for (let i = 0; i < 4; i++) {\n      explicitPadding[i][0] = (pad as number[])[i * 2];\n      explicitPadding[i][1] = (pad as number[])[i * 2 + 1];\n    }\n    return explicitPadding;\n  }\n  return pad;\n}\n\n/**\n *  Reuse the tensor if it is marked as keep, otherwise clone the tensor to\n *  avoid disposal. This is important for TensorArray and TensorList ops, since\n *  internally they use a tensor as the id for TensorArray and TensorList, and\n * to simplify lookup, they also use Tensor.id as the key to the internal map.\n * These id tensors have been marked as kept in the backend, we need avoid clone\n * them in order to create new Tensor.id.\n * @param tensor\n */\nexport function cloneTensor(tensor: Tensor): Tensor {\n  return tensor.kept ? tensor : clone(tensor);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}