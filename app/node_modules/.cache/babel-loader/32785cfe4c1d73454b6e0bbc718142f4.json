{"ast":null,"code":"import { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { conv2d } from './conv2d';\nimport * as conv_util from './conv_util';\nimport { op } from './operation';\nimport { reshape } from './reshape';\n/**\n * Computes a 1D convolution over the input x.\n *\n * @param x The input tensor, of rank 3 or rank 2, of shape\n *     `[batch, width, inChannels]`. If rank 2, batch of 1 is assumed.\n * @param filter The filter, rank 3, of shape\n *     `[filterWidth, inDepth, outDepth]`.\n * @param stride The number of entries by which the filter is moved right at\n *     each step.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dataFormat An optional string from \"NWC\", \"NCW\". Defaults to \"NWC\",\n *     the data is stored in the order of [batch, in_width, in_channels]. Only\n *     \"NWC\" is currently supported.\n * @param dilation The dilation rate in which we sample input values in\n *     atrous convolution. Defaults to `1`. If it is greater than 1, then\n *     stride must be `1`.\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n *\n * @doc {heading: 'Operations', subheading: 'Convolution'}\n */\nfunction conv1d_(x, filter, stride, pad) {\n  let dataFormat = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'NWC';\n  let dilation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n  let dimRoundingMode = arguments.length > 6 ? arguments[6] : undefined;\n  const $x = convertToTensor(x, 'x', 'conv1d');\n  const $filter = convertToTensor(filter, 'filter', 'conv1d');\n  let x3D = $x;\n  let reshapedTo3D = false;\n  if ($x.rank === 2) {\n    reshapedTo3D = true;\n    x3D = reshape($x, [1, $x.shape[0], $x.shape[1]]);\n  }\n  util.assert(x3D.rank === 3, () => `Error in conv1d: input must be rank 3, but got rank ${x3D.rank}.`);\n  util.assert($filter.rank === 3, () => `Error in conv1d: filter must be rank 3, but got rank ` + `${$filter.rank}.`);\n  if (dimRoundingMode != null) {\n    util.assert(util.isInt(pad), () => `Error in conv1d: pad must be an integer when using, ` + `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n  util.assert(x3D.shape[2] === $filter.shape[1], () => `Error in conv1d: depth of input (${x3D.shape[2]}) must match ` + `input depth for filter ${$filter.shape[1]}.`);\n  util.assert(conv_util.eitherStridesOrDilationsAreOne(stride, dilation), () => 'Error in conv1D: Either stride or dilation must be 1. ' + `Got stride ${stride} and dilation '${dilation}'`);\n  util.assert(dataFormat === 'NWC', () => `Error in conv1d: got dataFormat of ${dataFormat} but only NWC is currently supported.`);\n  const filter4D = reshape($filter, [1, $filter.shape[0], $filter.shape[1], $filter.shape[2]]);\n  const input4D = reshape(x3D, [x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]]);\n  const strides = [1, stride];\n  const dilations = [1, dilation];\n  const conv2dDataFormat = 'NHWC';\n  const res = conv2d(input4D, filter4D, strides, pad, conv2dDataFormat, dilations, dimRoundingMode);\n  if (reshapedTo3D) {\n    return reshape(res, [res.shape[2], res.shape[3]]);\n  }\n  return reshape(res, [res.shape[0], res.shape[2], res.shape[3]]);\n}\nexport const conv1d = op({\n  conv1d_\n});","map":{"version":3,"sources":["../../src/ops/conv1d.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { conv2d } from './conv2d';\nimport * as conv_util from './conv_util';\nimport { op } from './operation';\nimport { reshape } from './reshape';\n/**\n * Computes a 1D convolution over the input x.\n *\n * @param x The input tensor, of rank 3 or rank 2, of shape\n *     `[batch, width, inChannels]`. If rank 2, batch of 1 is assumed.\n * @param filter The filter, rank 3, of shape\n *     `[filterWidth, inDepth, outDepth]`.\n * @param stride The number of entries by which the filter is moved right at\n *     each step.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dataFormat An optional string from \"NWC\", \"NCW\". Defaults to \"NWC\",\n *     the data is stored in the order of [batch, in_width, in_channels]. Only\n *     \"NWC\" is currently supported.\n * @param dilation The dilation rate in which we sample input values in\n *     atrous convolution. Defaults to `1`. If it is greater than 1, then\n *     stride must be `1`.\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n *\n * @doc {heading: 'Operations', subheading: 'Convolution'}\n */\nfunction conv1d_(x, filter, stride, pad, dataFormat = 'NWC', dilation = 1, dimRoundingMode) {\n    const $x = convertToTensor(x, 'x', 'conv1d');\n    const $filter = convertToTensor(filter, 'filter', 'conv1d');\n    let x3D = $x;\n    let reshapedTo3D = false;\n    if ($x.rank === 2) {\n        reshapedTo3D = true;\n        x3D = reshape($x, [1, $x.shape[0], $x.shape[1]]);\n    }\n    util.assert(x3D.rank === 3, () => `Error in conv1d: input must be rank 3, but got rank ${x3D.rank}.`);\n    util.assert($filter.rank === 3, () => `Error in conv1d: filter must be rank 3, but got rank ` +\n        `${$filter.rank}.`);\n    if (dimRoundingMode != null) {\n        util.assert(util.isInt(pad), () => `Error in conv1d: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    }\n    util.assert(x3D.shape[2] === $filter.shape[1], () => `Error in conv1d: depth of input (${x3D.shape[2]}) must match ` +\n        `input depth for filter ${$filter.shape[1]}.`);\n    util.assert(conv_util.eitherStridesOrDilationsAreOne(stride, dilation), () => 'Error in conv1D: Either stride or dilation must be 1. ' +\n        `Got stride ${stride} and dilation '${dilation}'`);\n    util.assert(dataFormat === 'NWC', () => `Error in conv1d: got dataFormat of ${dataFormat} but only NWC is currently supported.`);\n    const filter4D = reshape($filter, [1, $filter.shape[0], $filter.shape[1], $filter.shape[2]]);\n    const input4D = reshape(x3D, [x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]]);\n    const strides = [1, stride];\n    const dilations = [1, dilation];\n    const conv2dDataFormat = 'NHWC';\n    const res = conv2d(input4D, filter4D, strides, pad, conv2dDataFormat, dilations, dimRoundingMode);\n    if (reshapedTo3D) {\n        return reshape(res, [res.shape[2], res.shape[3]]);\n    }\n    return reshape(res, [res.shape[0], res.shape[2], res.shape[3]]);\n}\nexport const conv1d = op({ conv1d_ });\n//# sourceMappingURL=conv1d.js.map"]},"metadata":{},"sourceType":"module"}