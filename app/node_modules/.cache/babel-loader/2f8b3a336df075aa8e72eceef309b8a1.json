{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Conv2DBackpropInput, TensorBuffer, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function conv2DBackpropInput(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    dy,\n    filter\n  } = inputs;\n  const {\n    inputShape,\n    strides,\n    pad,\n    dataFormat,\n    dimRoundingMode\n  } = attrs;\n  assertNotComplex([dy, filter], 'conv2dBackpropInput');\n  const filterStrides = util.computeStrides(filter.shape);\n  const dyStrides = util.computeStrides(dy.shape);\n  let $dataFormat = backend_util.convertConv2DDataFormat(dataFormat);\n  const convInfo = backend_util.computeConv2DInfo(inputShape, filter.shape, strides, 1 /* dilations */, pad, dimRoundingMode, false, $dataFormat);\n  const dx = new TensorBuffer(convInfo.inShape, 'float32');\n  const dxValues = dx.values;\n  const dyValues = backend.data.get(dy.dataId).values;\n  const fltValues = backend.data.get(filter.dataId).values;\n  const [fltS0, fltS1, fltS2] = filterStrides;\n  const {\n    batchSize,\n    filterHeight,\n    filterWidth,\n    inChannels,\n    inHeight,\n    inWidth,\n    outChannels,\n    outHeight,\n    outWidth,\n    strideHeight,\n    strideWidth\n  } = convInfo;\n  $dataFormat = convInfo.dataFormat;\n  const topPad = filterHeight - 1 - convInfo.padInfo.top;\n  const leftPad = filterWidth - 1 - convInfo.padInfo.left;\n  const isChannelsLast = $dataFormat === 'channelsLast';\n  const xBatchStride = dx.strides[0];\n  const xRowStride = isChannelsLast ? dx.strides[1] : dx.strides[2];\n  const xColStride = isChannelsLast ? dx.strides[2] : 1;\n  const xChannelStride = isChannelsLast ? 1 : dx.strides[1];\n  const yBatchStride = dyStrides[0];\n  const yRowStride = isChannelsLast ? dyStrides[1] : dyStrides[2];\n  const yColStride = isChannelsLast ? dyStrides[2] : 1;\n  const yChannelStride = isChannelsLast ? 1 : dyStrides[1];\n  for (let b = 0; b < batchSize; ++b) {\n    for (let d1 = 0; d1 < inChannels; ++d1) {\n      for (let xR = 0; xR < inHeight; ++xR) {\n        const xRCorner = xR - topPad;\n        const xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));\n        const yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);\n        for (let xC = 0; xC < inWidth; ++xC) {\n          const xCCorner = xC - leftPad;\n          const xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));\n          const yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);\n          let dotProd = 0;\n          for (let yR = xRMin; yR < yRMax; ++yR) {\n            const wR = yR * strideHeight - xRCorner;\n            for (let yC = xCMin; yC < yCMax; ++yC) {\n              const wC = yC * strideWidth - xCCorner;\n              const dyOffset = yBatchStride * b + yRowStride * yR + yColStride * yC;\n              const fltOffset = fltS0 * (filterHeight - 1 - wR) + fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;\n              for (let d2 = 0; d2 < outChannels; ++d2) {\n                const pixel = dyValues[dyOffset + yChannelStride * d2];\n                const weight = fltValues[fltOffset + d2];\n                dotProd += pixel * weight;\n              }\n            }\n          }\n          const dxOffset = xBatchStride * b + xRowStride * xR + xColStride * xC + xChannelStride * d1;\n          dxValues[dxOffset] = dotProd;\n        }\n      }\n    }\n  }\n  return backend.makeTensorInfo(dx.shape, dx.dtype, dx.values);\n}\nexport const conv2DBackpropInputConfig = {\n  kernelName: Conv2DBackpropInput,\n  backendName: 'cpu',\n  kernelFunc: conv2DBackpropInput\n};","map":{"version":3,"sources":["../../src/kernels/Conv2DBackpropInput.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,YAAY,EAAE,mBAAmB,EAAiF,YAAY,EAA0B,IAAI,QAAO,uBAAuB;AAGlM,SAAQ,gBAAgB,QAAO,aAAa;AAE5C,OAAM,SAAU,mBAAmB,CAAC,IAInC,EAAA;EACC,MAAM;IAAC,MAAM;IAAE,OAAO;IAAE;EAAK,CAAC,GAAG,IAAI;EACrC,MAAM;IAAC,EAAE;IAAE;EAAM,CAAC,GAAG,MAAM;EAC3B,MAAM;IAAC,UAAU;IAAE,OAAO;IAAE,GAAG;IAAE,UAAU;IAAE;EAAe,CAAC,GAAG,KAAK;EAErE,gBAAgB,CAAC,CAAC,EAAE,EAAE,MAAM,CAAC,EAAE,qBAAqB,CAAC;EAErD,MAAM,aAAa,GAAG,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,KAAK,CAAC;EACvD,MAAM,SAAS,GAAG,IAAI,CAAC,cAAc,CAAC,EAAE,CAAC,KAAK,CAAC;EAE/C,IAAI,WAAW,GAAG,YAAY,CAAC,uBAAuB,CAAC,UAAU,CAAC;EAClE,MAAM,QAAQ,GAAG,YAAY,CAAC,iBAAiB,CAC3C,UAAU,EAAE,MAAM,CAAC,KAAyC,EAAE,OAAO,EACrE,CAAC,CAAC,iBAAiB,GAAG,EAAE,eAAe,EAAE,KAAK,EAAE,WAAW,CAAC;EAEhE,MAAM,EAAE,GAAG,IAAI,YAAY,CAAC,QAAQ,CAAC,OAAO,EAAE,SAAS,CAAC;EACxD,MAAM,QAAQ,GAAG,EAAE,CAAC,MAAM;EAC1B,MAAM,QAAQ,GAAG,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC,MAAoB;EACjE,MAAM,SAAS,GAAG,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,MAAoB;EACtE,MAAM,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,GAAG,aAAa;EAC3C,MAAM;IACJ,SAAS;IACT,YAAY;IACZ,WAAW;IACX,UAAU;IACV,QAAQ;IACR,OAAO;IACP,WAAW;IACX,SAAS;IACT,QAAQ;IACR,YAAY;IACZ;EAAW,CACZ,GAAG,QAAQ;EACZ,WAAW,GAAG,QAAQ,CAAC,UAAU;EACjC,MAAM,MAAM,GAAG,YAAY,GAAG,CAAC,GAAG,QAAQ,CAAC,OAAO,CAAC,GAAG;EACtD,MAAM,OAAO,GAAG,WAAW,GAAG,CAAC,GAAG,QAAQ,CAAC,OAAO,CAAC,IAAI;EAEvD,MAAM,cAAc,GAAG,WAAW,KAAK,cAAc;EACrD,MAAM,YAAY,GAAG,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC;EAClC,MAAM,UAAU,GAAG,cAAc,GAAG,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC;EACjE,MAAM,UAAU,GAAG,cAAc,GAAG,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC;EACrD,MAAM,cAAc,GAAG,cAAc,GAAG,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC;EACzD,MAAM,YAAY,GAAG,SAAS,CAAC,CAAC,CAAC;EACjC,MAAM,UAAU,GAAG,cAAc,GAAG,SAAS,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC;EAC/D,MAAM,UAAU,GAAG,cAAc,GAAG,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;EACpD,MAAM,cAAc,GAAG,cAAc,GAAG,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC;EAExD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,EAAE,EAAE,CAAC,EAAE;IAClC,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,UAAU,EAAE,EAAE,EAAE,EAAE;MACtC,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,QAAQ,EAAE,EAAE,EAAE,EAAE;QACpC,MAAM,QAAQ,GAAG,EAAE,GAAG,MAAM;QAC5B,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,YAAY,CAAC,CAAC;QAC7D,MAAM,KAAK,GACP,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,YAAY,GAAG,QAAQ,IAAI,YAAY,CAAC;QAEjE,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,OAAO,EAAE,EAAE,EAAE,EAAE;UACnC,MAAM,QAAQ,GAAG,EAAE,GAAG,OAAO;UAC7B,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,WAAW,CAAC,CAAC;UAC5D,MAAM,KAAK,GACP,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,WAAW,GAAG,QAAQ,IAAI,WAAW,CAAC;UAE9D,IAAI,OAAO,GAAG,CAAC;UACf,KAAK,IAAI,EAAE,GAAG,KAAK,EAAE,EAAE,GAAG,KAAK,EAAE,EAAE,EAAE,EAAE;YACrC,MAAM,EAAE,GAAG,EAAE,GAAG,YAAY,GAAG,QAAQ;YAEvC,KAAK,IAAI,EAAE,GAAG,KAAK,EAAE,EAAE,GAAG,KAAK,EAAE,EAAE,EAAE,EAAE;cACrC,MAAM,EAAE,GAAG,EAAE,GAAG,WAAW,GAAG,QAAQ;cACtC,MAAM,QAAQ,GACV,YAAY,GAAG,CAAC,GAAG,UAAU,GAAG,EAAE,GAAG,UAAU,GAAG,EAAE;cACxD,MAAM,SAAS,GAAG,KAAK,IAAI,YAAY,GAAG,CAAC,GAAG,EAAE,CAAC,GAC7C,KAAK,IAAI,WAAW,GAAG,CAAC,GAAG,EAAE,CAAC,GAAG,KAAK,GAAG,EAAE;cAE/C,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,WAAW,EAAE,EAAE,EAAE,EAAE;gBACvC,MAAM,KAAK,GAAG,QAAQ,CAAC,QAAQ,GAAG,cAAc,GAAG,EAAE,CAAC;gBACtD,MAAM,MAAM,GAAG,SAAS,CAAC,SAAS,GAAG,EAAE,CAAC;gBACxC,OAAO,IAAI,KAAK,GAAG,MAAM;cAC1B;YACF;UACF;UACD,MAAM,QAAQ,GAAG,YAAY,GAAG,CAAC,GAAG,UAAU,GAAG,EAAE,GAC/C,UAAU,GAAG,EAAE,GAAG,cAAc,GAAG,EAAE;UACzC,QAAQ,CAAC,QAAQ,CAAC,GAAG,OAAO;QAC7B;MACF;IACF;EACF;EAED,OAAO,OAAO,CAAC,cAAc,CAAC,EAAE,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,EAAE,EAAE,CAAC,MAAM,CAAC;AAC9D;AAEA,OAAO,MAAM,yBAAyB,GAAiB;EACrD,UAAU,EAAE,mBAAmB;EAC/B,WAAW,EAAE,KAAK;EAClB,UAAU,EAAE;CACb","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Conv2DBackpropInput, TensorBuffer, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function conv2DBackpropInput(args) {\n    const { inputs, backend, attrs } = args;\n    const { dy, filter } = inputs;\n    const { inputShape, strides, pad, dataFormat, dimRoundingMode } = attrs;\n    assertNotComplex([dy, filter], 'conv2dBackpropInput');\n    const filterStrides = util.computeStrides(filter.shape);\n    const dyStrides = util.computeStrides(dy.shape);\n    let $dataFormat = backend_util.convertConv2DDataFormat(dataFormat);\n    const convInfo = backend_util.computeConv2DInfo(inputShape, filter.shape, strides, 1 /* dilations */, pad, dimRoundingMode, false, $dataFormat);\n    const dx = new TensorBuffer(convInfo.inShape, 'float32');\n    const dxValues = dx.values;\n    const dyValues = backend.data.get(dy.dataId).values;\n    const fltValues = backend.data.get(filter.dataId).values;\n    const [fltS0, fltS1, fltS2] = filterStrides;\n    const { batchSize, filterHeight, filterWidth, inChannels, inHeight, inWidth, outChannels, outHeight, outWidth, strideHeight, strideWidth } = convInfo;\n    $dataFormat = convInfo.dataFormat;\n    const topPad = filterHeight - 1 - convInfo.padInfo.top;\n    const leftPad = filterWidth - 1 - convInfo.padInfo.left;\n    const isChannelsLast = $dataFormat === 'channelsLast';\n    const xBatchStride = dx.strides[0];\n    const xRowStride = isChannelsLast ? dx.strides[1] : dx.strides[2];\n    const xColStride = isChannelsLast ? dx.strides[2] : 1;\n    const xChannelStride = isChannelsLast ? 1 : dx.strides[1];\n    const yBatchStride = dyStrides[0];\n    const yRowStride = isChannelsLast ? dyStrides[1] : dyStrides[2];\n    const yColStride = isChannelsLast ? dyStrides[2] : 1;\n    const yChannelStride = isChannelsLast ? 1 : dyStrides[1];\n    for (let b = 0; b < batchSize; ++b) {\n        for (let d1 = 0; d1 < inChannels; ++d1) {\n            for (let xR = 0; xR < inHeight; ++xR) {\n                const xRCorner = xR - topPad;\n                const xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));\n                const yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);\n                for (let xC = 0; xC < inWidth; ++xC) {\n                    const xCCorner = xC - leftPad;\n                    const xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));\n                    const yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);\n                    let dotProd = 0;\n                    for (let yR = xRMin; yR < yRMax; ++yR) {\n                        const wR = yR * strideHeight - xRCorner;\n                        for (let yC = xCMin; yC < yCMax; ++yC) {\n                            const wC = yC * strideWidth - xCCorner;\n                            const dyOffset = yBatchStride * b + yRowStride * yR + yColStride * yC;\n                            const fltOffset = fltS0 * (filterHeight - 1 - wR) +\n                                fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;\n                            for (let d2 = 0; d2 < outChannels; ++d2) {\n                                const pixel = dyValues[dyOffset + yChannelStride * d2];\n                                const weight = fltValues[fltOffset + d2];\n                                dotProd += pixel * weight;\n                            }\n                        }\n                    }\n                    const dxOffset = xBatchStride * b + xRowStride * xR +\n                        xColStride * xC + xChannelStride * d1;\n                    dxValues[dxOffset] = dotProd;\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo(dx.shape, dx.dtype, dx.values);\n}\nexport const conv2DBackpropInputConfig = {\n    kernelName: Conv2DBackpropInput,\n    backendName: 'cpu',\n    kernelFunc: conv2DBackpropInput\n};\n//# sourceMappingURL=Conv2DBackpropInput.js.map"]},"metadata":{},"sourceType":"module"}