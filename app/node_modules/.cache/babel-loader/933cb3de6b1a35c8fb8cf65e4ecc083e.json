{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { All, backend_util, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { reshape } from './Reshape';\nimport { transpose } from './Transpose';\nexport function all(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    x\n  } = inputs;\n  const {\n    axis,\n    keepDims\n  } = attrs;\n  assertNotComplex(x, 'all');\n  const origAxes = util.parseAxisParam(axis, x.shape);\n  let axes = origAxes;\n  const permutedAxes = backend_util.getAxesPermutation(axes, x.shape.length);\n  let $x = x;\n  if (permutedAxes != null) {\n    $x = transpose({\n      inputs: {\n        x\n      },\n      backend,\n      attrs: {\n        perm: permutedAxes\n      }\n    });\n    axes = backend_util.getInnerMostAxes(axes.length, x.shape.length);\n  }\n  backend_util.assertAxesAreInnerMostDims('all', axes, $x.shape.length);\n  const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes($x.shape, axes);\n  const reduceSize = util.sizeFromShape(reduceShape);\n  const vals = util.makeZerosTypedArray(util.sizeFromShape(outShape), $x.dtype);\n  const aVals = backend.data.get($x.dataId).values;\n  for (let i = 0; i < vals.length; ++i) {\n    const offset = i * reduceSize;\n    let all = aVals[offset];\n    for (let j = 0; j < reduceSize; ++j) {\n      const value = aVals[offset + j];\n      all = all && value;\n    }\n    vals[i] = all;\n  }\n  if (permutedAxes != null) {\n    backend.disposeIntermediateTensorInfo($x);\n  }\n  const result = backend.makeTensorInfo(outShape, $x.dtype, vals);\n  if (keepDims) {\n    const expandedShape = backend_util.expandShapeToKeepDim(outShape, origAxes);\n    const reshapedResult = reshape({\n      inputs: {\n        x: result\n      },\n      backend,\n      attrs: {\n        shape: expandedShape\n      }\n    });\n    backend.disposeIntermediateTensorInfo(result);\n    return reshapedResult;\n  }\n  return result;\n}\nexport const allConfig = {\n  kernelName: All,\n  backendName: 'cpu',\n  kernelFunc: all\n};","map":{"version":3,"sources":["../../src/kernels/All.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { All, backend_util, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { reshape } from './Reshape';\nimport { transpose } from './Transpose';\nexport function all(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { axis, keepDims } = attrs;\n    assertNotComplex(x, 'all');\n    const origAxes = util.parseAxisParam(axis, x.shape);\n    let axes = origAxes;\n    const permutedAxes = backend_util.getAxesPermutation(axes, x.shape.length);\n    let $x = x;\n    if (permutedAxes != null) {\n        $x = transpose({ inputs: { x }, backend, attrs: { perm: permutedAxes } });\n        axes = backend_util.getInnerMostAxes(axes.length, x.shape.length);\n    }\n    backend_util.assertAxesAreInnerMostDims('all', axes, $x.shape.length);\n    const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes($x.shape, axes);\n    const reduceSize = util.sizeFromShape(reduceShape);\n    const vals = util.makeZerosTypedArray(util.sizeFromShape(outShape), $x.dtype);\n    const aVals = backend.data.get($x.dataId).values;\n    for (let i = 0; i < vals.length; ++i) {\n        const offset = i * reduceSize;\n        let all = aVals[offset];\n        for (let j = 0; j < reduceSize; ++j) {\n            const value = aVals[offset + j];\n            all = all && value;\n        }\n        vals[i] = all;\n    }\n    if (permutedAxes != null) {\n        backend.disposeIntermediateTensorInfo($x);\n    }\n    const result = backend.makeTensorInfo(outShape, $x.dtype, vals);\n    if (keepDims) {\n        const expandedShape = backend_util.expandShapeToKeepDim(outShape, origAxes);\n        const reshapedResult = reshape({ inputs: { x: result }, backend, attrs: { shape: expandedShape } });\n        backend.disposeIntermediateTensorInfo(result);\n        return reshapedResult;\n    }\n    return result;\n}\nexport const allConfig = {\n    kernelName: All,\n    backendName: 'cpu',\n    kernelFunc: all\n};\n//# sourceMappingURL=All.js.map"]},"metadata":{},"sourceType":"module"}