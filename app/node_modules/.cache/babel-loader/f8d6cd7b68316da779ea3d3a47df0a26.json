{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport var Rank;\n(function (Rank) {\n  Rank[\"R0\"] = \"R0\";\n  Rank[\"R1\"] = \"R1\";\n  Rank[\"R2\"] = \"R2\";\n  Rank[\"R3\"] = \"R3\";\n  Rank[\"R4\"] = \"R4\";\n  Rank[\"R5\"] = \"R5\";\n  Rank[\"R6\"] = \"R6\";\n})(Rank || (Rank = {}));\n// Looks for upcasting types. Used, for example, in operations with mixed dtype\n// inputs.\nvar UpcastInt32AndMap;\n(function (UpcastInt32AndMap) {\n  UpcastInt32AndMap[\"float32\"] = \"float32\";\n  UpcastInt32AndMap[\"int32\"] = \"int32\";\n  UpcastInt32AndMap[\"bool\"] = \"int32\";\n  UpcastInt32AndMap[\"complex64\"] = \"complex64\";\n})(UpcastInt32AndMap || (UpcastInt32AndMap = {}));\nvar UpcastBoolAndMap;\n(function (UpcastBoolAndMap) {\n  UpcastBoolAndMap[\"float32\"] = \"float32\";\n  UpcastBoolAndMap[\"int32\"] = \"int32\";\n  UpcastBoolAndMap[\"bool\"] = \"bool\";\n  UpcastBoolAndMap[\"complex64\"] = \"complex64\";\n})(UpcastBoolAndMap || (UpcastBoolAndMap = {}));\nvar UpcastFloat32AndMap;\n(function (UpcastFloat32AndMap) {\n  UpcastFloat32AndMap[\"float32\"] = \"float32\";\n  UpcastFloat32AndMap[\"int32\"] = \"float32\";\n  UpcastFloat32AndMap[\"bool\"] = \"float32\";\n  UpcastFloat32AndMap[\"complex64\"] = \"complex64\";\n})(UpcastFloat32AndMap || (UpcastFloat32AndMap = {}));\nvar UpcastComplex64AndMap;\n(function (UpcastComplex64AndMap) {\n  UpcastComplex64AndMap[\"float32\"] = \"complex64\";\n  UpcastComplex64AndMap[\"int32\"] = \"complex64\";\n  UpcastComplex64AndMap[\"bool\"] = \"complex64\";\n  UpcastComplex64AndMap[\"complex64\"] = \"complex64\";\n})(UpcastComplex64AndMap || (UpcastComplex64AndMap = {}));\nconst upcastTypeMap = {\n  'float32': UpcastFloat32AndMap,\n  'int32': UpcastInt32AndMap,\n  'bool': UpcastBoolAndMap,\n  'complex64': UpcastComplex64AndMap\n};\nexport function upcastType(typeA, typeB) {\n  if (typeA === 'string' || typeB === 'string') {\n    if (typeA === 'string' && typeB === 'string') {\n      return 'string';\n    }\n    throw new Error(`Can not upcast ${typeA} with ${typeB}`);\n  }\n  return upcastTypeMap[typeA][typeB];\n}\n/** Returns the output type after summation. */\nexport function sumOutType(type) {\n  return upcastType(type, 'int32');\n}","map":{"version":3,"sources":["../src/types.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAiDH,OAAA,IAAY,IAQX;AARD,CAAA,UAAY,IAAI,EAAA;EACd,IAAA,CAAA,IAAA,CAAA,GAAA,IAAS;EACT,IAAA,CAAA,IAAA,CAAA,GAAA,IAAS;EACT,IAAA,CAAA,IAAA,CAAA,GAAA,IAAS;EACT,IAAA,CAAA,IAAA,CAAA,GAAA,IAAS;EACT,IAAA,CAAA,IAAA,CAAA,GAAA,IAAS;EACT,IAAA,CAAA,IAAA,CAAA,GAAA,IAAS;EACT,IAAA,CAAA,IAAA,CAAA,GAAA,IAAS;AACX,CAAC,EARW,IAAI,KAAJ,IAAI,GAAA,CAAA,CAAA,CAAA,CAAA;AAmBhB;AACA;AACA,IAAK,iBAKJ;AALD,CAAA,UAAK,iBAAiB,EAAA;EACpB,iBAAA,CAAA,SAAA,CAAA,GAAA,SAAqB;EACrB,iBAAA,CAAA,OAAA,CAAA,GAAA,OAAiB;EACjB,iBAAA,CAAA,MAAA,CAAA,GAAA,OAAgB;EAChB,iBAAA,CAAA,WAAA,CAAA,GAAA,WAAyB;AAC3B,CAAC,EALI,iBAAiB,KAAjB,iBAAiB,GAAA,CAAA,CAAA,CAAA,CAAA;AAOtB,IAAK,gBAKJ;AALD,CAAA,UAAK,gBAAgB,EAAA;EACnB,gBAAA,CAAA,SAAA,CAAA,GAAA,SAAqB;EACrB,gBAAA,CAAA,OAAA,CAAA,GAAA,OAAiB;EACjB,gBAAA,CAAA,MAAA,CAAA,GAAA,MAAe;EACf,gBAAA,CAAA,WAAA,CAAA,GAAA,WAAyB;AAC3B,CAAC,EALI,gBAAgB,KAAhB,gBAAgB,GAAA,CAAA,CAAA,CAAA,CAAA;AAOrB,IAAK,mBAKJ;AALD,CAAA,UAAK,mBAAmB,EAAA;EACtB,mBAAA,CAAA,SAAA,CAAA,GAAA,SAAqB;EACrB,mBAAA,CAAA,OAAA,CAAA,GAAA,SAAmB;EACnB,mBAAA,CAAA,MAAA,CAAA,GAAA,SAAkB;EAClB,mBAAA,CAAA,WAAA,CAAA,GAAA,WAAyB;AAC3B,CAAC,EALI,mBAAmB,KAAnB,mBAAmB,GAAA,CAAA,CAAA,CAAA,CAAA;AAOxB,IAAK,qBAKJ;AALD,CAAA,UAAK,qBAAqB,EAAA;EACxB,qBAAA,CAAA,SAAA,CAAA,GAAA,WAAuB;EACvB,qBAAA,CAAA,OAAA,CAAA,GAAA,WAAqB;EACrB,qBAAA,CAAA,MAAA,CAAA,GAAA,WAAoB;EACpB,qBAAA,CAAA,WAAA,CAAA,GAAA,WAAyB;AAC3B,CAAC,EALI,qBAAqB,KAArB,qBAAqB,GAAA,CAAA,CAAA,CAAA,CAAA;AAO1B,MAAM,aAAa,GAAG;EACpB,SAAS,EAAE,mBAAmB;EAC9B,OAAO,EAAE,iBAAiB;EAC1B,MAAM,EAAE,gBAAgB;EACxB,WAAW,EAAE;CACd;AAED,OAAM,SAAU,UAAU,CAAC,KAAe,EAAE,KAAe,EAAA;EACzD,IAAI,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,QAAQ,EAAE;IAC5C,IAAI,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,QAAQ,EAAE;MAC5C,OAAO,QAAQ;IAChB;IACD,MAAM,IAAI,KAAK,CAAC,kBAAkB,KAAK,SAAS,KAAK,EAAE,CAAC;EACzD;EACD,OAAO,aAAa,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC;AACpC;AAEA;AACA,OAAM,SAAU,UAAU,CAAC,IAAc,EAAA;EACvC,OAAO,UAAU,CAAC,IAAI,EAAE,OAAO,CAAC;AAClC","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport var Rank;\n(function (Rank) {\n    Rank[\"R0\"] = \"R0\";\n    Rank[\"R1\"] = \"R1\";\n    Rank[\"R2\"] = \"R2\";\n    Rank[\"R3\"] = \"R3\";\n    Rank[\"R4\"] = \"R4\";\n    Rank[\"R5\"] = \"R5\";\n    Rank[\"R6\"] = \"R6\";\n})(Rank || (Rank = {}));\n// Looks for upcasting types. Used, for example, in operations with mixed dtype\n// inputs.\nvar UpcastInt32AndMap;\n(function (UpcastInt32AndMap) {\n    UpcastInt32AndMap[\"float32\"] = \"float32\";\n    UpcastInt32AndMap[\"int32\"] = \"int32\";\n    UpcastInt32AndMap[\"bool\"] = \"int32\";\n    UpcastInt32AndMap[\"complex64\"] = \"complex64\";\n})(UpcastInt32AndMap || (UpcastInt32AndMap = {}));\nvar UpcastBoolAndMap;\n(function (UpcastBoolAndMap) {\n    UpcastBoolAndMap[\"float32\"] = \"float32\";\n    UpcastBoolAndMap[\"int32\"] = \"int32\";\n    UpcastBoolAndMap[\"bool\"] = \"bool\";\n    UpcastBoolAndMap[\"complex64\"] = \"complex64\";\n})(UpcastBoolAndMap || (UpcastBoolAndMap = {}));\nvar UpcastFloat32AndMap;\n(function (UpcastFloat32AndMap) {\n    UpcastFloat32AndMap[\"float32\"] = \"float32\";\n    UpcastFloat32AndMap[\"int32\"] = \"float32\";\n    UpcastFloat32AndMap[\"bool\"] = \"float32\";\n    UpcastFloat32AndMap[\"complex64\"] = \"complex64\";\n})(UpcastFloat32AndMap || (UpcastFloat32AndMap = {}));\nvar UpcastComplex64AndMap;\n(function (UpcastComplex64AndMap) {\n    UpcastComplex64AndMap[\"float32\"] = \"complex64\";\n    UpcastComplex64AndMap[\"int32\"] = \"complex64\";\n    UpcastComplex64AndMap[\"bool\"] = \"complex64\";\n    UpcastComplex64AndMap[\"complex64\"] = \"complex64\";\n})(UpcastComplex64AndMap || (UpcastComplex64AndMap = {}));\nconst upcastTypeMap = {\n    'float32': UpcastFloat32AndMap,\n    'int32': UpcastInt32AndMap,\n    'bool': UpcastBoolAndMap,\n    'complex64': UpcastComplex64AndMap\n};\nexport function upcastType(typeA, typeB) {\n    if (typeA === 'string' || typeB === 'string') {\n        if (typeA === 'string' && typeB === 'string') {\n            return 'string';\n        }\n        throw new Error(`Can not upcast ${typeA} with ${typeB}`);\n    }\n    return upcastTypeMap[typeA][typeB];\n}\n/** Returns the output type after summation. */\nexport function sumOutType(type) {\n    return upcastType(type, 'int32');\n}\n//# sourceMappingURL=types.js.map"]},"metadata":{},"sourceType":"module"}