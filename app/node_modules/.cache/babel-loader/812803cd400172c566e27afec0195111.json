{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * TensorFlow.js Layers: Pooling Layers.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy } from '@tensorflow/tfjs-core';\nimport { imageDataFormat } from '../backend/common';\nimport * as K from '../backend/tfjs_backend';\nimport { checkDataFormat, checkPaddingMode, checkPoolMode } from '../common';\nimport { InputSpec } from '../engine/topology';\nimport { Layer } from '../engine/topology';\nimport { NotImplementedError, ValueError } from '../errors';\nimport { convOutputLength } from '../utils/conv_utils';\nimport { assertPositiveInteger } from '../utils/generic_utils';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../utils/types_utils';\nimport { preprocessConv2DInput, preprocessConv3DInput } from './convolutional';\n/**\n * 2D pooling.\n * @param x\n * @param poolSize\n * @param stridesdes strides. Defaults to [1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 2D pooling.\n */\nexport function pool2d(x, poolSize, strides, padding, dataFormat, poolMode) {\n  return tidy(() => {\n    checkDataFormat(dataFormat);\n    checkPoolMode(poolMode);\n    checkPaddingMode(padding);\n    if (strides == null) {\n      strides = [1, 1];\n    }\n    if (padding == null) {\n      padding = 'valid';\n    }\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n    if (poolMode == null) {\n      poolMode = 'max';\n    }\n    // TODO(cais): Remove the preprocessing step once deeplearn.js supports\n    // dataFormat as an input argument.\n    x = preprocessConv2DInput(x, dataFormat); // x is NHWC after preprocessing.\n    let y;\n    const paddingString = padding === 'same' ? 'same' : 'valid';\n    if (poolMode === 'max') {\n      // TODO(cais): Rank check?\n      y = tfc.maxPool(x, poolSize, strides, paddingString);\n    } else {\n      // 'avg'\n      // TODO(cais): Check the dtype and rank of x and give clear error message\n      //   if those are incorrect.\n      y = tfc.avgPool(\n      // TODO(cais): Rank check?\n      x, poolSize, strides, paddingString);\n    }\n    if (dataFormat === 'channelsFirst') {\n      y = tfc.transpose(y, [0, 3, 1, 2]); // NHWC -> NCHW.\n    }\n\n    return y;\n  });\n}\n/**\n * 3D pooling.\n * @param x\n * @param poolSize. Default to [1, 1, 1].\n * @param strides strides. Defaults to [1, 1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 3D pooling.\n */\nexport function pool3d(x, poolSize, strides, padding, dataFormat, poolMode) {\n  return tidy(() => {\n    checkDataFormat(dataFormat);\n    checkPoolMode(poolMode);\n    checkPaddingMode(padding);\n    if (strides == null) {\n      strides = [1, 1, 1];\n    }\n    if (padding == null) {\n      padding = 'valid';\n    }\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n    if (poolMode == null) {\n      poolMode = 'max';\n    }\n    // x is NDHWC after preprocessing.\n    x = preprocessConv3DInput(x, dataFormat);\n    let y;\n    const paddingString = padding === 'same' ? 'same' : 'valid';\n    if (poolMode === 'max') {\n      y = tfc.maxPool3d(x, poolSize, strides, paddingString);\n    } else {\n      // 'avg'\n      y = tfc.avgPool3d(x, poolSize, strides, paddingString);\n    }\n    if (dataFormat === 'channelsFirst') {\n      y = tfc.transpose(y, [0, 4, 1, 2, 3]); // NDHWC -> NCDHW.\n    }\n\n    return y;\n  });\n}\n/**\n * Abstract class for different pooling 1D layers.\n */\nexport class Pooling1D extends Layer {\n  /**\n   *\n   * @param args Parameters for the Pooling layer.\n   *\n   * config.poolSize defaults to 2.\n   */\n  constructor(args) {\n    if (args.poolSize == null) {\n      args.poolSize = 2;\n    }\n    super(args);\n    if (typeof args.poolSize === 'number') {\n      this.poolSize = [args.poolSize];\n    } else if (Array.isArray(args.poolSize) && args.poolSize.length === 1 && typeof args.poolSize[0] === 'number') {\n      this.poolSize = args.poolSize;\n    } else {\n      throw new ValueError(`poolSize for 1D convolutional layer must be a number or an ` + `Array of a single number, but received ` + `${JSON.stringify(args.poolSize)}`);\n    }\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else {\n      if (typeof args.strides === 'number') {\n        this.strides = [args.strides];\n      } else if (Array.isArray(args.strides) && args.strides.length === 1 && typeof args.strides[0] === 'number') {\n        this.strides = args.strides;\n      } else {\n        throw new ValueError(`strides for 1D convolutional layer must be a number or an ` + `Array of a single number, but received ` + `${JSON.stringify(args.strides)}`);\n      }\n    }\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    checkPaddingMode(this.padding);\n    this.inputSpec = [new InputSpec({\n      ndim: 3\n    })];\n  }\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    const length = convOutputLength(inputShape[1], this.poolSize[0], this.padding, this.strides[0]);\n    return [inputShape[0], length, inputShape[2]];\n  }\n  call(inputs, kwargs) {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      // Add dummy last dimension.\n      inputs = K.expandDims(getExactlyOneTensor(inputs), 2);\n      const output = this.poolingFunction(getExactlyOneTensor(inputs), [this.poolSize[0], 1], [this.strides[0], 1], this.padding, 'channelsLast');\n      // Remove dummy last dimension.\n      return tfc.squeeze(output, [2]);\n    });\n  }\n  getConfig() {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\nexport class MaxPooling1D extends Pooling1D {\n  constructor(args) {\n    super(args);\n  }\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n}\n/** @nocollapse */\nMaxPooling1D.className = 'MaxPooling1D';\nserialization.registerClass(MaxPooling1D);\nexport class AveragePooling1D extends Pooling1D {\n  constructor(args) {\n    super(args);\n  }\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n}\n/** @nocollapse */\nAveragePooling1D.className = 'AveragePooling1D';\nserialization.registerClass(AveragePooling1D);\n/**\n * Abstract class for different pooling 2D layers.\n */\nexport class Pooling2D extends Layer {\n  constructor(args) {\n    if (args.poolSize == null) {\n      args.poolSize = [2, 2];\n    }\n    super(args);\n    this.poolSize = Array.isArray(args.poolSize) ? args.poolSize : [args.poolSize, args.poolSize];\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else if (Array.isArray(args.strides)) {\n      if (args.strides.length !== 2) {\n        throw new ValueError(`If the strides property of a 2D pooling layer is an Array, ` + `it is expected to have a length of 2, but received length ` + `${args.strides.length}.`);\n      }\n      this.strides = args.strides;\n    } else {\n      // `config.strides` is a number.\n      this.strides = [args.strides, args.strides];\n    }\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    this.dataFormat = args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    checkPaddingMode(this.padding);\n    this.inputSpec = [new InputSpec({\n      ndim: 4\n    })];\n  }\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    let rows = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n    let cols = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n    rows = convOutputLength(rows, this.poolSize[0], this.padding, this.strides[0]);\n    cols = convOutputLength(cols, this.poolSize[1], this.padding, this.strides[1]);\n    if (this.dataFormat === 'channelsFirst') {\n      return [inputShape[0], inputShape[1], rows, cols];\n    } else {\n      return [inputShape[0], rows, cols, inputShape[3]];\n    }\n  }\n  call(inputs, kwargs) {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);\n    });\n  }\n  getConfig() {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides,\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\nexport class MaxPooling2D extends Pooling2D {\n  constructor(args) {\n    super(args);\n  }\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n}\n/** @nocollapse */\nMaxPooling2D.className = 'MaxPooling2D';\nserialization.registerClass(MaxPooling2D);\nexport class AveragePooling2D extends Pooling2D {\n  constructor(args) {\n    super(args);\n  }\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n}\n/** @nocollapse */\nAveragePooling2D.className = 'AveragePooling2D';\nserialization.registerClass(AveragePooling2D);\n/**\n * Abstract class for different pooling 3D layers.\n */\nexport class Pooling3D extends Layer {\n  constructor(args) {\n    if (args.poolSize == null) {\n      args.poolSize = [2, 2, 2];\n    }\n    super(args);\n    this.poolSize = Array.isArray(args.poolSize) ? args.poolSize : [args.poolSize, args.poolSize, args.poolSize];\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else if (Array.isArray(args.strides)) {\n      if (args.strides.length !== 3) {\n        throw new ValueError(`If the strides property of a 3D pooling layer is an Array, ` + `it is expected to have a length of 3, but received length ` + `${args.strides.length}.`);\n      }\n      this.strides = args.strides;\n    } else {\n      // `config.strides` is a number.\n      this.strides = [args.strides, args.strides, args.strides];\n    }\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    this.dataFormat = args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    checkPaddingMode(this.padding);\n    this.inputSpec = [new InputSpec({\n      ndim: 5\n    })];\n  }\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    let depths = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n    let rows = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n    let cols = this.dataFormat === 'channelsFirst' ? inputShape[4] : inputShape[3];\n    depths = convOutputLength(depths, this.poolSize[0], this.padding, this.strides[0]);\n    rows = convOutputLength(rows, this.poolSize[1], this.padding, this.strides[1]);\n    cols = convOutputLength(cols, this.poolSize[2], this.padding, this.strides[2]);\n    if (this.dataFormat === 'channelsFirst') {\n      return [inputShape[0], inputShape[1], depths, rows, cols];\n    } else {\n      return [inputShape[0], depths, rows, cols, inputShape[4]];\n    }\n  }\n  call(inputs, kwargs) {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);\n    });\n  }\n  getConfig() {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides,\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\nexport class MaxPooling3D extends Pooling3D {\n  constructor(args) {\n    super(args);\n  }\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool3d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n}\n/** @nocollapse */\nMaxPooling3D.className = 'MaxPooling3D';\nserialization.registerClass(MaxPooling3D);\nexport class AveragePooling3D extends Pooling3D {\n  constructor(args) {\n    super(args);\n  }\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool3d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n}\n/** @nocollapse */\nAveragePooling3D.className = 'AveragePooling3D';\nserialization.registerClass(AveragePooling3D);\n/**\n * Abstract class for different global pooling 1D layers.\n */\nexport class GlobalPooling1D extends Layer {\n  constructor(args) {\n    super(args);\n    this.inputSpec = [new InputSpec({\n      ndim: 3\n    })];\n  }\n  computeOutputShape(inputShape) {\n    return [inputShape[0], inputShape[2]];\n  }\n  call(inputs, kwargs) {\n    throw new NotImplementedError();\n  }\n}\nexport class GlobalAveragePooling1D extends GlobalPooling1D {\n  constructor(args) {\n    super(args || {});\n  }\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      return tfc.mean(input, 1);\n    });\n  }\n}\n/** @nocollapse */\nGlobalAveragePooling1D.className = 'GlobalAveragePooling1D';\nserialization.registerClass(GlobalAveragePooling1D);\nexport class GlobalMaxPooling1D extends GlobalPooling1D {\n  constructor(args) {\n    super(args || {});\n  }\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      return tfc.max(input, 1);\n    });\n  }\n}\n/** @nocollapse */\nGlobalMaxPooling1D.className = 'GlobalMaxPooling1D';\nserialization.registerClass(GlobalMaxPooling1D);\n/**\n * Abstract class for different global pooling 2D layers.\n */\nexport class GlobalPooling2D extends Layer {\n  constructor(args) {\n    super(args);\n    this.dataFormat = args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    this.inputSpec = [new InputSpec({\n      ndim: 4\n    })];\n  }\n  computeOutputShape(inputShape) {\n    inputShape = inputShape;\n    if (this.dataFormat === 'channelsLast') {\n      return [inputShape[0], inputShape[3]];\n    } else {\n      return [inputShape[0], inputShape[1]];\n    }\n  }\n  call(inputs, kwargs) {\n    throw new NotImplementedError();\n  }\n  getConfig() {\n    const config = {\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\nexport class GlobalAveragePooling2D extends GlobalPooling2D {\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      if (this.dataFormat === 'channelsLast') {\n        return tfc.mean(input, [1, 2]);\n      } else {\n        return tfc.mean(input, [2, 3]);\n      }\n    });\n  }\n}\n/** @nocollapse */\nGlobalAveragePooling2D.className = 'GlobalAveragePooling2D';\nserialization.registerClass(GlobalAveragePooling2D);\nexport class GlobalMaxPooling2D extends GlobalPooling2D {\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      if (this.dataFormat === 'channelsLast') {\n        return tfc.max(input, [1, 2]);\n      } else {\n        return tfc.max(input, [2, 3]);\n      }\n    });\n  }\n}\n/** @nocollapse */\nGlobalMaxPooling2D.className = 'GlobalMaxPooling2D';\nserialization.registerClass(GlobalMaxPooling2D);","map":{"version":3,"sources":["../../src/layers/pooling.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * TensorFlow.js Layers: Pooling Layers.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy } from '@tensorflow/tfjs-core';\nimport { imageDataFormat } from '../backend/common';\nimport * as K from '../backend/tfjs_backend';\nimport { checkDataFormat, checkPaddingMode, checkPoolMode } from '../common';\nimport { InputSpec } from '../engine/topology';\nimport { Layer } from '../engine/topology';\nimport { NotImplementedError, ValueError } from '../errors';\nimport { convOutputLength } from '../utils/conv_utils';\nimport { assertPositiveInteger } from '../utils/generic_utils';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../utils/types_utils';\nimport { preprocessConv2DInput, preprocessConv3DInput } from './convolutional';\n/**\n * 2D pooling.\n * @param x\n * @param poolSize\n * @param stridesdes strides. Defaults to [1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 2D pooling.\n */\nexport function pool2d(x, poolSize, strides, padding, dataFormat, poolMode) {\n    return tidy(() => {\n        checkDataFormat(dataFormat);\n        checkPoolMode(poolMode);\n        checkPaddingMode(padding);\n        if (strides == null) {\n            strides = [1, 1];\n        }\n        if (padding == null) {\n            padding = 'valid';\n        }\n        if (dataFormat == null) {\n            dataFormat = imageDataFormat();\n        }\n        if (poolMode == null) {\n            poolMode = 'max';\n        }\n        // TODO(cais): Remove the preprocessing step once deeplearn.js supports\n        // dataFormat as an input argument.\n        x = preprocessConv2DInput(x, dataFormat); // x is NHWC after preprocessing.\n        let y;\n        const paddingString = (padding === 'same') ? 'same' : 'valid';\n        if (poolMode === 'max') {\n            // TODO(cais): Rank check?\n            y = tfc.maxPool(x, poolSize, strides, paddingString);\n        }\n        else { // 'avg'\n            // TODO(cais): Check the dtype and rank of x and give clear error message\n            //   if those are incorrect.\n            y = tfc.avgPool(\n            // TODO(cais): Rank check?\n            x, poolSize, strides, paddingString);\n        }\n        if (dataFormat === 'channelsFirst') {\n            y = tfc.transpose(y, [0, 3, 1, 2]); // NHWC -> NCHW.\n        }\n        return y;\n    });\n}\n/**\n * 3D pooling.\n * @param x\n * @param poolSize. Default to [1, 1, 1].\n * @param strides strides. Defaults to [1, 1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 3D pooling.\n */\nexport function pool3d(x, poolSize, strides, padding, dataFormat, poolMode) {\n    return tidy(() => {\n        checkDataFormat(dataFormat);\n        checkPoolMode(poolMode);\n        checkPaddingMode(padding);\n        if (strides == null) {\n            strides = [1, 1, 1];\n        }\n        if (padding == null) {\n            padding = 'valid';\n        }\n        if (dataFormat == null) {\n            dataFormat = imageDataFormat();\n        }\n        if (poolMode == null) {\n            poolMode = 'max';\n        }\n        // x is NDHWC after preprocessing.\n        x = preprocessConv3DInput(x, dataFormat);\n        let y;\n        const paddingString = (padding === 'same') ? 'same' : 'valid';\n        if (poolMode === 'max') {\n            y = tfc.maxPool3d(x, poolSize, strides, paddingString);\n        }\n        else { // 'avg'\n            y = tfc.avgPool3d(x, poolSize, strides, paddingString);\n        }\n        if (dataFormat === 'channelsFirst') {\n            y = tfc.transpose(y, [0, 4, 1, 2, 3]); // NDHWC -> NCDHW.\n        }\n        return y;\n    });\n}\n/**\n * Abstract class for different pooling 1D layers.\n */\nexport class Pooling1D extends Layer {\n    /**\n     *\n     * @param args Parameters for the Pooling layer.\n     *\n     * config.poolSize defaults to 2.\n     */\n    constructor(args) {\n        if (args.poolSize == null) {\n            args.poolSize = 2;\n        }\n        super(args);\n        if (typeof args.poolSize === 'number') {\n            this.poolSize = [args.poolSize];\n        }\n        else if (Array.isArray(args.poolSize) &&\n            args.poolSize.length === 1 &&\n            typeof args.poolSize[0] === 'number') {\n            this.poolSize = args.poolSize;\n        }\n        else {\n            throw new ValueError(`poolSize for 1D convolutional layer must be a number or an ` +\n                `Array of a single number, but received ` +\n                `${JSON.stringify(args.poolSize)}`);\n        }\n        assertPositiveInteger(this.poolSize, 'poolSize');\n        if (args.strides == null) {\n            this.strides = this.poolSize;\n        }\n        else {\n            if (typeof args.strides === 'number') {\n                this.strides = [args.strides];\n            }\n            else if (Array.isArray(args.strides) &&\n                args.strides.length === 1 &&\n                typeof args.strides[0] === 'number') {\n                this.strides = args.strides;\n            }\n            else {\n                throw new ValueError(`strides for 1D convolutional layer must be a number or an ` +\n                    `Array of a single number, but received ` +\n                    `${JSON.stringify(args.strides)}`);\n            }\n        }\n        assertPositiveInteger(this.strides, 'strides');\n        this.padding = args.padding == null ? 'valid' : args.padding;\n        checkPaddingMode(this.padding);\n        this.inputSpec = [new InputSpec({ ndim: 3 })];\n    }\n    computeOutputShape(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        const length = convOutputLength(inputShape[1], this.poolSize[0], this.padding, this.strides[0]);\n        return [inputShape[0], length, inputShape[2]];\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            this.invokeCallHook(inputs, kwargs);\n            // Add dummy last dimension.\n            inputs = K.expandDims(getExactlyOneTensor(inputs), 2);\n            const output = this.poolingFunction(getExactlyOneTensor(inputs), [this.poolSize[0], 1], [this.strides[0], 1], this.padding, 'channelsLast');\n            // Remove dummy last dimension.\n            return tfc.squeeze(output, [2]);\n        });\n    }\n    getConfig() {\n        const config = {\n            poolSize: this.poolSize,\n            padding: this.padding,\n            strides: this.strides,\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\nexport class MaxPooling1D extends Pooling1D {\n    constructor(args) {\n        super(args);\n    }\n    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n        checkDataFormat(dataFormat);\n        checkPaddingMode(padding);\n        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n    }\n}\n/** @nocollapse */\nMaxPooling1D.className = 'MaxPooling1D';\nserialization.registerClass(MaxPooling1D);\nexport class AveragePooling1D extends Pooling1D {\n    constructor(args) {\n        super(args);\n    }\n    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n        checkDataFormat(dataFormat);\n        checkPaddingMode(padding);\n        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n    }\n}\n/** @nocollapse */\nAveragePooling1D.className = 'AveragePooling1D';\nserialization.registerClass(AveragePooling1D);\n/**\n * Abstract class for different pooling 2D layers.\n */\nexport class Pooling2D extends Layer {\n    constructor(args) {\n        if (args.poolSize == null) {\n            args.poolSize = [2, 2];\n        }\n        super(args);\n        this.poolSize = Array.isArray(args.poolSize) ?\n            args.poolSize :\n            [args.poolSize, args.poolSize];\n        if (args.strides == null) {\n            this.strides = this.poolSize;\n        }\n        else if (Array.isArray(args.strides)) {\n            if (args.strides.length !== 2) {\n                throw new ValueError(`If the strides property of a 2D pooling layer is an Array, ` +\n                    `it is expected to have a length of 2, but received length ` +\n                    `${args.strides.length}.`);\n            }\n            this.strides = args.strides;\n        }\n        else {\n            // `config.strides` is a number.\n            this.strides = [args.strides, args.strides];\n        }\n        assertPositiveInteger(this.poolSize, 'poolSize');\n        assertPositiveInteger(this.strides, 'strides');\n        this.padding = args.padding == null ? 'valid' : args.padding;\n        this.dataFormat =\n            args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n        checkDataFormat(this.dataFormat);\n        checkPaddingMode(this.padding);\n        this.inputSpec = [new InputSpec({ ndim: 4 })];\n    }\n    computeOutputShape(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        let rows = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n        let cols = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n        rows =\n            convOutputLength(rows, this.poolSize[0], this.padding, this.strides[0]);\n        cols =\n            convOutputLength(cols, this.poolSize[1], this.padding, this.strides[1]);\n        if (this.dataFormat === 'channelsFirst') {\n            return [inputShape[0], inputShape[1], rows, cols];\n        }\n        else {\n            return [inputShape[0], rows, cols, inputShape[3]];\n        }\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            this.invokeCallHook(inputs, kwargs);\n            return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);\n        });\n    }\n    getConfig() {\n        const config = {\n            poolSize: this.poolSize,\n            padding: this.padding,\n            strides: this.strides,\n            dataFormat: this.dataFormat\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\nexport class MaxPooling2D extends Pooling2D {\n    constructor(args) {\n        super(args);\n    }\n    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n        checkDataFormat(dataFormat);\n        checkPaddingMode(padding);\n        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n    }\n}\n/** @nocollapse */\nMaxPooling2D.className = 'MaxPooling2D';\nserialization.registerClass(MaxPooling2D);\nexport class AveragePooling2D extends Pooling2D {\n    constructor(args) {\n        super(args);\n    }\n    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n        checkDataFormat(dataFormat);\n        checkPaddingMode(padding);\n        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n    }\n}\n/** @nocollapse */\nAveragePooling2D.className = 'AveragePooling2D';\nserialization.registerClass(AveragePooling2D);\n/**\n * Abstract class for different pooling 3D layers.\n */\nexport class Pooling3D extends Layer {\n    constructor(args) {\n        if (args.poolSize == null) {\n            args.poolSize = [2, 2, 2];\n        }\n        super(args);\n        this.poolSize = Array.isArray(args.poolSize) ?\n            args.poolSize :\n            [args.poolSize, args.poolSize, args.poolSize];\n        if (args.strides == null) {\n            this.strides = this.poolSize;\n        }\n        else if (Array.isArray(args.strides)) {\n            if (args.strides.length !== 3) {\n                throw new ValueError(`If the strides property of a 3D pooling layer is an Array, ` +\n                    `it is expected to have a length of 3, but received length ` +\n                    `${args.strides.length}.`);\n            }\n            this.strides = args.strides;\n        }\n        else {\n            // `config.strides` is a number.\n            this.strides = [args.strides, args.strides, args.strides];\n        }\n        assertPositiveInteger(this.poolSize, 'poolSize');\n        assertPositiveInteger(this.strides, 'strides');\n        this.padding = args.padding == null ? 'valid' : args.padding;\n        this.dataFormat =\n            args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n        checkDataFormat(this.dataFormat);\n        checkPaddingMode(this.padding);\n        this.inputSpec = [new InputSpec({ ndim: 5 })];\n    }\n    computeOutputShape(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        let depths = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n        let rows = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n        let cols = this.dataFormat === 'channelsFirst' ? inputShape[4] : inputShape[3];\n        depths = convOutputLength(depths, this.poolSize[0], this.padding, this.strides[0]);\n        rows =\n            convOutputLength(rows, this.poolSize[1], this.padding, this.strides[1]);\n        cols =\n            convOutputLength(cols, this.poolSize[2], this.padding, this.strides[2]);\n        if (this.dataFormat === 'channelsFirst') {\n            return [inputShape[0], inputShape[1], depths, rows, cols];\n        }\n        else {\n            return [inputShape[0], depths, rows, cols, inputShape[4]];\n        }\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            this.invokeCallHook(inputs, kwargs);\n            return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);\n        });\n    }\n    getConfig() {\n        const config = {\n            poolSize: this.poolSize,\n            padding: this.padding,\n            strides: this.strides,\n            dataFormat: this.dataFormat\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\nexport class MaxPooling3D extends Pooling3D {\n    constructor(args) {\n        super(args);\n    }\n    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n        checkDataFormat(dataFormat);\n        checkPaddingMode(padding);\n        return pool3d(inputs, poolSize, strides, padding, dataFormat, 'max');\n    }\n}\n/** @nocollapse */\nMaxPooling3D.className = 'MaxPooling3D';\nserialization.registerClass(MaxPooling3D);\nexport class AveragePooling3D extends Pooling3D {\n    constructor(args) {\n        super(args);\n    }\n    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n        checkDataFormat(dataFormat);\n        checkPaddingMode(padding);\n        return pool3d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n    }\n}\n/** @nocollapse */\nAveragePooling3D.className = 'AveragePooling3D';\nserialization.registerClass(AveragePooling3D);\n/**\n * Abstract class for different global pooling 1D layers.\n */\nexport class GlobalPooling1D extends Layer {\n    constructor(args) {\n        super(args);\n        this.inputSpec = [new InputSpec({ ndim: 3 })];\n    }\n    computeOutputShape(inputShape) {\n        return [inputShape[0], inputShape[2]];\n    }\n    call(inputs, kwargs) {\n        throw new NotImplementedError();\n    }\n}\nexport class GlobalAveragePooling1D extends GlobalPooling1D {\n    constructor(args) {\n        super(args || {});\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            const input = getExactlyOneTensor(inputs);\n            return tfc.mean(input, 1);\n        });\n    }\n}\n/** @nocollapse */\nGlobalAveragePooling1D.className = 'GlobalAveragePooling1D';\nserialization.registerClass(GlobalAveragePooling1D);\nexport class GlobalMaxPooling1D extends GlobalPooling1D {\n    constructor(args) {\n        super(args || {});\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            const input = getExactlyOneTensor(inputs);\n            return tfc.max(input, 1);\n        });\n    }\n}\n/** @nocollapse */\nGlobalMaxPooling1D.className = 'GlobalMaxPooling1D';\nserialization.registerClass(GlobalMaxPooling1D);\n/**\n * Abstract class for different global pooling 2D layers.\n */\nexport class GlobalPooling2D extends Layer {\n    constructor(args) {\n        super(args);\n        this.dataFormat =\n            args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n        checkDataFormat(this.dataFormat);\n        this.inputSpec = [new InputSpec({ ndim: 4 })];\n    }\n    computeOutputShape(inputShape) {\n        inputShape = inputShape;\n        if (this.dataFormat === 'channelsLast') {\n            return [inputShape[0], inputShape[3]];\n        }\n        else {\n            return [inputShape[0], inputShape[1]];\n        }\n    }\n    call(inputs, kwargs) {\n        throw new NotImplementedError();\n    }\n    getConfig() {\n        const config = { dataFormat: this.dataFormat };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\nexport class GlobalAveragePooling2D extends GlobalPooling2D {\n    call(inputs, kwargs) {\n        return tidy(() => {\n            const input = getExactlyOneTensor(inputs);\n            if (this.dataFormat === 'channelsLast') {\n                return tfc.mean(input, [1, 2]);\n            }\n            else {\n                return tfc.mean(input, [2, 3]);\n            }\n        });\n    }\n}\n/** @nocollapse */\nGlobalAveragePooling2D.className = 'GlobalAveragePooling2D';\nserialization.registerClass(GlobalAveragePooling2D);\nexport class GlobalMaxPooling2D extends GlobalPooling2D {\n    call(inputs, kwargs) {\n        return tidy(() => {\n            const input = getExactlyOneTensor(inputs);\n            if (this.dataFormat === 'channelsLast') {\n                return tfc.max(input, [1, 2]);\n            }\n            else {\n                return tfc.max(input, [2, 3]);\n            }\n        });\n    }\n}\n/** @nocollapse */\nGlobalMaxPooling2D.className = 'GlobalMaxPooling2D';\nserialization.registerClass(GlobalMaxPooling2D);\n//# sourceMappingURL=pooling.js.map"]},"metadata":{},"sourceType":"module"}