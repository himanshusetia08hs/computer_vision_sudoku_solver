{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nimport { isNode } from '../../utils/is';\nimport { keywords } from '../keywords';\nimport { deepStrictEqual, hasOwnProperty } from '../../utils/object';\nimport { factory } from '../../utils/factory';\nvar name = 'Node';\nvar dependencies = ['mathWithTransform'];\nexport var createNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var mathWithTransform = _ref.mathWithTransform;\n\n  /**\n   * Node\n   */\n  function Node() {\n    if (!(this instanceof Node)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n  }\n  /**\n   * Evaluate the node\n   * @param {Object} [scope]  Scope to read/write variables\n   * @return {*}              Returns the result\n   */\n\n  Node.prototype.evaluate = function (scope) {\n    return this.compile().evaluate(scope);\n  };\n  Node.prototype.type = 'Node';\n  Node.prototype.isNode = true;\n  Node.prototype.comment = '';\n  /**\n   * Compile the node into an optimized, evauatable JavaScript function\n   * @return {{evaluate: function([Object])}} object\n   *                Returns an object with a function 'evaluate',\n   *                which can be invoked as expr.evaluate([scope: Object]),\n   *                where scope is an optional object with\n   *                variables.\n   */\n\n  Node.prototype.compile = function () {\n    var expr = this._compile(mathWithTransform, {});\n    var args = {};\n    var context = null;\n    function evaluate(scope) {\n      var s = scope || {};\n      _validateScope(s);\n      return expr(s, args, context);\n    }\n    return {\n      evaluate: evaluate\n    };\n  };\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  Node.prototype._compile = function (math, argNames) {\n    throw new Error('Method _compile should be implemented by type ' + this.type);\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n  Node.prototype.forEach = function (callback) {\n    // must be implemented by each of the Node implementations\n    throw new Error('Cannot run forEach on a Node interface');\n  };\n  /**\n   * Create a new Node having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {OperatorNode} Returns a transformed copy of the node\n   */\n\n  Node.prototype.map = function (callback) {\n    // must be implemented by each of the Node implementations\n    throw new Error('Cannot run map on a Node interface');\n  };\n  /**\n   * Validate whether an object is a Node, for use with map\n   * @param {Node} node\n   * @returns {Node} Returns the input if it's a node, else throws an Error\n   * @protected\n   */\n\n  Node.prototype._ifNode = function (node) {\n    if (!isNode(node)) {\n      throw new TypeError('Callback function must return a Node');\n    }\n    return node;\n  };\n  /**\n   * Recursively traverse all nodes in a node tree. Executes given callback for\n   * this node and each of its child nodes.\n   * @param {function(node: Node, path: string, parent: Node)} callback\n   *          A callback called for every node in the node tree.\n   */\n\n  Node.prototype.traverse = function (callback) {\n    // execute callback for itself\n    // eslint-disable-next-line\n    callback(this, null, null); // recursively traverse over all childs of a node\n\n    function _traverse(node, callback) {\n      node.forEach(function (child, path, parent) {\n        callback(child, path, parent);\n        _traverse(child, callback);\n      });\n    }\n    _traverse(this, callback);\n  };\n  /**\n   * Recursively transform a node tree via a transform function.\n   *\n   * For example, to replace all nodes of type SymbolNode having name 'x' with a\n   * ConstantNode with value 2:\n   *\n   *     const res = Node.transform(function (node, path, parent) {\n   *       if (node && node.isSymbolNode) && (node.name === 'x')) {\n   *         return new ConstantNode(2)\n   *       }\n   *       else {\n   *         return node\n   *       }\n   *     })\n   *\n   * @param {function(node: Node, path: string, parent: Node) : Node} callback\n   *          A mapping function accepting a node, and returning\n   *          a replacement for the node or the original node.\n   *          Signature: callback(node: Node, index: string, parent: Node) : Node\n   * @return {Node} Returns the original node or its replacement\n   */\n\n  Node.prototype.transform = function (callback) {\n    function _transform(child, path, parent) {\n      var replacement = callback(child, path, parent);\n      if (replacement !== child) {\n        // stop iterating when the node is replaced\n        return replacement;\n      }\n      return child.map(_transform);\n    }\n    return _transform(this, null, null);\n  };\n  /**\n   * Find any node in the node tree matching given filter function. For example, to\n   * find all nodes of type SymbolNode having name 'x':\n   *\n   *     const results = Node.filter(function (node) {\n   *       return (node && node.isSymbolNode) && (node.name === 'x')\n   *     })\n   *\n   * @param {function(node: Node, path: string, parent: Node) : Node} callback\n   *            A test function returning true when a node matches, and false\n   *            otherwise. Function signature:\n   *            callback(node: Node, index: string, parent: Node) : boolean\n   * @return {Node[]} nodes       An array with nodes matching given filter criteria\n   */\n\n  Node.prototype.filter = function (callback) {\n    var nodes = [];\n    this.traverse(function (node, path, parent) {\n      if (callback(node, path, parent)) {\n        nodes.push(node);\n      }\n    });\n    return nodes;\n  };\n  /**\n   * Create a shallow clone of this node\n   * @return {Node}\n   */\n\n  Node.prototype.clone = function () {\n    // must be implemented by each of the Node implementations\n    throw new Error('Cannot clone a Node interface');\n  };\n  /**\n   * Create a deep clone of this node\n   * @return {Node}\n   */\n\n  Node.prototype.cloneDeep = function () {\n    return this.map(function (node) {\n      return node.cloneDeep();\n    });\n  };\n  /**\n   * Deep compare this node with another node.\n   * @param {Node} other\n   * @return {boolean} Returns true when both nodes are of the same type and\n   *                   contain the same values (as do their childs)\n   */\n\n  Node.prototype.equals = function (other) {\n    return other ? deepStrictEqual(this, other) : false;\n  };\n  /**\n   * Get string representation. (wrapper function)\n   *\n   * This function can get an object of the following form:\n   * {\n   *    handler: //This can be a callback function of the form\n   *             // \"function callback(node, options)\"or\n   *             // a map that maps function names (used in FunctionNodes)\n   *             // to callbacks\n   *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n   * }\n   *\n   * @param {Object} [options]\n   * @return {string}\n   */\n\n  Node.prototype.toString = function (options) {\n    var customString;\n    if (options && _typeof(options) === 'object') {\n      switch (_typeof(options.handler)) {\n        case 'object':\n        case 'undefined':\n          break;\n        case 'function':\n          customString = options.handler(this, options);\n          break;\n        default:\n          throw new TypeError('Object or function expected as callback');\n      }\n    }\n    if (typeof customString !== 'undefined') {\n      return customString;\n    }\n    return this._toString(options);\n  };\n  /**\n   * Get a JSON representation of the node\n   * Both .toJSON() and the static .fromJSON(json) should be implemented by all\n   * implementations of Node\n   * @returns {Object}\n   */\n\n  Node.prototype.toJSON = function () {\n    throw new Error('Cannot serialize object: toJSON not implemented by ' + this.type);\n  };\n  /**\n   * Get HTML representation. (wrapper function)\n   *\n   * This function can get an object of the following form:\n   * {\n   *    handler: //This can be a callback function of the form\n   *             // \"function callback(node, options)\" or\n   *             // a map that maps function names (used in FunctionNodes)\n   *             // to callbacks\n   *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n   * }\n   *\n   * @param {Object} [options]\n   * @return {string}\n   */\n\n  Node.prototype.toHTML = function (options) {\n    var customString;\n    if (options && _typeof(options) === 'object') {\n      switch (_typeof(options.handler)) {\n        case 'object':\n        case 'undefined':\n          break;\n        case 'function':\n          customString = options.handler(this, options);\n          break;\n        default:\n          throw new TypeError('Object or function expected as callback');\n      }\n    }\n    if (typeof customString !== 'undefined') {\n      return customString;\n    }\n    return this.toHTML(options);\n  };\n  /**\n   * Internal function to generate the string output.\n   * This has to be implemented by every Node\n   *\n   * @throws {Error}\n   */\n\n  Node.prototype._toString = function () {\n    // must be implemented by each of the Node implementations\n    throw new Error('_toString not implemented for ' + this.type);\n  };\n  /**\n   * Get LaTeX representation. (wrapper function)\n   *\n   * This function can get an object of the following form:\n   * {\n   *    handler: //This can be a callback function of the form\n   *             // \"function callback(node, options)\"or\n   *             // a map that maps function names (used in FunctionNodes)\n   *             // to callbacks\n   *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n   * }\n   *\n   * @param {Object} [options]\n   * @return {string}\n   */\n\n  Node.prototype.toTex = function (options) {\n    var customTex;\n    if (options && _typeof(options) === 'object') {\n      switch (_typeof(options.handler)) {\n        case 'object':\n        case 'undefined':\n          break;\n        case 'function':\n          customTex = options.handler(this, options);\n          break;\n        default:\n          throw new TypeError('Object or function expected as callback');\n      }\n    }\n    if (typeof customTex !== 'undefined') {\n      return customTex;\n    }\n    return this._toTex(options);\n  };\n  /**\n   * Internal function to generate the LaTeX output.\n   * This has to be implemented by every Node\n   *\n   * @param {Object} [options]\n   * @throws {Error}\n   */\n\n  Node.prototype._toTex = function (options) {\n    // must be implemented by each of the Node implementations\n    throw new Error('_toTex not implemented for ' + this.type);\n  };\n  /**\n   * Get identifier.\n   * @return {string}\n   */\n\n  Node.prototype.getIdentifier = function () {\n    return this.type;\n  };\n  /**\n   * Get the content of the current Node.\n   * @return {Node} node\n   **/\n\n  Node.prototype.getContent = function () {\n    return this;\n  };\n  /**\n   * Validate the symbol names of a scope.\n   * Throws an error when the scope contains an illegal symbol.\n   * @param {Object} scope\n   */\n\n  function _validateScope(scope) {\n    for (var symbol in scope) {\n      if (hasOwnProperty(scope, symbol)) {\n        if (symbol in keywords) {\n          throw new Error('Scope contains an illegal symbol, \"' + symbol + '\" is a reserved keyword');\n        }\n      }\n    }\n  }\n  return Node;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","isNode","keywords","deepStrictEqual","hasOwnProperty","factory","name","dependencies","createNode","_ref","mathWithTransform","Node","SyntaxError","evaluate","scope","compile","type","comment","expr","_compile","args","context","s","_validateScope","math","argNames","Error","forEach","callback","map","_ifNode","node","TypeError","traverse","_traverse","child","path","parent","transform","_transform","replacement","filter","nodes","push","clone","cloneDeep","equals","other","toString","options","customString","handler","_toString","toJSON","toHTML","toTex","customTex","_toTex","getIdentifier","getContent","symbol","isClass"],"sources":["F:/extension/SEM 7/NN/Lab/my lab/P/temp/app/node_modules/mathjs/es/expression/node/Node.js"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport { isNode } from '../../utils/is';\nimport { keywords } from '../keywords';\nimport { deepStrictEqual, hasOwnProperty } from '../../utils/object';\nimport { factory } from '../../utils/factory';\nvar name = 'Node';\nvar dependencies = ['mathWithTransform'];\nexport var createNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var mathWithTransform = _ref.mathWithTransform;\n\n  /**\n   * Node\n   */\n  function Node() {\n    if (!(this instanceof Node)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n  }\n  /**\n   * Evaluate the node\n   * @param {Object} [scope]  Scope to read/write variables\n   * @return {*}              Returns the result\n   */\n\n\n  Node.prototype.evaluate = function (scope) {\n    return this.compile().evaluate(scope);\n  };\n\n  Node.prototype.type = 'Node';\n  Node.prototype.isNode = true;\n  Node.prototype.comment = '';\n  /**\n   * Compile the node into an optimized, evauatable JavaScript function\n   * @return {{evaluate: function([Object])}} object\n   *                Returns an object with a function 'evaluate',\n   *                which can be invoked as expr.evaluate([scope: Object]),\n   *                where scope is an optional object with\n   *                variables.\n   */\n\n  Node.prototype.compile = function () {\n    var expr = this._compile(mathWithTransform, {});\n\n    var args = {};\n    var context = null;\n\n    function evaluate(scope) {\n      var s = scope || {};\n\n      _validateScope(s);\n\n      return expr(s, args, context);\n    }\n\n    return {\n      evaluate: evaluate\n    };\n  };\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n\n  Node.prototype._compile = function (math, argNames) {\n    throw new Error('Method _compile should be implemented by type ' + this.type);\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  Node.prototype.forEach = function (callback) {\n    // must be implemented by each of the Node implementations\n    throw new Error('Cannot run forEach on a Node interface');\n  };\n  /**\n   * Create a new Node having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {OperatorNode} Returns a transformed copy of the node\n   */\n\n\n  Node.prototype.map = function (callback) {\n    // must be implemented by each of the Node implementations\n    throw new Error('Cannot run map on a Node interface');\n  };\n  /**\n   * Validate whether an object is a Node, for use with map\n   * @param {Node} node\n   * @returns {Node} Returns the input if it's a node, else throws an Error\n   * @protected\n   */\n\n\n  Node.prototype._ifNode = function (node) {\n    if (!isNode(node)) {\n      throw new TypeError('Callback function must return a Node');\n    }\n\n    return node;\n  };\n  /**\n   * Recursively traverse all nodes in a node tree. Executes given callback for\n   * this node and each of its child nodes.\n   * @param {function(node: Node, path: string, parent: Node)} callback\n   *          A callback called for every node in the node tree.\n   */\n\n\n  Node.prototype.traverse = function (callback) {\n    // execute callback for itself\n    // eslint-disable-next-line\n    callback(this, null, null); // recursively traverse over all childs of a node\n\n    function _traverse(node, callback) {\n      node.forEach(function (child, path, parent) {\n        callback(child, path, parent);\n\n        _traverse(child, callback);\n      });\n    }\n\n    _traverse(this, callback);\n  };\n  /**\n   * Recursively transform a node tree via a transform function.\n   *\n   * For example, to replace all nodes of type SymbolNode having name 'x' with a\n   * ConstantNode with value 2:\n   *\n   *     const res = Node.transform(function (node, path, parent) {\n   *       if (node && node.isSymbolNode) && (node.name === 'x')) {\n   *         return new ConstantNode(2)\n   *       }\n   *       else {\n   *         return node\n   *       }\n   *     })\n   *\n   * @param {function(node: Node, path: string, parent: Node) : Node} callback\n   *          A mapping function accepting a node, and returning\n   *          a replacement for the node or the original node.\n   *          Signature: callback(node: Node, index: string, parent: Node) : Node\n   * @return {Node} Returns the original node or its replacement\n   */\n\n\n  Node.prototype.transform = function (callback) {\n    function _transform(child, path, parent) {\n      var replacement = callback(child, path, parent);\n\n      if (replacement !== child) {\n        // stop iterating when the node is replaced\n        return replacement;\n      }\n\n      return child.map(_transform);\n    }\n\n    return _transform(this, null, null);\n  };\n  /**\n   * Find any node in the node tree matching given filter function. For example, to\n   * find all nodes of type SymbolNode having name 'x':\n   *\n   *     const results = Node.filter(function (node) {\n   *       return (node && node.isSymbolNode) && (node.name === 'x')\n   *     })\n   *\n   * @param {function(node: Node, path: string, parent: Node) : Node} callback\n   *            A test function returning true when a node matches, and false\n   *            otherwise. Function signature:\n   *            callback(node: Node, index: string, parent: Node) : boolean\n   * @return {Node[]} nodes       An array with nodes matching given filter criteria\n   */\n\n\n  Node.prototype.filter = function (callback) {\n    var nodes = [];\n    this.traverse(function (node, path, parent) {\n      if (callback(node, path, parent)) {\n        nodes.push(node);\n      }\n    });\n    return nodes;\n  };\n  /**\n   * Create a shallow clone of this node\n   * @return {Node}\n   */\n\n\n  Node.prototype.clone = function () {\n    // must be implemented by each of the Node implementations\n    throw new Error('Cannot clone a Node interface');\n  };\n  /**\n   * Create a deep clone of this node\n   * @return {Node}\n   */\n\n\n  Node.prototype.cloneDeep = function () {\n    return this.map(function (node) {\n      return node.cloneDeep();\n    });\n  };\n  /**\n   * Deep compare this node with another node.\n   * @param {Node} other\n   * @return {boolean} Returns true when both nodes are of the same type and\n   *                   contain the same values (as do their childs)\n   */\n\n\n  Node.prototype.equals = function (other) {\n    return other ? deepStrictEqual(this, other) : false;\n  };\n  /**\n   * Get string representation. (wrapper function)\n   *\n   * This function can get an object of the following form:\n   * {\n   *    handler: //This can be a callback function of the form\n   *             // \"function callback(node, options)\"or\n   *             // a map that maps function names (used in FunctionNodes)\n   *             // to callbacks\n   *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n   * }\n   *\n   * @param {Object} [options]\n   * @return {string}\n   */\n\n\n  Node.prototype.toString = function (options) {\n    var customString;\n\n    if (options && _typeof(options) === 'object') {\n      switch (_typeof(options.handler)) {\n        case 'object':\n        case 'undefined':\n          break;\n\n        case 'function':\n          customString = options.handler(this, options);\n          break;\n\n        default:\n          throw new TypeError('Object or function expected as callback');\n      }\n    }\n\n    if (typeof customString !== 'undefined') {\n      return customString;\n    }\n\n    return this._toString(options);\n  };\n  /**\n   * Get a JSON representation of the node\n   * Both .toJSON() and the static .fromJSON(json) should be implemented by all\n   * implementations of Node\n   * @returns {Object}\n   */\n\n\n  Node.prototype.toJSON = function () {\n    throw new Error('Cannot serialize object: toJSON not implemented by ' + this.type);\n  };\n  /**\n   * Get HTML representation. (wrapper function)\n   *\n   * This function can get an object of the following form:\n   * {\n   *    handler: //This can be a callback function of the form\n   *             // \"function callback(node, options)\" or\n   *             // a map that maps function names (used in FunctionNodes)\n   *             // to callbacks\n   *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n   * }\n   *\n   * @param {Object} [options]\n   * @return {string}\n   */\n\n\n  Node.prototype.toHTML = function (options) {\n    var customString;\n\n    if (options && _typeof(options) === 'object') {\n      switch (_typeof(options.handler)) {\n        case 'object':\n        case 'undefined':\n          break;\n\n        case 'function':\n          customString = options.handler(this, options);\n          break;\n\n        default:\n          throw new TypeError('Object or function expected as callback');\n      }\n    }\n\n    if (typeof customString !== 'undefined') {\n      return customString;\n    }\n\n    return this.toHTML(options);\n  };\n  /**\n   * Internal function to generate the string output.\n   * This has to be implemented by every Node\n   *\n   * @throws {Error}\n   */\n\n\n  Node.prototype._toString = function () {\n    // must be implemented by each of the Node implementations\n    throw new Error('_toString not implemented for ' + this.type);\n  };\n  /**\n   * Get LaTeX representation. (wrapper function)\n   *\n   * This function can get an object of the following form:\n   * {\n   *    handler: //This can be a callback function of the form\n   *             // \"function callback(node, options)\"or\n   *             // a map that maps function names (used in FunctionNodes)\n   *             // to callbacks\n   *    parenthesis: \"keep\" //the parenthesis option (This is optional)\n   * }\n   *\n   * @param {Object} [options]\n   * @return {string}\n   */\n\n\n  Node.prototype.toTex = function (options) {\n    var customTex;\n\n    if (options && _typeof(options) === 'object') {\n      switch (_typeof(options.handler)) {\n        case 'object':\n        case 'undefined':\n          break;\n\n        case 'function':\n          customTex = options.handler(this, options);\n          break;\n\n        default:\n          throw new TypeError('Object or function expected as callback');\n      }\n    }\n\n    if (typeof customTex !== 'undefined') {\n      return customTex;\n    }\n\n    return this._toTex(options);\n  };\n  /**\n   * Internal function to generate the LaTeX output.\n   * This has to be implemented by every Node\n   *\n   * @param {Object} [options]\n   * @throws {Error}\n   */\n\n\n  Node.prototype._toTex = function (options) {\n    // must be implemented by each of the Node implementations\n    throw new Error('_toTex not implemented for ' + this.type);\n  };\n  /**\n   * Get identifier.\n   * @return {string}\n   */\n\n\n  Node.prototype.getIdentifier = function () {\n    return this.type;\n  };\n  /**\n   * Get the content of the current Node.\n   * @return {Node} node\n   **/\n\n\n  Node.prototype.getContent = function () {\n    return this;\n  };\n  /**\n   * Validate the symbol names of a scope.\n   * Throws an error when the scope contains an illegal symbol.\n   * @param {Object} scope\n   */\n\n\n  function _validateScope(scope) {\n    for (var symbol in scope) {\n      if (hasOwnProperty(scope, symbol)) {\n        if (symbol in keywords) {\n          throw new Error('Scope contains an illegal symbol, \"' + symbol + '\" is a reserved keyword');\n        }\n      }\n    }\n  }\n\n  return Node;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}