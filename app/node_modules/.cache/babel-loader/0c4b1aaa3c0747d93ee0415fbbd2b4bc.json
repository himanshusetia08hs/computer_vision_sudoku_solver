{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { countParamsInWeights } from './variable_utils';\n/**\n * Print the summary of a LayersModel object.\n *\n * @param model tf.LayersModel instance.\n * @param lineLength Total length of printed lines. Set this to adapt to the\n *   display to different terminal or console sizes.\n * @param positions Relative or absolute positions of log elements in each\n *   line. Each number corresponds to right-most (i.e., ending) position of a\n *   column.\n *   If not provided, defaults to `[0.45, 0.85, 1]` for sequential-like\n *   models and `[0.33, 0.55, 0.67, 1]` for non-sequential like models.\n * @param printFn Print function to use.\n *   It will be called on each line of the summary. You can provide a custom\n *   function in order to capture the string summary. Defaults to `console.log`.\n */\nexport function printSummary(model, lineLength, positions) {\n  let printFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : console.log;\n  const sequentialLike = isModelSequentialLike(model);\n  // Header names for different log elements.\n  const toDisplay = ['Layer (type)', 'Output shape', 'Param #'];\n  if (sequentialLike) {\n    lineLength = lineLength || 65;\n    positions = positions || [0.45, 0.85, 1];\n  } else {\n    lineLength = lineLength || 98;\n    positions = positions || [0.33, 0.55, 0.67, 1];\n    // Header names for different log elements.\n  }\n\n  if (positions[positions.length - 1] <= 1) {\n    // `positions` is relative. Convert it to absolute positioning.\n    positions = positions.map(p => Math.floor(lineLength * p));\n  }\n  let relevantNodes;\n  if (!sequentialLike) {\n    toDisplay.push('Receives inputs');\n    relevantNodes = [];\n    for (const depth in model.nodesByDepth) {\n      relevantNodes.push(...model.nodesByDepth[depth]);\n    }\n  }\n  printFn('_'.repeat(lineLength));\n  printRow(toDisplay, positions, printFn);\n  printFn('='.repeat(lineLength));\n  const layers = model.layers;\n  for (let i = 0; i < layers.length; ++i) {\n    if (sequentialLike) {\n      printLayerSummary(layers[i], positions, printFn);\n    } else {\n      printLayerSummaryWithConnections(layers[i], positions, relevantNodes, printFn);\n    }\n    printFn((i === layers.length - 1 ? '=' : '_').repeat(lineLength));\n  }\n  // tslint:disable-next-line:no-any\n  model.checkTrainableWeightsConsistency();\n  const trainableCount = countTrainableParams(model);\n  const nonTrainableCount = countParamsInWeights(model.nonTrainableWeights);\n  printFn(`Total params: ${trainableCount + nonTrainableCount}`);\n  printFn(`Trainable params: ${trainableCount}`);\n  printFn(`Non-trainable params: ${nonTrainableCount}`);\n  printFn('_'.repeat(lineLength));\n}\nfunction countTrainableParams(model) {\n  let trainableCount;\n  // tslint:disable:no-any\n  if (model.collectedTrainableWeights != null) {\n    trainableCount = countParamsInWeights(model.collectedTrainableWeights);\n  } else {\n    trainableCount = countParamsInWeights(model.trainableWeights);\n  }\n  // tslint:enable:no-any\n  return trainableCount;\n}\nfunction isModelSequentialLike(model) {\n  let sequentialLike = true;\n  const nodesByDepth = [];\n  const nodes = [];\n  for (const depth in model.nodesByDepth) {\n    nodesByDepth.push(model.nodesByDepth[depth]);\n  }\n  for (const depthNodes of nodesByDepth) {\n    if (depthNodes.length > 1 || depthNodes.length === 1 && depthNodes[0].inboundLayers.length > 1) {\n      sequentialLike = false;\n      break;\n    }\n    nodes.push(...depthNodes);\n  }\n  if (sequentialLike) {\n    // Search for shared layers.\n    for (const layer of model.layers) {\n      let flag = false;\n      for (const node of layer.inboundNodes) {\n        if (nodes.indexOf(node) !== -1) {\n          if (flag) {\n            sequentialLike = false;\n            break;\n          } else {\n            flag = true;\n          }\n        }\n      }\n      if (!sequentialLike) {\n        break;\n      }\n    }\n  }\n  return sequentialLike;\n}\nfunction printRow(fields, positions) {\n  let printFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : console.log;\n  let line = '';\n  for (let i = 0; i < fields.length; ++i) {\n    if (i > 0) {\n      line = line.slice(0, line.length - 1) + ' ';\n    }\n    line += fields[i];\n    line = line.slice(0, positions[i]);\n    line += ' '.repeat(positions[i] - line.length);\n  }\n  printFn(line);\n}\n/**\n * Prints a summary for a single Layer, without connectivity information.\n *\n * @param layer: Layer instance to print.\n */\nfunction printLayerSummary(layer, positions,\n// tslint:disable-next-line:no-any\nprintFn) {\n  let outputShape;\n  try {\n    outputShape = JSON.stringify(layer.outputShape);\n  } catch (err) {\n    outputShape = 'multiple';\n  }\n  const name = layer.name;\n  const className = layer.getClassName();\n  const fields = [`${name} (${className})`, outputShape, layer.countParams().toString()];\n  printRow(fields, positions, printFn);\n}\n/**\n * Prints a summary for a single Layer, with connectivity information.\n */\nfunction printLayerSummaryWithConnections(layer, positions, relevantNodes,\n// tslint:disable-next-line:no-any\nprintFn) {\n  let outputShape;\n  try {\n    outputShape = JSON.stringify(layer.outputShape);\n  } catch (err) {\n    outputShape = 'multiple';\n  }\n  const connections = [];\n  for (const node of layer.inboundNodes) {\n    if (relevantNodes != null && relevantNodes.length > 0 && relevantNodes.indexOf(node) === -1) {\n      continue;\n    }\n    for (let i = 0; i < node.inboundLayers.length; ++i) {\n      const inboundLayer = node.inboundLayers[i].name;\n      const inboundLayerIndex = node.nodeIndices[i];\n      const inboundTensorIndex = node.tensorIndices[i];\n      connections.push(`${inboundLayer}[${inboundLayerIndex}][${inboundTensorIndex}]`);\n    }\n  }\n  const name = layer.name;\n  const className = layer.getClassName();\n  const firstConnection = connections.length === 0 ? '' : connections[0];\n  const fields = [`${name} (${className})`, outputShape, layer.countParams().toString(), firstConnection];\n  printRow(fields, positions, printFn);\n  for (let i = 1; i < connections.length; ++i) {\n    printRow(['', '', '', connections[i]], positions, printFn);\n  }\n}","map":{"version":3,"sources":["../../src/utils/layer_utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { countParamsInWeights } from './variable_utils';\n/**\n * Print the summary of a LayersModel object.\n *\n * @param model tf.LayersModel instance.\n * @param lineLength Total length of printed lines. Set this to adapt to the\n *   display to different terminal or console sizes.\n * @param positions Relative or absolute positions of log elements in each\n *   line. Each number corresponds to right-most (i.e., ending) position of a\n *   column.\n *   If not provided, defaults to `[0.45, 0.85, 1]` for sequential-like\n *   models and `[0.33, 0.55, 0.67, 1]` for non-sequential like models.\n * @param printFn Print function to use.\n *   It will be called on each line of the summary. You can provide a custom\n *   function in order to capture the string summary. Defaults to `console.log`.\n */\nexport function printSummary(model, lineLength, positions, \n// tslint:disable-next-line:no-any\nprintFn = console.log) {\n    const sequentialLike = isModelSequentialLike(model);\n    // Header names for different log elements.\n    const toDisplay = ['Layer (type)', 'Output shape', 'Param #'];\n    if (sequentialLike) {\n        lineLength = lineLength || 65;\n        positions = positions || [0.45, 0.85, 1];\n    }\n    else {\n        lineLength = lineLength || 98;\n        positions = positions || [0.33, 0.55, 0.67, 1];\n        // Header names for different log elements.\n    }\n    if (positions[positions.length - 1] <= 1) {\n        // `positions` is relative. Convert it to absolute positioning.\n        positions = positions.map(p => Math.floor(lineLength * p));\n    }\n    let relevantNodes;\n    if (!sequentialLike) {\n        toDisplay.push('Receives inputs');\n        relevantNodes = [];\n        for (const depth in model.nodesByDepth) {\n            relevantNodes.push(...model.nodesByDepth[depth]);\n        }\n    }\n    printFn('_'.repeat(lineLength));\n    printRow(toDisplay, positions, printFn);\n    printFn('='.repeat(lineLength));\n    const layers = model.layers;\n    for (let i = 0; i < layers.length; ++i) {\n        if (sequentialLike) {\n            printLayerSummary(layers[i], positions, printFn);\n        }\n        else {\n            printLayerSummaryWithConnections(layers[i], positions, relevantNodes, printFn);\n        }\n        printFn((i === layers.length - 1 ? '=' : '_').repeat(lineLength));\n    }\n    // tslint:disable-next-line:no-any\n    model.checkTrainableWeightsConsistency();\n    const trainableCount = countTrainableParams(model);\n    const nonTrainableCount = countParamsInWeights(model.nonTrainableWeights);\n    printFn(`Total params: ${trainableCount + nonTrainableCount}`);\n    printFn(`Trainable params: ${trainableCount}`);\n    printFn(`Non-trainable params: ${nonTrainableCount}`);\n    printFn('_'.repeat(lineLength));\n}\nfunction countTrainableParams(model) {\n    let trainableCount;\n    // tslint:disable:no-any\n    if (model.collectedTrainableWeights != null) {\n        trainableCount =\n            countParamsInWeights(model.collectedTrainableWeights);\n    }\n    else {\n        trainableCount = countParamsInWeights(model.trainableWeights);\n    }\n    // tslint:enable:no-any\n    return trainableCount;\n}\nfunction isModelSequentialLike(model) {\n    let sequentialLike = true;\n    const nodesByDepth = [];\n    const nodes = [];\n    for (const depth in model.nodesByDepth) {\n        nodesByDepth.push(model.nodesByDepth[depth]);\n    }\n    for (const depthNodes of nodesByDepth) {\n        if (depthNodes.length > 1 ||\n            depthNodes.length === 1 && depthNodes[0].inboundLayers.length > 1) {\n            sequentialLike = false;\n            break;\n        }\n        nodes.push(...depthNodes);\n    }\n    if (sequentialLike) {\n        // Search for shared layers.\n        for (const layer of model.layers) {\n            let flag = false;\n            for (const node of layer.inboundNodes) {\n                if (nodes.indexOf(node) !== -1) {\n                    if (flag) {\n                        sequentialLike = false;\n                        break;\n                    }\n                    else {\n                        flag = true;\n                    }\n                }\n            }\n            if (!sequentialLike) {\n                break;\n            }\n        }\n    }\n    return sequentialLike;\n}\nfunction printRow(fields, positions, \n// tslint:disable-next-line:no-any\nprintFn = console.log) {\n    let line = '';\n    for (let i = 0; i < fields.length; ++i) {\n        if (i > 0) {\n            line = line.slice(0, line.length - 1) + ' ';\n        }\n        line += fields[i];\n        line = line.slice(0, positions[i]);\n        line += ' '.repeat(positions[i] - line.length);\n    }\n    printFn(line);\n}\n/**\n * Prints a summary for a single Layer, without connectivity information.\n *\n * @param layer: Layer instance to print.\n */\nfunction printLayerSummary(layer, positions, \n// tslint:disable-next-line:no-any\nprintFn) {\n    let outputShape;\n    try {\n        outputShape = JSON.stringify(layer.outputShape);\n    }\n    catch (err) {\n        outputShape = 'multiple';\n    }\n    const name = layer.name;\n    const className = layer.getClassName();\n    const fields = [`${name} (${className})`, outputShape, layer.countParams().toString()];\n    printRow(fields, positions, printFn);\n}\n/**\n * Prints a summary for a single Layer, with connectivity information.\n */\nfunction printLayerSummaryWithConnections(layer, positions, relevantNodes, \n// tslint:disable-next-line:no-any\nprintFn) {\n    let outputShape;\n    try {\n        outputShape = JSON.stringify(layer.outputShape);\n    }\n    catch (err) {\n        outputShape = 'multiple';\n    }\n    const connections = [];\n    for (const node of layer.inboundNodes) {\n        if (relevantNodes != null && relevantNodes.length > 0 &&\n            relevantNodes.indexOf(node) === -1) {\n            continue;\n        }\n        for (let i = 0; i < node.inboundLayers.length; ++i) {\n            const inboundLayer = node.inboundLayers[i].name;\n            const inboundLayerIndex = node.nodeIndices[i];\n            const inboundTensorIndex = node.tensorIndices[i];\n            connections.push(`${inboundLayer}[${inboundLayerIndex}][${inboundTensorIndex}]`);\n        }\n    }\n    const name = layer.name;\n    const className = layer.getClassName();\n    const firstConnection = connections.length === 0 ? '' : connections[0];\n    const fields = [\n        `${name} (${className})`, outputShape, layer.countParams().toString(),\n        firstConnection\n    ];\n    printRow(fields, positions, printFn);\n    for (let i = 1; i < connections.length; ++i) {\n        printRow(['', '', '', connections[i]], positions, printFn);\n    }\n}\n//# sourceMappingURL=layer_utils.js.map"]},"metadata":{},"sourceType":"module"}