{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nexport function concatImpl(inputs, outShape, dtype, simplyConcat) {\n  const outVals = util.getArrayFromDType(dtype, util.sizeFromShape(outShape));\n  if (simplyConcat && dtype !== 'string') {\n    // Use built-in TypedArray.set() method for speed.\n    let offset = 0;\n    inputs.forEach(input => {\n      const size = util.sizeFromShape(input.shape);\n      outVals.set(input.vals, offset);\n      offset += size;\n    });\n  } else {\n    let colOffset = 0;\n    inputs.forEach(input => {\n      const decodedData = dtype === 'string' ? backend_util.fromUint8ToStringArray(input.vals) : input.vals;\n      let tIdx = 0;\n      for (let row = 0; row < input.shape[0]; ++row) {\n        const resIdx = row * outShape[1] + colOffset;\n        for (let col = 0; col < input.shape[1]; ++col) {\n          outVals[resIdx + col] = decodedData[tIdx++];\n        }\n      }\n      colOffset += input.shape[1];\n    });\n  }\n  return outVals;\n}","map":{"version":3,"sources":["../../src/kernels/Concat_impl.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,YAAY,EAAuC,IAAI,QAAO,uBAAuB;AAE7F,OAAM,SAAU,UAAU,CACtB,MAAqD,EAAE,QAAkB,EACzE,KAAe,EAAE,YAAqB,EAAA;EACxC,MAAM,OAAO,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;EAE3E,IAAI,YAAY,IAAI,KAAK,KAAK,QAAQ,EAAE;IACtC;IACA,IAAI,MAAM,GAAG,CAAC;IACd,MAAM,CAAC,OAAO,CAAC,KAAK,IAAG;MACrB,MAAM,IAAI,GAAG,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,KAAK,CAAC;MAE3C,OAAsB,CAAC,GAAG,CAAC,KAAK,CAAC,IAAkB,EAAE,MAAM,CAAC;MAC7D,MAAM,IAAI,IAAI;IAChB,CAAC,CAAC;GACH,MAAM;IACL,IAAI,SAAS,GAAG,CAAC;IAEjB,MAAM,CAAC,OAAO,CAAC,KAAK,IAAG;MACrB,MAAM,WAAW,GAAG,KAAK,KAAK,QAAQ,GAClC,YAAY,CAAC,sBAAsB,CAAC,KAAK,CAAC,IAAoB,CAAC,GAC/D,KAAK,CAAC,IAAkB;MAE5B,IAAI,IAAI,GAAG,CAAC;MAEZ,KAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,GAAG,EAAE;QAC7C,MAAM,MAAM,GAAG,GAAG,GAAG,QAAQ,CAAC,CAAC,CAAC,GAAG,SAAS;QAC5C,KAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,GAAG,EAAE;UAC7C,OAAO,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG,WAAW,CAAC,IAAI,EAAE,CAAC;QAC5C;MACF;MAED,SAAS,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;IAC7B,CAAC,CAAC;EACH;EAED,OAAO,OAAO;AAChB","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nexport function concatImpl(inputs, outShape, dtype, simplyConcat) {\n    const outVals = util.getArrayFromDType(dtype, util.sizeFromShape(outShape));\n    if (simplyConcat && dtype !== 'string') {\n        // Use built-in TypedArray.set() method for speed.\n        let offset = 0;\n        inputs.forEach(input => {\n            const size = util.sizeFromShape(input.shape);\n            outVals.set(input.vals, offset);\n            offset += size;\n        });\n    }\n    else {\n        let colOffset = 0;\n        inputs.forEach(input => {\n            const decodedData = dtype === 'string' ?\n                backend_util.fromUint8ToStringArray(input.vals) :\n                input.vals;\n            let tIdx = 0;\n            for (let row = 0; row < input.shape[0]; ++row) {\n                const resIdx = row * outShape[1] + colOffset;\n                for (let col = 0; col < input.shape[1]; ++col) {\n                    outVals[resIdx + col] = decodedData[tIdx++];\n                }\n            }\n            colOffset += input.shape[1];\n        });\n    }\n    return outVals;\n}\n//# sourceMappingURL=Concat_impl.js.map"]},"metadata":{},"sourceType":"module"}