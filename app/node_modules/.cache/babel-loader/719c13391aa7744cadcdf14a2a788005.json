{"ast":null,"code":"/**\n * ExecutionContext captures the runtime environment of the node. It keeps\n * track of the current frame and iteration for the control flow ops.\n *\n * For example, typical Dynamic RNN model may contain loops, for which\n * TensorFlow will generate graphs with Enter/Exit nodes to control the\n * current execution frame, and NextIteration Nodes for iteration id increment.\n * For model with branch logic, TensorFLow will generate Switch/Merge ops.\n */\nexport class ExecutionContext {\n  constructor() {\n    let weightMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let tensorArrayMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let tensorListMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let functionMap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    this.weightMap = weightMap;\n    this.tensorArrayMap = tensorArrayMap;\n    this.tensorListMap = tensorListMap;\n    this.functionMap = functionMap;\n    this.rootContext = {\n      id: 0,\n      frameName: '',\n      iterationId: 0\n    };\n    this.contexts = [this.rootContext];\n    this.lastId = 0;\n    this.generateCurrentContextIds();\n  }\n  newFrame(id, frameName) {\n    return {\n      id,\n      frameName,\n      iterationId: 0\n    };\n  }\n  /**\n   * Set the current context\n   * @param contexts: ExecutionContextInfo[] the current path of execution\n   * frames\n   */\n  set currentContext(contexts) {\n    if (this.contexts !== contexts) {\n      this.contexts = contexts;\n      this.generateCurrentContextIds();\n    }\n  }\n  get currentContext() {\n    return this.contexts;\n  }\n  /**\n   * Returns the current context in string format.\n   */\n  get currentContextId() {\n    return this._currentContextIds[0];\n  }\n  /**\n   * Returns the current context and all parent contexts in string format.\n   * This allow access to the nodes in the current and parent frames.\n   */\n  get currentContextIds() {\n    return this._currentContextIds;\n  }\n  generateCurrentContextIds() {\n    const names = [];\n    for (let i = 0; i < this.contexts.length - 1; i++) {\n      const contexts = this.contexts.slice(0, this.contexts.length - i);\n      names.push(this.contextIdforContexts(contexts));\n    }\n    names.push('');\n    this._currentContextIds = names;\n  }\n  contextIdforContexts(contexts) {\n    return contexts ? contexts.map(context => context.id === 0 && context.iterationId === 0 ? '' : `${context.frameName}-${context.iterationId}`).join('/') : '';\n  }\n  /**\n   * Enter a new frame, a new context is pushed on the current context list.\n   * @param frameId new frame id\n   */\n  enterFrame(frameId) {\n    if (this.contexts) {\n      this.lastId++;\n      this.contexts = this.contexts.slice();\n      this.contexts.push(this.newFrame(this.lastId, frameId));\n      this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));\n    }\n  }\n  /**\n   * Exit the current frame, the last context is removed from the current\n   * context list.\n   */\n  exitFrame() {\n    if (this.contexts && this.contexts.length > 1) {\n      this.contexts = this.contexts.slice();\n      this.contexts.splice(-1);\n      this.currentContextIds.shift();\n    } else {\n      throw new Error('Cannot exit frame, the context is empty');\n    }\n  }\n  /**\n   * Enter the next iteration of a loop, the iteration id of last context is\n   * increased.\n   */\n  nextIteration() {\n    if (this.contexts && this.contexts.length > 0) {\n      this.contexts = this.contexts.slice();\n      this.lastId++;\n      const context = Object.assign({}, this.contexts[this.contexts.length - 1]);\n      context.iterationId += 1;\n      context.id = this.lastId;\n      this.contexts.splice(-1, 1, context);\n      this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));\n    } else {\n      throw new Error('Cannot increase frame iteration, the context is empty');\n    }\n  }\n  getWeight(name) {\n    return this.weightMap[name];\n  }\n  addTensorArray(tensorArray) {\n    this.tensorArrayMap[tensorArray.id] = tensorArray;\n  }\n  getTensorArray(id) {\n    return this.tensorArrayMap[id];\n  }\n  addTensorList(tensorList) {\n    this.tensorListMap[tensorList.id] = tensorList;\n  }\n  getTensorList(id) {\n    return this.tensorListMap[id];\n  }\n  dispose(keepIds) {\n    for (const key in this.tensorArrayMap) {\n      this.tensorArrayMap[key].clearAndClose(keepIds);\n    }\n    for (const key in this.tensorListMap) {\n      this.tensorListMap[key].clearAndClose(keepIds);\n    }\n  }\n}","map":{"version":3,"sources":["../../src/executor/execution_context.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * ExecutionContext captures the runtime environment of the node. It keeps\n * track of the current frame and iteration for the control flow ops.\n *\n * For example, typical Dynamic RNN model may contain loops, for which\n * TensorFlow will generate graphs with Enter/Exit nodes to control the\n * current execution frame, and NextIteration Nodes for iteration id increment.\n * For model with branch logic, TensorFLow will generate Switch/Merge ops.\n */\nexport class ExecutionContext {\n    constructor(weightMap = {}, tensorArrayMap = {}, tensorListMap = {}, functionMap = {}) {\n        this.weightMap = weightMap;\n        this.tensorArrayMap = tensorArrayMap;\n        this.tensorListMap = tensorListMap;\n        this.functionMap = functionMap;\n        this.rootContext = { id: 0, frameName: '', iterationId: 0 };\n        this.contexts = [this.rootContext];\n        this.lastId = 0;\n        this.generateCurrentContextIds();\n    }\n    newFrame(id, frameName) {\n        return { id, frameName, iterationId: 0 };\n    }\n    /**\n     * Set the current context\n     * @param contexts: ExecutionContextInfo[] the current path of execution\n     * frames\n     */\n    set currentContext(contexts) {\n        if (this.contexts !== contexts) {\n            this.contexts = contexts;\n            this.generateCurrentContextIds();\n        }\n    }\n    get currentContext() {\n        return this.contexts;\n    }\n    /**\n     * Returns the current context in string format.\n     */\n    get currentContextId() {\n        return this._currentContextIds[0];\n    }\n    /**\n     * Returns the current context and all parent contexts in string format.\n     * This allow access to the nodes in the current and parent frames.\n     */\n    get currentContextIds() {\n        return this._currentContextIds;\n    }\n    generateCurrentContextIds() {\n        const names = [];\n        for (let i = 0; i < this.contexts.length - 1; i++) {\n            const contexts = this.contexts.slice(0, this.contexts.length - i);\n            names.push(this.contextIdforContexts(contexts));\n        }\n        names.push('');\n        this._currentContextIds = names;\n    }\n    contextIdforContexts(contexts) {\n        return contexts ?\n            contexts\n                .map(context => (context.id === 0 && context.iterationId === 0) ?\n                '' :\n                `${context.frameName}-${context.iterationId}`)\n                .join('/') :\n            '';\n    }\n    /**\n     * Enter a new frame, a new context is pushed on the current context list.\n     * @param frameId new frame id\n     */\n    enterFrame(frameId) {\n        if (this.contexts) {\n            this.lastId++;\n            this.contexts = this.contexts.slice();\n            this.contexts.push(this.newFrame(this.lastId, frameId));\n            this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));\n        }\n    }\n    /**\n     * Exit the current frame, the last context is removed from the current\n     * context list.\n     */\n    exitFrame() {\n        if (this.contexts && this.contexts.length > 1) {\n            this.contexts = this.contexts.slice();\n            this.contexts.splice(-1);\n            this.currentContextIds.shift();\n        }\n        else {\n            throw new Error('Cannot exit frame, the context is empty');\n        }\n    }\n    /**\n     * Enter the next iteration of a loop, the iteration id of last context is\n     * increased.\n     */\n    nextIteration() {\n        if (this.contexts && this.contexts.length > 0) {\n            this.contexts = this.contexts.slice();\n            this.lastId++;\n            const context = Object.assign({}, this.contexts[this.contexts.length - 1]);\n            context.iterationId += 1;\n            context.id = this.lastId;\n            this.contexts.splice(-1, 1, context);\n            this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));\n        }\n        else {\n            throw new Error('Cannot increase frame iteration, the context is empty');\n        }\n    }\n    getWeight(name) {\n        return this.weightMap[name];\n    }\n    addTensorArray(tensorArray) {\n        this.tensorArrayMap[tensorArray.id] = tensorArray;\n    }\n    getTensorArray(id) {\n        return this.tensorArrayMap[id];\n    }\n    addTensorList(tensorList) {\n        this.tensorListMap[tensorList.id] = tensorList;\n    }\n    getTensorList(id) {\n        return this.tensorListMap[id];\n    }\n    dispose(keepIds) {\n        for (const key in this.tensorArrayMap) {\n            this.tensorArrayMap[key].clearAndClose(keepIds);\n        }\n        for (const key in this.tensorListMap) {\n            this.tensorListMap[key].clearAndClose(keepIds);\n        }\n    }\n}\n//# sourceMappingURL=execution_context.js.map"]},"metadata":{},"sourceType":"module"}