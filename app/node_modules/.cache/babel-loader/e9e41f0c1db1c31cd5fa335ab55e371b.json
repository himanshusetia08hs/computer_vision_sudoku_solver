{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, DepthwiseConv2dNativeBackpropFilter, TensorBuffer } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function depthwiseConv2dNativeBackpropFilter(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    x,\n    dy\n  } = inputs;\n  const {\n    strides,\n    dilations,\n    pad,\n    dimRoundingMode,\n    filterShape\n  } = attrs;\n  assertNotComplex([x, dy], 'depthwiseConv2dNativeBackpropFilter');\n  const convInfo = backend_util.computeConv2DInfo(x.shape, filterShape, strides, dilations, pad, dimRoundingMode, true /* depthwise */);\n  const {\n    strideHeight,\n    strideWidth,\n    filterHeight,\n    filterWidth\n  } = convInfo;\n  const dW = new TensorBuffer(convInfo.filterShape, 'float32');\n  const leftPad = convInfo.padInfo.left;\n  const topPad = convInfo.padInfo.top;\n  const chMul = convInfo.outChannels / convInfo.inChannels;\n  const xVals = backend.data.get(x.dataId).values;\n  const xBuf = new TensorBuffer(x.shape, x.dtype, xVals);\n  const dyVals = backend.data.get(dy.dataId).values;\n  const dyBuf = new TensorBuffer(dy.shape, dy.dtype, dyVals);\n  for (let wR = 0; wR < filterHeight; ++wR) {\n    const yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));\n    const yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);\n    for (let wC = 0; wC < filterWidth; ++wC) {\n      const yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));\n      const yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);\n      for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {\n        const d1 = Math.trunc(d2 / chMul);\n        const dm = d2 % chMul;\n        let dotProd = 0;\n        for (let b = 0; b < convInfo.batchSize; ++b) {\n          for (let yR = yRMin; yR < yRMax; ++yR) {\n            const xR = wR + yR * strideHeight - topPad;\n            for (let yC = yCMin; yC < yCMax; ++yC) {\n              const xC = wC + yC * strideWidth - leftPad;\n              dotProd += xBuf.get(b, xR, xC, d1) * dyBuf.get(b, yR, yC, d2);\n            }\n          }\n        }\n        dW.set(dotProd, wR, wC, d1, dm);\n      }\n    }\n  }\n  return backend.makeTensorInfo(dW.shape, dW.dtype, dW.values);\n}\nexport const depthwiseConv2dNativeBackpropFilterConfig = {\n  kernelName: DepthwiseConv2dNativeBackpropFilter,\n  backendName: 'cpu',\n  kernelFunc: depthwiseConv2dNativeBackpropFilter\n};","map":{"version":3,"sources":["../../src/kernels/DepthwiseConv2dNativeBackpropFilter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, DepthwiseConv2dNativeBackpropFilter, TensorBuffer } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function depthwiseConv2dNativeBackpropFilter(args) {\n    const { inputs, backend, attrs } = args;\n    const { x, dy } = inputs;\n    const { strides, dilations, pad, dimRoundingMode, filterShape } = attrs;\n    assertNotComplex([x, dy], 'depthwiseConv2dNativeBackpropFilter');\n    const convInfo = backend_util.computeConv2DInfo(x.shape, filterShape, strides, dilations, pad, dimRoundingMode, true /* depthwise */);\n    const { strideHeight, strideWidth, filterHeight, filterWidth } = convInfo;\n    const dW = new TensorBuffer(convInfo.filterShape, 'float32');\n    const leftPad = convInfo.padInfo.left;\n    const topPad = convInfo.padInfo.top;\n    const chMul = convInfo.outChannels / convInfo.inChannels;\n    const xVals = backend.data.get(x.dataId).values;\n    const xBuf = new TensorBuffer(x.shape, x.dtype, xVals);\n    const dyVals = backend.data.get(dy.dataId).values;\n    const dyBuf = new TensorBuffer(dy.shape, dy.dtype, dyVals);\n    for (let wR = 0; wR < filterHeight; ++wR) {\n        const yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));\n        const yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);\n        for (let wC = 0; wC < filterWidth; ++wC) {\n            const yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));\n            const yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);\n            for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {\n                const d1 = Math.trunc(d2 / chMul);\n                const dm = d2 % chMul;\n                let dotProd = 0;\n                for (let b = 0; b < convInfo.batchSize; ++b) {\n                    for (let yR = yRMin; yR < yRMax; ++yR) {\n                        const xR = wR + yR * strideHeight - topPad;\n                        for (let yC = yCMin; yC < yCMax; ++yC) {\n                            const xC = wC + yC * strideWidth - leftPad;\n                            dotProd += xBuf.get(b, xR, xC, d1) *\n                                dyBuf.get(b, yR, yC, d2);\n                        }\n                    }\n                }\n                dW.set(dotProd, wR, wC, d1, dm);\n            }\n        }\n    }\n    return backend.makeTensorInfo(dW.shape, dW.dtype, dW.values);\n}\nexport const depthwiseConv2dNativeBackpropFilterConfig = {\n    kernelName: DepthwiseConv2dNativeBackpropFilter,\n    backendName: 'cpu',\n    kernelFunc: depthwiseConv2dNativeBackpropFilter\n};\n//# sourceMappingURL=DepthwiseConv2dNativeBackpropFilter.js.map"]},"metadata":{},"sourceType":"module"}