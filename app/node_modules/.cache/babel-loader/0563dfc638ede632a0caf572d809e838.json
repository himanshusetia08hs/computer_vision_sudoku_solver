{"ast":null,"code":"import { computeStrides, sizeFromShape } from '../util';\n/**\n * Check whether updates.shape = indices.shape[:batchDim] +\n * shape[sliceDim:]\n *\n * @param x The input tensor.\n */\nexport function validateUpdateShape(shape, indices, updates) {\n  const sliceDim = indices.rank > 1 ? indices.shape[indices.rank - 1] : 1;\n  const batchDim = indices.rank > 1 ? indices.rank - 1 : 1;\n  const shapeError = 'Must have updates.shape = indices.shape[:batchDim] + ' + `shape[sliceDim:], got updates.shape: ${updates.shape}` + `, indices.shape: ${indices.shape}, shape: ${shape}` + `, sliceDim: ${sliceDim}, and batchDim: ${batchDim}.`;\n  if (updates.rank < batchDim) {\n    throw new Error(shapeError + ` update.rank < ${batchDim}. `);\n  }\n  if (shape.length < sliceDim + (updates.rank - batchDim)) {\n    throw new Error(shapeError + ` Output shape length < ${sliceDim + (updates.rank - batchDim)}`);\n  }\n  if (updates.rank !== batchDim + shape.length - sliceDim) {\n    throw new Error(shapeError + ` update.rank != ${batchDim + shape.length - sliceDim}`);\n  }\n  for (let d = 0; d < batchDim; ++d) {\n    if (updates.shape[d] !== indices.shape[d]) {\n      throw new Error(shapeError + ` updates.shape[${d}] (${updates.shape[d]}) != indices.shape[${d}] (${indices.shape[d]}).`);\n    }\n  }\n  for (let d = 0; d < updates.rank - batchDim; ++d) {\n    if (updates.shape[d + batchDim] !== shape[d + sliceDim]) {\n      throw new Error(shapeError + ` updates.shape[${d + batchDim}] (${updates.shape[d + batchDim]}) != shape[${d + batchDim}] (${shape[d + batchDim]})`);\n    }\n  }\n}\n/**\n * Validate scatter nd inputs.\n *\n * @param update The tensor contains the update values.\n * @param indices The tensor contains the indices for the update values.\n * @param shape The shape of the output tensor.\n */\nexport function validateInput(updates, indices, shape) {\n  if (indices.rank < 1) {\n    throw new Error('tf.scatterND() expects the indices to be rank 1 or higher,' + ` but the rank was ${indices.rank}.`);\n  }\n  if (updates.rank < 1) {\n    throw new Error('tf.scatterND() expects the updates to be rank 1 or higher,' + ` but the rank was ${updates.rank}.`);\n  }\n  if (indices.dtype !== 'int32') {\n    throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${indices.dtype}`);\n  }\n  if (shape.length < 1) {\n    throw new Error(`Output rank must be greater or equal to 1, but got shape: ${shape}`);\n  }\n  if (shape.length === 0) {\n    if (indices.size === 0) {\n      throw new Error(`Indices specified for empty output. indices shape: ${indices.shape}`);\n    }\n    if (updates.size === 0) {\n      throw new Error(`Updates specified for empty output. updates shape: ${updates.shape}`);\n    }\n  }\n  validateUpdateShape(shape, indices, updates);\n}\n/**\n * Calculate the shape information for the output.\n *\n * @param update The tensor contains the update values.\n * @param indices The tensor contains the indices for the update values.\n * @param shape The shape of the output tensor.\n *\n * @returns ScatterShapeInfo\n */\nexport function calculateShapes(updates, indices, shape) {\n  // Calculate the number of dimensions in indices\n  const indicesRank = indices.shape.length;\n  const sliceRank = indicesRank > 1 ? indices.shape[indicesRank - 1] : 1;\n  // Calculate the number of elements that make up each slice of our updated\n  // tensor. This allows us to work with flattened tensors and copy over whole\n  // slices at a time.\n  const totalNd = shape.length;\n  let sliceSize = 1;\n  for (let i = sliceRank; i < totalNd; ++i) {\n    sliceSize *= shape[i];\n  }\n  const safeSliceDim = sliceRank < 1 ? 1 : sliceRank;\n  const numUpdates = sizeFromShape(indices.shape) / safeSliceDim;\n  const strides = [...computeStrides(shape.slice(0, sliceRank)), 1];\n  const outputSize = sizeFromShape(shape);\n  return {\n    sliceRank,\n    numUpdates,\n    sliceSize,\n    strides,\n    outputSize\n  };\n}","map":{"version":3,"sources":["../../src/ops/scatter_nd_util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { computeStrides, sizeFromShape } from '../util';\n/**\n * Check whether updates.shape = indices.shape[:batchDim] +\n * shape[sliceDim:]\n *\n * @param x The input tensor.\n */\nexport function validateUpdateShape(shape, indices, updates) {\n    const sliceDim = (indices.rank > 1) ? indices.shape[indices.rank - 1] : 1;\n    const batchDim = (indices.rank > 1) ? indices.rank - 1 : 1;\n    const shapeError = 'Must have updates.shape = indices.shape[:batchDim] + ' +\n        `shape[sliceDim:], got updates.shape: ${updates.shape}` +\n        `, indices.shape: ${indices.shape}, shape: ${shape}` +\n        `, sliceDim: ${sliceDim}, and batchDim: ${batchDim}.`;\n    if (updates.rank < batchDim) {\n        throw new Error(shapeError + ` update.rank < ${batchDim}. `);\n    }\n    if (shape.length < sliceDim + (updates.rank - batchDim)) {\n        throw new Error(shapeError +\n            ` Output shape length < ${sliceDim + (updates.rank - batchDim)}`);\n    }\n    if (updates.rank !== batchDim + shape.length - sliceDim) {\n        throw new Error(shapeError + ` update.rank != ${batchDim + shape.length - sliceDim}`);\n    }\n    for (let d = 0; d < batchDim; ++d) {\n        if (updates.shape[d] !== indices.shape[d]) {\n            throw new Error(shapeError +\n                ` updates.shape[${d}] (${updates.shape[d]}) != indices.shape[${d}] (${indices.shape[d]}).`);\n        }\n    }\n    for (let d = 0; d < updates.rank - batchDim; ++d) {\n        if (updates.shape[d + batchDim] !== shape[d + sliceDim]) {\n            throw new Error(shapeError +\n                ` updates.shape[${d + batchDim}] (${updates.shape[d + batchDim]}) != shape[${d + batchDim}] (${shape[d + batchDim]})`);\n        }\n    }\n}\n/**\n * Validate scatter nd inputs.\n *\n * @param update The tensor contains the update values.\n * @param indices The tensor contains the indices for the update values.\n * @param shape The shape of the output tensor.\n */\nexport function validateInput(updates, indices, shape) {\n    if (indices.rank < 1) {\n        throw new Error('tf.scatterND() expects the indices to be rank 1 or higher,' +\n            ` but the rank was ${indices.rank}.`);\n    }\n    if (updates.rank < 1) {\n        throw new Error('tf.scatterND() expects the updates to be rank 1 or higher,' +\n            ` but the rank was ${updates.rank}.`);\n    }\n    if (indices.dtype !== 'int32') {\n        throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${indices.dtype}`);\n    }\n    if (shape.length < 1) {\n        throw new Error(`Output rank must be greater or equal to 1, but got shape: ${shape}`);\n    }\n    if (shape.length === 0) {\n        if (indices.size === 0) {\n            throw new Error(`Indices specified for empty output. indices shape: ${indices.shape}`);\n        }\n        if (updates.size === 0) {\n            throw new Error(`Updates specified for empty output. updates shape: ${updates.shape}`);\n        }\n    }\n    validateUpdateShape(shape, indices, updates);\n}\n/**\n * Calculate the shape information for the output.\n *\n * @param update The tensor contains the update values.\n * @param indices The tensor contains the indices for the update values.\n * @param shape The shape of the output tensor.\n *\n * @returns ScatterShapeInfo\n */\nexport function calculateShapes(updates, indices, shape) {\n    // Calculate the number of dimensions in indices\n    const indicesRank = indices.shape.length;\n    const sliceRank = (indicesRank > 1) ? indices.shape[indicesRank - 1] : 1;\n    // Calculate the number of elements that make up each slice of our updated\n    // tensor. This allows us to work with flattened tensors and copy over whole\n    // slices at a time.\n    const totalNd = shape.length;\n    let sliceSize = 1;\n    for (let i = sliceRank; i < totalNd; ++i) {\n        sliceSize *= shape[i];\n    }\n    const safeSliceDim = (sliceRank < 1) ? 1 : sliceRank;\n    const numUpdates = sizeFromShape(indices.shape) / safeSliceDim;\n    const strides = [...computeStrides(shape.slice(0, sliceRank)), 1];\n    const outputSize = sizeFromShape(shape);\n    return { sliceRank, numUpdates, sliceSize, strides, outputSize };\n}\n//# sourceMappingURL=scatter_nd_util.js.map"]},"metadata":{},"sourceType":"module"}