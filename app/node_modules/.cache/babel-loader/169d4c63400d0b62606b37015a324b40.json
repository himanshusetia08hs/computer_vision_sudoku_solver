{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { ValueError } from '../errors';\nimport { pyListRepeat } from './generic_utils';\nimport { isInteger, max } from './math_utils';\n/**\n * Transforms a single number of array of numbers into an array of numbers.\n * @param value\n * @param n: The size of the tuple to be returned.\n * @param name: Name of the parameter, used for generating error messages.\n * @returns An array of numbers.\n */\nexport function normalizeArray(value, n, name) {\n  if (typeof value === 'number') {\n    return pyListRepeat(value, n);\n  } else {\n    if (value.length !== n) {\n      throw new ValueError(`The ${name} argument must be an integer or tuple of ${n} integers.` + ` Received: ${value.length} elements.`);\n    }\n    for (let i = 0; i < n; ++i) {\n      const singleValue = value[i];\n      if (!isInteger(singleValue)) {\n        throw new ValueError(`The ${name} argument must be an integer or tuple of ${n}` + ` integers. Received: ${JSON.stringify(value)} including a` + ` non-integer number ${singleValue}`);\n      }\n    }\n    return value;\n  }\n}\n/**\n * Determines output length of a convolution given input length.\n * @param inputLength\n * @param filterSize\n * @param padding\n * @param stride\n * @param dilation: dilation rate.\n */\nexport function convOutputLength(inputLength, filterSize, padding, stride) {\n  let dilation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  if (inputLength == null) {\n    return inputLength;\n  }\n  const dilatedFilterSize = filterSize + (filterSize - 1) * (dilation - 1);\n  let outputLength;\n  if (padding === 'same') {\n    outputLength = inputLength;\n  } else {\n    // VALID\n    outputLength = inputLength - dilatedFilterSize + 1;\n  }\n  return Math.floor((outputLength + stride - 1) / stride);\n}\nexport function deconvLength(dimSize, strideSize, kernelSize, padding) {\n  if (dimSize == null) {\n    return null;\n  }\n  if (padding === 'valid') {\n    dimSize = dimSize * strideSize + max([kernelSize - strideSize, 0]);\n  } else if (padding === 'same') {\n    dimSize = dimSize * strideSize;\n  } else {\n    throw new ValueError(`Unsupport padding mode: ${padding}.`);\n  }\n  return dimSize;\n}","map":{"version":3,"sources":["../../src/utils/conv_utils.ts"],"names":[],"mappings":"AAAA;;;;;;;;AAQG;AAEH,SAAQ,UAAU,QAAO,WAAW;AAGpC,SAAQ,YAAY,QAAO,iBAAiB;AAC5C,SAAQ,SAAS,EAAE,GAAG,QAAO,cAAc;AAE3C;;;;;;AAMG;AACH,OAAM,SAAU,cAAc,CAC1B,KAAsB,EAAE,CAAS,EAAE,IAAY,EAAA;EACjD,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;IAC7B,OAAO,YAAY,CAAC,KAAK,EAAE,CAAC,CAAC;GAC9B,MAAM;IACL,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;MACtB,MAAM,IAAI,UAAU,CAChB,OAAO,IAAI,4CAA4C,CAAC,YAAY,GACpE,cAAc,KAAK,CAAC,MAAM,YAAY,CAAC;IAC5C;IACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE;MAC1B,MAAM,WAAW,GAAG,KAAK,CAAC,CAAC,CAAC;MAC5B,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,EAAE;QAC3B,MAAM,IAAI,UAAU,CAChB,OAAO,IAAI,4CAA4C,CAAC,EAAE,GAC1D,wBAAwB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,cAAc,GAC3D,uBAAuB,WAAW,EAAE,CAAC;MAC1C;IACF;IACD,OAAO,KAAK;EACb;AACH;AAEA;;;;;;;AAOG;AACH,OAAM,SAAU,gBAAgB,CAC5B,WAAmB,EAAE,UAAkB,EAAE,OAAoB,EAC7D,MAAc,EAAc;EAAA,IAAZ,QAAQ,uEAAG,CAAC;EAC9B,IAAI,WAAW,IAAI,IAAI,EAAE;IACvB,OAAO,WAAW;EACnB;EACD,MAAM,iBAAiB,GAAG,UAAU,GAAG,CAAC,UAAU,GAAG,CAAC,KAAK,QAAQ,GAAG,CAAC,CAAC;EACxE,IAAI,YAAoB;EACxB,IAAI,OAAO,KAAK,MAAM,EAAE;IACtB,YAAY,GAAG,WAAW;GAC3B,MAAM;IAAG;IACR,YAAY,GAAG,WAAW,GAAG,iBAAiB,GAAG,CAAC;EACnD;EACD,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,YAAY,GAAG,MAAM,GAAG,CAAC,IAAI,MAAM,CAAC;AACzD;AAEA,OAAM,SAAU,YAAY,CACxB,OAAe,EAAE,UAAkB,EAAE,UAAkB,EACvD,OAAoB,EAAA;EACtB,IAAI,OAAO,IAAI,IAAI,EAAE;IACnB,OAAO,IAAI;EACZ;EAED,IAAI,OAAO,KAAK,OAAO,EAAE;IACvB,OAAO,GAAG,OAAO,GAAG,UAAU,GAAG,GAAG,CAAC,CAAC,UAAU,GAAG,UAAU,EAAE,CAAC,CAAC,CAAC;GACnE,MAAM,IAAI,OAAO,KAAK,MAAM,EAAE;IAC7B,OAAO,GAAG,OAAO,GAAG,UAAU;GAC/B,MAAM;IACL,MAAM,IAAI,UAAU,CAAC,2BAA2B,OAAO,GAAG,CAAC;EAC5D;EACD,OAAO,OAAO;AAChB","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { ValueError } from '../errors';\nimport { pyListRepeat } from './generic_utils';\nimport { isInteger, max } from './math_utils';\n/**\n * Transforms a single number of array of numbers into an array of numbers.\n * @param value\n * @param n: The size of the tuple to be returned.\n * @param name: Name of the parameter, used for generating error messages.\n * @returns An array of numbers.\n */\nexport function normalizeArray(value, n, name) {\n    if (typeof value === 'number') {\n        return pyListRepeat(value, n);\n    }\n    else {\n        if (value.length !== n) {\n            throw new ValueError(`The ${name} argument must be an integer or tuple of ${n} integers.` +\n                ` Received: ${value.length} elements.`);\n        }\n        for (let i = 0; i < n; ++i) {\n            const singleValue = value[i];\n            if (!isInteger(singleValue)) {\n                throw new ValueError(`The ${name} argument must be an integer or tuple of ${n}` +\n                    ` integers. Received: ${JSON.stringify(value)} including a` +\n                    ` non-integer number ${singleValue}`);\n            }\n        }\n        return value;\n    }\n}\n/**\n * Determines output length of a convolution given input length.\n * @param inputLength\n * @param filterSize\n * @param padding\n * @param stride\n * @param dilation: dilation rate.\n */\nexport function convOutputLength(inputLength, filterSize, padding, stride, dilation = 1) {\n    if (inputLength == null) {\n        return inputLength;\n    }\n    const dilatedFilterSize = filterSize + (filterSize - 1) * (dilation - 1);\n    let outputLength;\n    if (padding === 'same') {\n        outputLength = inputLength;\n    }\n    else { // VALID\n        outputLength = inputLength - dilatedFilterSize + 1;\n    }\n    return Math.floor((outputLength + stride - 1) / stride);\n}\nexport function deconvLength(dimSize, strideSize, kernelSize, padding) {\n    if (dimSize == null) {\n        return null;\n    }\n    if (padding === 'valid') {\n        dimSize = dimSize * strideSize + max([kernelSize - strideSize, 0]);\n    }\n    else if (padding === 'same') {\n        dimSize = dimSize * strideSize;\n    }\n    else {\n        throw new ValueError(`Unsupport padding mode: ${padding}.`);\n    }\n    return dimSize;\n}\n//# sourceMappingURL=conv_utils.js.map"]},"metadata":{},"sourceType":"module"}