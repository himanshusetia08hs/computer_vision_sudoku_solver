{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { env, tensor, util } from '@tensorflow/tfjs-core';\nimport { LazyIterator } from './lazy_iterator';\n/**\n * Provide a stream of tensors from microphone audio stream. The tensors are\n * representing audio data as frequency-domain spectrogram generated with\n * browser's native FFT. Tensors representing time-domain waveform is available\n * based on configuration. Only works in browser environment.\n */\nexport class MicrophoneIterator extends LazyIterator {\n  constructor(microphoneConfig) {\n    super();\n    this.microphoneConfig = microphoneConfig;\n    this.isClosed = false;\n    this.fftSize = microphoneConfig.fftSize || 1024;\n    const fftSizeLog2 = Math.log2(this.fftSize);\n    if (this.fftSize < 0 || fftSizeLog2 < 4 || fftSizeLog2 > 14 || !Number.isInteger(fftSizeLog2)) {\n      throw new Error(`Invalid fftSize: it must be a power of 2 between ` + `2 to 4 and 2 to 14, but got ${this.fftSize}`);\n    }\n    this.numFrames = microphoneConfig.numFramesPerSpectrogram || 43;\n    this.sampleRateHz = microphoneConfig.sampleRateHz;\n    this.columnTruncateLength = microphoneConfig.columnTruncateLength || this.fftSize;\n    this.audioTrackConstraints = microphoneConfig.audioTrackConstraints;\n    this.smoothingTimeConstant = microphoneConfig.smoothingTimeConstant || 0;\n    this.includeSpectrogram = microphoneConfig.includeSpectrogram === false ? false : true;\n    this.includeWaveform = microphoneConfig.includeWaveform === true ? true : false;\n    if (!this.includeSpectrogram && !this.includeWaveform) {\n      throw new Error('Both includeSpectrogram and includeWaveform are false. ' + 'At least one type of data should be returned.');\n    }\n  }\n  summary() {\n    return `microphone`;\n  }\n  // Construct a MicrophoneIterator and start the audio stream.\n  static async create() {\n    let microphoneConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (env().get('IS_NODE')) {\n      throw new Error('microphone API is only supported in browser environment.');\n    }\n    const microphoneIterator = new MicrophoneIterator(microphoneConfig);\n    // Call async function start() to initialize the audio stream.\n    await microphoneIterator.start();\n    return microphoneIterator;\n  }\n  // Start the audio stream and FFT.\n  async start() {\n    try {\n      this.stream = await navigator.mediaDevices.getUserMedia({\n        audio: this.audioTrackConstraints == null ? true : this.audioTrackConstraints,\n        video: false\n      });\n    } catch (e) {\n      throw new Error(`Error thrown while initializing video stream: ${e.message}`);\n    }\n    if (!this.stream) {\n      throw new Error('Could not obtain audio from microphone.');\n    }\n    const ctxConstructor =\n    // tslint:disable-next-line:no-any\n    window.AudioContext || window.webkitAudioContext;\n    this.audioContext = new ctxConstructor();\n    if (!this.sampleRateHz) {\n      // If sample rate is not provided, use the available sample rate on\n      // device.\n      this.sampleRateHz = this.audioContext.sampleRate;\n    } else if (this.audioContext.sampleRate !== this.sampleRateHz) {\n      throw new Error(`Mismatch in sampling rate: ` + `Expected: ${this.sampleRateHz}; ` + `Actual: ${this.audioContext.sampleRate}`);\n    }\n    const streamSource = this.audioContext.createMediaStreamSource(this.stream);\n    this.analyser = this.audioContext.createAnalyser();\n    this.analyser.fftSize = this.fftSize * 2;\n    this.analyser.smoothingTimeConstant = this.smoothingTimeConstant;\n    streamSource.connect(this.analyser);\n    this.freqData = new Float32Array(this.fftSize);\n    this.timeData = new Float32Array(this.fftSize);\n    return;\n  }\n  async next() {\n    if (this.isClosed) {\n      return {\n        value: null,\n        done: true\n      };\n    }\n    let spectrogramTensor;\n    let waveformTensor;\n    const audioDataQueue = await this.getAudioData();\n    if (this.includeSpectrogram) {\n      const freqData = this.flattenQueue(audioDataQueue.freqDataQueue);\n      spectrogramTensor = this.getTensorFromAudioDataArray(freqData, [this.numFrames, this.columnTruncateLength, 1]);\n    }\n    if (this.includeWaveform) {\n      const timeData = this.flattenQueue(audioDataQueue.timeDataQueue);\n      waveformTensor = this.getTensorFromAudioDataArray(timeData, [this.numFrames * this.fftSize, 1]);\n    }\n    return {\n      value: {\n        'spectrogram': spectrogramTensor,\n        'waveform': waveformTensor\n      },\n      done: false\n    };\n  }\n  // Capture one result from the audio stream, and extract the value from\n  // iterator.next() result.\n  async capture() {\n    return (await this.next()).value;\n  }\n  async getAudioData() {\n    const freqDataQueue = [];\n    const timeDataQueue = [];\n    let currentFrames = 0;\n    return new Promise(resolve => {\n      const intervalID = setInterval(() => {\n        if (this.includeSpectrogram) {\n          this.analyser.getFloatFrequencyData(this.freqData);\n          // If the audio stream is initializing, return empty queue.\n          if (this.freqData[0] === -Infinity) {\n            resolve({\n              freqDataQueue,\n              timeDataQueue\n            });\n          }\n          freqDataQueue.push(this.freqData.slice(0, this.columnTruncateLength));\n        }\n        if (this.includeWaveform) {\n          this.analyser.getFloatTimeDomainData(this.timeData);\n          timeDataQueue.push(this.timeData.slice());\n        }\n        // Clean interval and return when all frames have been collected\n        if (++currentFrames === this.numFrames) {\n          clearInterval(intervalID);\n          resolve({\n            freqDataQueue,\n            timeDataQueue\n          });\n        }\n      }, this.fftSize / this.sampleRateHz * 1e3);\n    });\n  }\n  // Stop the audio stream and pause the iterator.\n  stop() {\n    if (!this.isClosed) {\n      this.isClosed = true;\n      this.analyser.disconnect();\n      this.audioContext.close();\n      if (this.stream != null && this.stream.getTracks().length > 0) {\n        this.stream.getTracks()[0].stop();\n      }\n    }\n  }\n  // Override toArray() function to prevent collecting.\n  toArray() {\n    throw new Error('Can not convert infinite audio stream to array.');\n  }\n  // Return audio sampling rate in Hz\n  getSampleRate() {\n    return this.sampleRateHz;\n  }\n  flattenQueue(queue) {\n    const frameSize = queue[0].length;\n    const freqData = new Float32Array(queue.length * frameSize);\n    queue.forEach((data, i) => freqData.set(data, i * frameSize));\n    return freqData;\n  }\n  getTensorFromAudioDataArray(freqData, shape) {\n    const vals = new Float32Array(util.sizeFromShape(shape));\n    // If the data is less than the output shape, the rest is padded with zeros.\n    vals.set(freqData, vals.length - freqData.length);\n    return tensor(vals, shape);\n  }\n}","map":{"version":3,"sources":["../../src/iterators/microphone_iterator.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBG;AAEH,SAAQ,GAAG,EAAU,MAAM,EAAuC,IAAI,QAAO,uBAAuB;AAEpG,SAAQ,YAAY,QAAO,iBAAiB;AAE5C;;;;;AAKG;AACH,OAAM,MAAO,kBAAmB,SAAQ,YAA6B,CAAA;EAgBnE,WAAA,CAAuC,gBAAkC,EAAA;IACvE,KAAK,EAAE;IAD8B,IAAA,CAAA,gBAAgB,GAAhB,gBAAgB;IAf/C,IAAA,CAAA,QAAQ,GAAG,KAAK;IAiBtB,IAAI,CAAC,OAAO,GAAG,gBAAgB,CAAC,OAAO,IAAI,IAAI;IAC/C,MAAM,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC;IAC3C,IAAI,IAAI,CAAC,OAAO,GAAG,CAAC,IAAI,WAAW,GAAG,CAAC,IAAI,WAAW,GAAG,EAAE,IACvD,CAAC,MAAM,CAAC,SAAS,CAAC,WAAW,CAAC,EAAE;MAClC,MAAM,IAAI,KAAK,CACX,mDAAmD,GACnD,+BAA+B,IAAI,CAAC,OAAO,EAAE,CAAC;IACnD;IAED,IAAI,CAAC,SAAS,GAAG,gBAAgB,CAAC,uBAAuB,IAAI,EAAE;IAC/D,IAAI,CAAC,YAAY,GAAG,gBAAgB,CAAC,YAAY;IACjD,IAAI,CAAC,oBAAoB,GACrB,gBAAgB,CAAC,oBAAoB,IAAI,IAAI,CAAC,OAAO;IACzD,IAAI,CAAC,qBAAqB,GAAG,gBAAgB,CAAC,qBAAqB;IACnE,IAAI,CAAC,qBAAqB,GAAG,gBAAgB,CAAC,qBAAqB,IAAI,CAAC;IAExE,IAAI,CAAC,kBAAkB,GACnB,gBAAgB,CAAC,kBAAkB,KAAK,KAAK,GAAG,KAAK,GAAG,IAAI;IAChE,IAAI,CAAC,eAAe,GAChB,gBAAgB,CAAC,eAAe,KAAK,IAAI,GAAG,IAAI,GAAG,KAAK;IAC5D,IAAI,CAAC,IAAI,CAAC,kBAAkB,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE;MACrD,MAAM,IAAI,KAAK,CACX,yDAAyD,GACzD,+CAA+C,CAAC;IACrD;EACH;EAEA,OAAO,GAAA;IACL,OAAO,YAAY;EACrB;EAEA;EACA,aAAa,MAAM,GAAwC;IAAA,IAAvC,gBAAA,uEAAqC,CAAA,CAAE;IACzD,IAAI,GAAG,EAAE,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;MACxB,MAAM,IAAI,KAAK,CACX,0DAA0D,CAAC;IAChE;IAED,MAAM,kBAAkB,GAAG,IAAI,kBAAkB,CAAC,gBAAgB,CAAC;IAEnE;IACA,MAAM,kBAAkB,CAAC,KAAK,EAAE;IAEhC,OAAO,kBAAkB;EAC3B;EAEA;EACA,MAAM,KAAK,GAAA;IACT,IAAI;MACF,IAAI,CAAC,MAAM,GAAG,MAAM,SAAS,CAAC,YAAY,CAAC,YAAY,CAAC;QACtD,KAAK,EAAE,IAAI,CAAC,qBAAqB,IAAI,IAAI,GAAG,IAAI,GACJ,IAAI,CAAC,qBAAqB;QACtE,KAAK,EAAE;OACR,CAAC;KACH,CAAC,OAAO,CAAC,EAAE;MACV,MAAM,IAAI,KAAK,CACX,iDAAiD,CAAC,CAAC,OAAO,EAAE,CAAC;IAClE;IAED,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;MAChB,MAAM,IAAI,KAAK,CAAC,yCAAyC,CAAC;IAC3D;IAED,MAAM,cAAc;IAChB;IACC,MAAc,CAAC,YAAY,IAAK,MAAc,CAAC,kBAAkB;IACtE,IAAI,CAAC,YAAY,GAAG,IAAI,cAAc,EAAE;IAExC,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;MACtB;MACA;MACA,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC,UAAU;KACjD,MAAM,IAAI,IAAI,CAAC,YAAY,CAAC,UAAU,KAAK,IAAI,CAAC,YAAY,EAAE;MAC7D,MAAM,IAAI,KAAK,CACX,6BAA6B,GAC7B,aAAa,IAAI,CAAC,YAAY,IAAI,GAClC,WAAW,IAAI,CAAC,YAAY,CAAC,UAAU,EAAE,CAAC;IAC/C;IAED,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC,uBAAuB,CAAC,IAAI,CAAC,MAAM,CAAC;IAC3E,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC,cAAc,EAAE;IAClD,IAAI,CAAC,QAAQ,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,GAAG,CAAC;IACxC,IAAI,CAAC,QAAQ,CAAC,qBAAqB,GAAG,IAAI,CAAC,qBAAqB;IAChE,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC;IACnC,IAAI,CAAC,QAAQ,GAAG,IAAI,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC;IAC9C,IAAI,CAAC,QAAQ,GAAG,IAAI,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC;IAC9C;EACF;EAEA,MAAM,IAAI,GAAA;IACR,IAAI,IAAI,CAAC,QAAQ,EAAE;MACjB,OAAO;QAAC,KAAK,EAAE,IAAI;QAAE,IAAI,EAAE;MAAI,CAAC;IACjC;IAED,IAAI,iBAAyB;IAC7B,IAAI,cAAsB;IAE1B,MAAM,cAAc,GAAG,MAAM,IAAI,CAAC,YAAY,EAAE;IAChD,IAAI,IAAI,CAAC,kBAAkB,EAAE;MAC3B,MAAM,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,aAAa,CAAC;MAChE,iBAAiB,GAAG,IAAI,CAAC,2BAA2B,CAChD,QAAQ,EAAE,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,oBAAoB,EAAE,CAAC,CAAC,CAAC;IAC9D;IACD,IAAI,IAAI,CAAC,eAAe,EAAE;MACxB,MAAM,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,aAAa,CAAC;MAChE,cAAc,GAAG,IAAI,CAAC,2BAA2B,CAC7C,QAAQ,EAAE,CAAC,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;IAClD;IAED,OAAO;MACL,KAAK,EAAE;QAAC,aAAa,EAAE,iBAAiB;QAAE,UAAU,EAAE;MAAc,CAAC;MACrE,IAAI,EAAE;KACP;EACH;EAEA;EACA;EACA,MAAM,OAAO,GAAA;IACX,OAAO,CAAC,MAAM,IAAI,CAAC,IAAI,EAAE,EAAE,KACoB;EACjD;EAEQ,MAAM,YAAY,GAAA;IAExB,MAAM,aAAa,GAAmB,EAAE;IACxC,MAAM,aAAa,GAAmB,EAAE;IACxC,IAAI,aAAa,GAAG,CAAC;IACrB,OAAO,IAAI,OAAO,CAAC,OAAO,IAAG;MAC3B,MAAM,UAAU,GAAG,WAAW,CAAC,MAAK;QAClC,IAAI,IAAI,CAAC,kBAAkB,EAAE;UAC3B,IAAI,CAAC,QAAQ,CAAC,qBAAqB,CAAC,IAAI,CAAC,QAAQ,CAAC;UAClD;UACA,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,EAAE;YAClC,OAAO,CAAC;cAAC,aAAa;cAAE;YAAa,CAAC,CAAC;UACxC;UACD,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,oBAAoB,CAAC,CAAC;QACtE;QACD,IAAI,IAAI,CAAC,eAAe,EAAE;UACxB,IAAI,CAAC,QAAQ,CAAC,sBAAsB,CAAC,IAAI,CAAC,QAAQ,CAAC;UACnD,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;QAC1C;QAED;QACA,IAAI,EAAE,aAAa,KAAK,IAAI,CAAC,SAAS,EAAE;UACtC,aAAa,CAAC,UAAU,CAAC;UACzB,OAAO,CAAC;YAAC,aAAa;YAAE;UAAa,CAAC,CAAC;QACxC;MACH,CAAC,EAAE,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,YAAY,GAAG,GAAG,CAAC;IAC5C,CAAC,CAAC;EACJ;EAEA;EACA,IAAI,GAAA;IACF,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;MAClB,IAAI,CAAC,QAAQ,GAAG,IAAI;MACpB,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE;MAC1B,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE;MACzB,IAAI,IAAI,CAAC,MAAM,IAAI,IAAI,IAAI,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC,MAAM,GAAG,CAAC,EAAE;QAC7D,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;MAClC;IACF;EACH;EAEA;EACA,OAAO,GAAA;IACL,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC;EACpE;EAEA;EACA,aAAa,GAAA;IACX,OAAO,IAAI,CAAC,YAAY;EAC1B;EAEQ,YAAY,CAAC,KAAqB,EAAA;IACxC,MAAM,SAAS,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM;IACjC,MAAM,QAAQ,GAAG,IAAI,YAAY,CAAC,KAAK,CAAC,MAAM,GAAG,SAAS,CAAC;IAC3D,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,CAAC,KAAK,QAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,GAAG,SAAS,CAAC,CAAC;IAC7D,OAAO,QAAQ;EACjB;EAEQ,2BAA2B,CAAC,QAAsB,EAAE,KAAe,EAAA;IAEzE,MAAM,IAAI,GAAG,IAAI,YAAY,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;IACxD;IACA,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;IACjD,OAAO,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC;EAC5B;AACD","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { env, tensor, util } from '@tensorflow/tfjs-core';\nimport { LazyIterator } from './lazy_iterator';\n/**\n * Provide a stream of tensors from microphone audio stream. The tensors are\n * representing audio data as frequency-domain spectrogram generated with\n * browser's native FFT. Tensors representing time-domain waveform is available\n * based on configuration. Only works in browser environment.\n */\nexport class MicrophoneIterator extends LazyIterator {\n    constructor(microphoneConfig) {\n        super();\n        this.microphoneConfig = microphoneConfig;\n        this.isClosed = false;\n        this.fftSize = microphoneConfig.fftSize || 1024;\n        const fftSizeLog2 = Math.log2(this.fftSize);\n        if (this.fftSize < 0 || fftSizeLog2 < 4 || fftSizeLog2 > 14 ||\n            !Number.isInteger(fftSizeLog2)) {\n            throw new Error(`Invalid fftSize: it must be a power of 2 between ` +\n                `2 to 4 and 2 to 14, but got ${this.fftSize}`);\n        }\n        this.numFrames = microphoneConfig.numFramesPerSpectrogram || 43;\n        this.sampleRateHz = microphoneConfig.sampleRateHz;\n        this.columnTruncateLength =\n            microphoneConfig.columnTruncateLength || this.fftSize;\n        this.audioTrackConstraints = microphoneConfig.audioTrackConstraints;\n        this.smoothingTimeConstant = microphoneConfig.smoothingTimeConstant || 0;\n        this.includeSpectrogram =\n            microphoneConfig.includeSpectrogram === false ? false : true;\n        this.includeWaveform =\n            microphoneConfig.includeWaveform === true ? true : false;\n        if (!this.includeSpectrogram && !this.includeWaveform) {\n            throw new Error('Both includeSpectrogram and includeWaveform are false. ' +\n                'At least one type of data should be returned.');\n        }\n    }\n    summary() {\n        return `microphone`;\n    }\n    // Construct a MicrophoneIterator and start the audio stream.\n    static async create(microphoneConfig = {}) {\n        if (env().get('IS_NODE')) {\n            throw new Error('microphone API is only supported in browser environment.');\n        }\n        const microphoneIterator = new MicrophoneIterator(microphoneConfig);\n        // Call async function start() to initialize the audio stream.\n        await microphoneIterator.start();\n        return microphoneIterator;\n    }\n    // Start the audio stream and FFT.\n    async start() {\n        try {\n            this.stream = await navigator.mediaDevices.getUserMedia({\n                audio: this.audioTrackConstraints == null ? true :\n                    this.audioTrackConstraints,\n                video: false\n            });\n        }\n        catch (e) {\n            throw new Error(`Error thrown while initializing video stream: ${e.message}`);\n        }\n        if (!this.stream) {\n            throw new Error('Could not obtain audio from microphone.');\n        }\n        const ctxConstructor = \n        // tslint:disable-next-line:no-any\n        window.AudioContext || window.webkitAudioContext;\n        this.audioContext = new ctxConstructor();\n        if (!this.sampleRateHz) {\n            // If sample rate is not provided, use the available sample rate on\n            // device.\n            this.sampleRateHz = this.audioContext.sampleRate;\n        }\n        else if (this.audioContext.sampleRate !== this.sampleRateHz) {\n            throw new Error(`Mismatch in sampling rate: ` +\n                `Expected: ${this.sampleRateHz}; ` +\n                `Actual: ${this.audioContext.sampleRate}`);\n        }\n        const streamSource = this.audioContext.createMediaStreamSource(this.stream);\n        this.analyser = this.audioContext.createAnalyser();\n        this.analyser.fftSize = this.fftSize * 2;\n        this.analyser.smoothingTimeConstant = this.smoothingTimeConstant;\n        streamSource.connect(this.analyser);\n        this.freqData = new Float32Array(this.fftSize);\n        this.timeData = new Float32Array(this.fftSize);\n        return;\n    }\n    async next() {\n        if (this.isClosed) {\n            return { value: null, done: true };\n        }\n        let spectrogramTensor;\n        let waveformTensor;\n        const audioDataQueue = await this.getAudioData();\n        if (this.includeSpectrogram) {\n            const freqData = this.flattenQueue(audioDataQueue.freqDataQueue);\n            spectrogramTensor = this.getTensorFromAudioDataArray(freqData, [this.numFrames, this.columnTruncateLength, 1]);\n        }\n        if (this.includeWaveform) {\n            const timeData = this.flattenQueue(audioDataQueue.timeDataQueue);\n            waveformTensor = this.getTensorFromAudioDataArray(timeData, [this.numFrames * this.fftSize, 1]);\n        }\n        return {\n            value: { 'spectrogram': spectrogramTensor, 'waveform': waveformTensor },\n            done: false\n        };\n    }\n    // Capture one result from the audio stream, and extract the value from\n    // iterator.next() result.\n    async capture() {\n        return (await this.next()).value;\n    }\n    async getAudioData() {\n        const freqDataQueue = [];\n        const timeDataQueue = [];\n        let currentFrames = 0;\n        return new Promise(resolve => {\n            const intervalID = setInterval(() => {\n                if (this.includeSpectrogram) {\n                    this.analyser.getFloatFrequencyData(this.freqData);\n                    // If the audio stream is initializing, return empty queue.\n                    if (this.freqData[0] === -Infinity) {\n                        resolve({ freqDataQueue, timeDataQueue });\n                    }\n                    freqDataQueue.push(this.freqData.slice(0, this.columnTruncateLength));\n                }\n                if (this.includeWaveform) {\n                    this.analyser.getFloatTimeDomainData(this.timeData);\n                    timeDataQueue.push(this.timeData.slice());\n                }\n                // Clean interval and return when all frames have been collected\n                if (++currentFrames === this.numFrames) {\n                    clearInterval(intervalID);\n                    resolve({ freqDataQueue, timeDataQueue });\n                }\n            }, this.fftSize / this.sampleRateHz * 1e3);\n        });\n    }\n    // Stop the audio stream and pause the iterator.\n    stop() {\n        if (!this.isClosed) {\n            this.isClosed = true;\n            this.analyser.disconnect();\n            this.audioContext.close();\n            if (this.stream != null && this.stream.getTracks().length > 0) {\n                this.stream.getTracks()[0].stop();\n            }\n        }\n    }\n    // Override toArray() function to prevent collecting.\n    toArray() {\n        throw new Error('Can not convert infinite audio stream to array.');\n    }\n    // Return audio sampling rate in Hz\n    getSampleRate() {\n        return this.sampleRateHz;\n    }\n    flattenQueue(queue) {\n        const frameSize = queue[0].length;\n        const freqData = new Float32Array(queue.length * frameSize);\n        queue.forEach((data, i) => freqData.set(data, i * frameSize));\n        return freqData;\n    }\n    getTensorFromAudioDataArray(freqData, shape) {\n        const vals = new Float32Array(util.sizeFromShape(shape));\n        // If the data is less than the output shape, the rest is padded with zeros.\n        vals.set(freqData, vals.length - freqData.length);\n        return tensor(vals, shape);\n    }\n}\n//# sourceMappingURL=microphone_iterator.js.map"]},"metadata":{},"sourceType":"module"}