{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer } from '@tensorflow/tfjs-core';\nexport function pool(xValues, xShape, dtype, strides, convInfo, poolType) {\n  const strideHeight = convInfo.strideHeight;\n  const strideWidth = convInfo.strideWidth;\n  const dilationHeight = convInfo.dilationHeight;\n  const dilationWidth = convInfo.dilationWidth;\n  const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  const padTop = convInfo.padInfo.top;\n  const padLeft = convInfo.padInfo.left;\n  const initialValue = poolType === 'max' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n  const output = buffer(convInfo.outShape, dtype);\n  const outputVals = output.values;\n  const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3];\n  const outputRowStrides = convInfo.outShape[2] * convInfo.outShape[3];\n  const outputColStrides = convInfo.outShape[3];\n  for (let b = 0; b < convInfo.batchSize; ++b) {\n    const outputBatchOffset = b * outputBatchStrides;\n    const inputBatchOffset = b * strides[0];\n    for (let d = 0; d < convInfo.inChannels; ++d) {\n      for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n        const xRCorner = yR * strideHeight - padTop;\n        const xRMin = Math.max(0, xRCorner);\n        const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n        const outputRowOffset = outputBatchOffset + yR * outputRowStrides;\n        for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n          const xCCorner = yC * strideWidth - padLeft;\n          const xCMin = Math.max(0, xCCorner);\n          const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n          let minMaxValue = initialValue;\n          let avgValue = 0;\n          let count = 0;\n          for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {\n            const xROffset = inputBatchOffset + xR * strides[1];\n            for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {\n              const xCOffset = xROffset + xC * strides[2];\n              const pixel = xValues[xCOffset + d];\n              if (poolType === 'max' && pixel > minMaxValue) {\n                minMaxValue = pixel;\n              } else if (poolType === 'avg') {\n                avgValue += pixel;\n                count++;\n              }\n            }\n            if (isNaN(minMaxValue)) {\n              break;\n            }\n          }\n          const outputOffset = outputRowOffset + yC * outputColStrides + d;\n          outputVals[outputOffset] = poolType === 'avg' ? avgValue / count : minMaxValue;\n        }\n      }\n    }\n  }\n  return output;\n}\nexport function maxPoolPositions(xValues, xShape, dtype, convInfo) {\n  let flattenPositions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let includeBatchInIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  const maxPositions = buffer(convInfo.outShape, 'int32');\n  const strideHeight = convInfo.strideHeight;\n  const strideWidth = convInfo.strideWidth;\n  const dilationHeight = convInfo.dilationHeight;\n  const dilationWidth = convInfo.dilationWidth;\n  const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  const padTop = convInfo.padInfo.top;\n  const padLeft = convInfo.padInfo.left;\n  const xBuf = buffer(xShape, dtype, xValues);\n  for (let b = 0; b < convInfo.batchSize; ++b) {\n    for (let d = 0; d < convInfo.inChannels; ++d) {\n      for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n        const xRCorner = yR * strideHeight - padTop;\n        let xRMin = xRCorner;\n        while (xRMin < 0) {\n          xRMin += dilationHeight;\n        }\n        // const xRMin = Math.max(0, xRCorner);\n        const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n        for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n          const xCCorner = yC * strideWidth - padLeft;\n          let xCMin = xCCorner;\n          while (xCMin < 0) {\n            xCMin += dilationWidth;\n          }\n          const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n          let maxValue = Number.NEGATIVE_INFINITY;\n          let maxPosition = -1;\n          for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {\n            const wR = xR - xRCorner;\n            for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {\n              const wC = xC - xCCorner;\n              const pixel = xBuf.get(b, xR, xC, d);\n              if (pixel > maxValue) {\n                maxValue = pixel;\n                if (flattenPositions) {\n                  maxPosition = includeBatchInIndex ? ((b * convInfo.inHeight + xR) * convInfo.inWidth + xC) * convInfo.inChannels + d : (xR * convInfo.inWidth + xC) * convInfo.inChannels + d;\n                } else {\n                  maxPosition = wR * effectiveFilterWidth + wC;\n                }\n              }\n            }\n          }\n          maxPositions.set(maxPosition, b, yR, yC, d);\n        }\n      }\n    }\n  }\n  return maxPositions;\n}\nexport function pool3d(xValues, xShape, dtype, strides, convInfo, poolType) {\n  const strideDepth = convInfo.strideDepth;\n  const strideHeight = convInfo.strideHeight;\n  const strideWidth = convInfo.strideWidth;\n  const dilationDepth = convInfo.dilationDepth;\n  const dilationHeight = convInfo.dilationHeight;\n  const dilationWidth = convInfo.dilationWidth;\n  const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n  const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  const padFront = convInfo.padInfo.front;\n  const padTop = convInfo.padInfo.top;\n  const padLeft = convInfo.padInfo.left;\n  const initialValue = poolType === 'max' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n  const output = buffer(convInfo.outShape, dtype);\n  const outputVals = output.values;\n  const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];\n  const outputDepthStrides = convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];\n  const outputRowStrides = convInfo.outShape[3] * convInfo.outShape[4];\n  const outputColStrides = convInfo.outShape[4];\n  for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n    const outputBatchOffset = batch * outputBatchStrides;\n    const inputBatchOffset = batch * strides[0];\n    for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n      for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n        const xDepthCorner = yDepth * strideDepth - padFront;\n        let xDepthMin = xDepthCorner;\n        while (xDepthMin < 0) {\n          xDepthMin += dilationDepth;\n        }\n        const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n        const outputDepthOffset = outputBatchOffset + yDepth * outputDepthStrides;\n        for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n          const xRowCorner = yRow * strideHeight - padTop;\n          let xRowMin = xRowCorner;\n          while (xRowMin < 0) {\n            xRowMin += dilationHeight;\n          }\n          const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n          const outputRowOffset = outputDepthOffset + yRow * outputRowStrides;\n          for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n            const xColCorner = yCol * strideWidth - padLeft;\n            let xColMin = xColCorner;\n            while (xColMin < 0) {\n              xColMin += dilationWidth;\n            }\n            const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);\n            // Shader code begins\n            const outputColOffset = outputRowOffset + yCol * outputColStrides;\n            let minMaxValue = initialValue;\n            let avgValue = 0;\n            let count = 0;\n            for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n              const xDepthOffset = inputBatchOffset + xDepth * strides[1];\n              for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                const xRowOffset = xDepthOffset + xRow * strides[2];\n                for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                  const xColOffset = xRowOffset + xCol * strides[3];\n                  const pixel = xValues[xColOffset + channel];\n                  if (poolType === 'max' && pixel > minMaxValue) {\n                    minMaxValue = pixel;\n                  } else if (poolType === 'avg') {\n                    avgValue += pixel;\n                    count++;\n                  }\n                  if (isNaN(minMaxValue)) {\n                    break;\n                  }\n                }\n                if (isNaN(minMaxValue)) {\n                  break;\n                }\n              }\n              if (isNaN(minMaxValue)) {\n                break;\n              }\n            }\n            const outputOffset = outputColOffset + channel;\n            outputVals[outputOffset] = poolType === 'avg' ? avgValue / count : minMaxValue;\n          }\n        }\n      }\n    }\n  }\n  return output;\n}\nexport function maxPool3dPositions(xBuf, convInfo) {\n  const maxPositions = buffer(convInfo.outShape, 'int32');\n  const strideDepth = convInfo.strideDepth;\n  const strideHeight = convInfo.strideHeight;\n  const strideWidth = convInfo.strideWidth;\n  const dilationDepth = convInfo.dilationDepth;\n  const dilationHeight = convInfo.dilationHeight;\n  const dilationWidth = convInfo.dilationWidth;\n  const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n  const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  const padFront = convInfo.padInfo.front;\n  const padTop = convInfo.padInfo.top;\n  const padLeft = convInfo.padInfo.left;\n  for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n    for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n      for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n        const xDepthCorner = yDepth * strideDepth - padFront;\n        let xDepthMin = xDepthCorner;\n        while (xDepthMin < 0) {\n          xDepthMin += dilationDepth;\n        }\n        const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n        for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n          const xRowCorner = yRow * strideHeight - padTop;\n          let xRowMin = xRowCorner;\n          while (xRowMin < 0) {\n            xRowMin += dilationHeight;\n          }\n          const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n          for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n            const xColCorner = yCol * strideWidth - padLeft;\n            let xColMin = xColCorner;\n            while (xColMin < 0) {\n              xColMin += dilationWidth;\n            }\n            const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);\n            // Shader code begins\n            let maxValue = Number.NEGATIVE_INFINITY;\n            let maxPosition = -1;\n            for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n              const wDepth = xDepth - xDepthCorner;\n              for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                const wRow = xRow - xRowCorner;\n                for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                  const wCol = xCol - xColCorner;\n                  const pixel = xBuf.get(batch, xDepth, xRow, xCol, channel);\n                  if (pixel >= maxValue) {\n                    maxValue = pixel;\n                    maxPosition = wDepth * effectiveFilterHeight * effectiveFilterWidth + wRow * effectiveFilterHeight + wCol;\n                  }\n                }\n              }\n            }\n            maxPositions.set(maxPosition, batch, yDepth, yRow, yCol, channel);\n          }\n        }\n      }\n    }\n  }\n  return maxPositions;\n}","map":{"version":3,"sources":["../../src/utils/pool_utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer } from '@tensorflow/tfjs-core';\nexport function pool(xValues, xShape, dtype, strides, convInfo, poolType) {\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const initialValue = (poolType === 'max' ? Number.NEGATIVE_INFINITY :\n        Number.POSITIVE_INFINITY);\n    const output = buffer(convInfo.outShape, dtype);\n    const outputVals = output.values;\n    const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3];\n    const outputRowStrides = convInfo.outShape[2] * convInfo.outShape[3];\n    const outputColStrides = convInfo.outShape[3];\n    for (let b = 0; b < convInfo.batchSize; ++b) {\n        const outputBatchOffset = b * outputBatchStrides;\n        const inputBatchOffset = b * strides[0];\n        for (let d = 0; d < convInfo.inChannels; ++d) {\n            for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n                const xRCorner = yR * strideHeight - padTop;\n                const xRMin = Math.max(0, xRCorner);\n                const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n                const outputRowOffset = outputBatchOffset + yR * outputRowStrides;\n                for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n                    const xCCorner = yC * strideWidth - padLeft;\n                    const xCMin = Math.max(0, xCCorner);\n                    const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n                    let minMaxValue = initialValue;\n                    let avgValue = 0;\n                    let count = 0;\n                    for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {\n                        const xROffset = inputBatchOffset + xR * strides[1];\n                        for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {\n                            const xCOffset = xROffset + xC * strides[2];\n                            const pixel = xValues[xCOffset + d];\n                            if ((poolType === 'max' && pixel > minMaxValue)) {\n                                minMaxValue = pixel;\n                            }\n                            else if (poolType === 'avg') {\n                                avgValue += pixel;\n                                count++;\n                            }\n                        }\n                        if (isNaN(minMaxValue)) {\n                            break;\n                        }\n                    }\n                    const outputOffset = outputRowOffset + yC * outputColStrides + d;\n                    outputVals[outputOffset] =\n                        poolType === 'avg' ? avgValue / count : minMaxValue;\n                }\n            }\n        }\n    }\n    return output;\n}\nexport function maxPoolPositions(xValues, xShape, dtype, convInfo, flattenPositions = false, includeBatchInIndex = false) {\n    const maxPositions = buffer(convInfo.outShape, 'int32');\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const xBuf = buffer(xShape, dtype, xValues);\n    for (let b = 0; b < convInfo.batchSize; ++b) {\n        for (let d = 0; d < convInfo.inChannels; ++d) {\n            for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n                const xRCorner = yR * strideHeight - padTop;\n                let xRMin = xRCorner;\n                while (xRMin < 0) {\n                    xRMin += dilationHeight;\n                }\n                // const xRMin = Math.max(0, xRCorner);\n                const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n                for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n                    const xCCorner = yC * strideWidth - padLeft;\n                    let xCMin = xCCorner;\n                    while (xCMin < 0) {\n                        xCMin += dilationWidth;\n                    }\n                    const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n                    let maxValue = Number.NEGATIVE_INFINITY;\n                    let maxPosition = -1;\n                    for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {\n                        const wR = xR - xRCorner;\n                        for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {\n                            const wC = xC - xCCorner;\n                            const pixel = xBuf.get(b, xR, xC, d);\n                            if (pixel > maxValue) {\n                                maxValue = pixel;\n                                if (flattenPositions) {\n                                    maxPosition = includeBatchInIndex ?\n                                        ((b * convInfo.inHeight + xR) * convInfo.inWidth + xC) *\n                                            convInfo.inChannels +\n                                            d :\n                                        (xR * convInfo.inWidth + xC) * convInfo.inChannels + d;\n                                }\n                                else {\n                                    maxPosition = wR * effectiveFilterWidth + wC;\n                                }\n                            }\n                        }\n                    }\n                    maxPositions.set(maxPosition, b, yR, yC, d);\n                }\n            }\n        }\n    }\n    return maxPositions;\n}\nexport function pool3d(xValues, xShape, dtype, strides, convInfo, poolType) {\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    const padFront = convInfo.padInfo.front;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const initialValue = (poolType === 'max' ? Number.NEGATIVE_INFINITY :\n        Number.POSITIVE_INFINITY);\n    const output = buffer(convInfo.outShape, dtype);\n    const outputVals = output.values;\n    const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] *\n        convInfo.outShape[3] * convInfo.outShape[4];\n    const outputDepthStrides = convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];\n    const outputRowStrides = convInfo.outShape[3] * convInfo.outShape[4];\n    const outputColStrides = convInfo.outShape[4];\n    for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n        const outputBatchOffset = batch * outputBatchStrides;\n        const inputBatchOffset = batch * strides[0];\n        for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n            for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n                const xDepthCorner = yDepth * strideDepth - padFront;\n                let xDepthMin = xDepthCorner;\n                while (xDepthMin < 0) {\n                    xDepthMin += dilationDepth;\n                }\n                const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n                const outputDepthOffset = outputBatchOffset + yDepth * outputDepthStrides;\n                for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n                    const xRowCorner = yRow * strideHeight - padTop;\n                    let xRowMin = xRowCorner;\n                    while (xRowMin < 0) {\n                        xRowMin += dilationHeight;\n                    }\n                    const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n                    const outputRowOffset = outputDepthOffset + yRow * outputRowStrides;\n                    for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n                        const xColCorner = yCol * strideWidth - padLeft;\n                        let xColMin = xColCorner;\n                        while (xColMin < 0) {\n                            xColMin += dilationWidth;\n                        }\n                        const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);\n                        // Shader code begins\n                        const outputColOffset = outputRowOffset + yCol * outputColStrides;\n                        let minMaxValue = initialValue;\n                        let avgValue = 0;\n                        let count = 0;\n                        for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n                            const xDepthOffset = inputBatchOffset + xDepth * strides[1];\n                            for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                                const xRowOffset = xDepthOffset + xRow * strides[2];\n                                for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                                    const xColOffset = xRowOffset + xCol * strides[3];\n                                    const pixel = xValues[xColOffset + channel];\n                                    if ((poolType === 'max' && pixel > minMaxValue)) {\n                                        minMaxValue = pixel;\n                                    }\n                                    else if (poolType === 'avg') {\n                                        avgValue += pixel;\n                                        count++;\n                                    }\n                                    if (isNaN(minMaxValue)) {\n                                        break;\n                                    }\n                                }\n                                if (isNaN(minMaxValue)) {\n                                    break;\n                                }\n                            }\n                            if (isNaN(minMaxValue)) {\n                                break;\n                            }\n                        }\n                        const outputOffset = outputColOffset + channel;\n                        outputVals[outputOffset] =\n                            poolType === 'avg' ? avgValue / count : minMaxValue;\n                    }\n                }\n            }\n        }\n    }\n    return output;\n}\nexport function maxPool3dPositions(xBuf, convInfo) {\n    const maxPositions = buffer(convInfo.outShape, 'int32');\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    const padFront = convInfo.padInfo.front;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n        for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n            for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n                const xDepthCorner = yDepth * strideDepth - padFront;\n                let xDepthMin = xDepthCorner;\n                while (xDepthMin < 0) {\n                    xDepthMin += dilationDepth;\n                }\n                const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n                for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n                    const xRowCorner = yRow * strideHeight - padTop;\n                    let xRowMin = xRowCorner;\n                    while (xRowMin < 0) {\n                        xRowMin += dilationHeight;\n                    }\n                    const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n                    for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n                        const xColCorner = yCol * strideWidth - padLeft;\n                        let xColMin = xColCorner;\n                        while (xColMin < 0) {\n                            xColMin += dilationWidth;\n                        }\n                        const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);\n                        // Shader code begins\n                        let maxValue = Number.NEGATIVE_INFINITY;\n                        let maxPosition = -1;\n                        for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n                            const wDepth = xDepth - xDepthCorner;\n                            for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                                const wRow = xRow - xRowCorner;\n                                for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                                    const wCol = xCol - xColCorner;\n                                    const pixel = xBuf.get(batch, xDepth, xRow, xCol, channel);\n                                    if (pixel >= maxValue) {\n                                        maxValue = pixel;\n                                        maxPosition =\n                                            wDepth * effectiveFilterHeight * effectiveFilterWidth +\n                                                wRow * effectiveFilterHeight + wCol;\n                                    }\n                                }\n                            }\n                        }\n                        maxPositions.set(maxPosition, batch, yDepth, yRow, yCol, channel);\n                    }\n                }\n            }\n        }\n    }\n    return maxPositions;\n}\n//# sourceMappingURL=pool_utils.js.map"]},"metadata":{},"sourceType":"module"}