{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nconst INT32_MAX = 2147483647;\nexport function raggedRangeImpl(starts, startsShape, startsDType, limits, limitsShape, deltas, deltasShape) {\n  // Check input tensor shapes.\n  if (startsShape.length > 1) {\n    throw new Error('starts must be a scalar or vector');\n  }\n  if (limitsShape.length > 1) {\n    throw new Error('limits must be a scalar or vector');\n  }\n  if (deltasShape.length > 1) {\n    throw new Error('deltas must be a scalar or vector');\n  }\n  // Determine which tensors we need to broadcast.\n  const broadcastStarts = startsShape.length === 0;\n  const broadcastLimits = limitsShape.length === 0;\n  const broadcastDeltas = deltasShape.length === 0;\n  // nRows (number of output rows) is the size of the non-broadcast inputs,\n  // or 1 if all inputs are scalars.\n  const inSizes = [];\n  if (!broadcastStarts) {\n    inSizes.push(startsShape[0]);\n  }\n  if (!broadcastLimits) {\n    inSizes.push(limitsShape[0]);\n  }\n  if (!broadcastDeltas) {\n    inSizes.push(deltasShape[0]);\n  }\n  for (let i = 1; i < inSizes.length; ++i) {\n    if (inSizes[i] !== inSizes[i - 1]) {\n      throw new Error('starts, limits, and deltas must have the same shape');\n    }\n  }\n  const nRows = inSizes.length === 0 ? 1 : inSizes[0];\n  // Construct the rtNestedSplits tensor.\n  const rtNestedSplits = util.getArrayFromDType('int32', nRows + 1);\n  rtNestedSplits[0] = 0;\n  for (let row = 0; row < nRows; ++row) {\n    const start = broadcastStarts ? starts[0] : starts[row];\n    const limit = broadcastLimits ? limits[0] : limits[row];\n    const delta = broadcastDeltas ? deltas[0] : deltas[row];\n    if (delta === 0) {\n      throw new Error('Requires delta != 0');\n    }\n    let size; // The number of elements in the specified range.\n    if (delta > 0 && limit < start || delta < 0 && limit > start) {\n      size = 0;\n    } else {\n      size = Math.ceil(Math.abs((limit - start) / delta));\n      if (size > INT32_MAX) {\n        throw new Error(`Requires ((limit - start) / delta) <= ${INT32_MAX}`);\n      }\n    }\n    rtNestedSplits[row + 1] = rtNestedSplits[row] + size;\n  }\n  const nVals = rtNestedSplits[nRows];\n  // Construct the rtDenseValues tensor.\n  const rtDenseValues = util.getArrayFromDType(startsDType, nVals);\n  let valueIndex = 0;\n  for (let row = 0; row < nRows; ++row) {\n    const rowSize = rtNestedSplits[row + 1] - rtNestedSplits[row];\n    let value = broadcastStarts ? starts[0] : starts[row];\n    const delta = broadcastDeltas ? deltas[0] : deltas[row];\n    for (let i = 0; i < rowSize; ++i) {\n      rtDenseValues[valueIndex++] = value;\n      value += delta;\n    }\n  }\n  return [rtNestedSplits, rtDenseValues];\n}","map":{"version":3,"sources":["../../../../../../tfjs-backend-cpu/src/kernels/RaggedRange_impl.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nconst INT32_MAX = 2147483647;\n\nexport function raggedRangeImpl(\n    starts: TypedArray, startsShape: number[], startsDType: DataType,\n    limits: TypedArray, limitsShape: number[], deltas: TypedArray,\n    deltasShape: number[]): [TypedArray, TypedArray] {\n  // Check input tensor shapes.\n  if (startsShape.length > 1) {\n    throw new Error('starts must be a scalar or vector');\n  }\n  if (limitsShape.length > 1) {\n    throw new Error('limits must be a scalar or vector');\n  }\n  if (deltasShape.length > 1) {\n    throw new Error('deltas must be a scalar or vector');\n  }\n\n  // Determine which tensors we need to broadcast.\n  const broadcastStarts = startsShape.length === 0;\n  const broadcastLimits = limitsShape.length === 0;\n  const broadcastDeltas = deltasShape.length === 0;\n\n  // nRows (number of output rows) is the size of the non-broadcast inputs,\n  // or 1 if all inputs are scalars.\n  const inSizes: number[] = [];\n  if (!broadcastStarts) {\n    inSizes.push(startsShape[0]);\n  }\n  if (!broadcastLimits) {\n    inSizes.push(limitsShape[0]);\n  }\n  if (!broadcastDeltas) {\n    inSizes.push(deltasShape[0]);\n  }\n\n  for (let i = 1; i < inSizes.length; ++i) {\n    if (inSizes[i] !== inSizes[i - 1]) {\n      throw new Error('starts, limits, and deltas must have the same shape');\n    }\n  }\n  const nRows = inSizes.length === 0 ? 1 : inSizes[0];\n\n  // Construct the rtNestedSplits tensor.\n  const rtNestedSplits =\n      util.getArrayFromDType('int32', nRows + 1) as TypedArray;\n  rtNestedSplits[0] = 0;\n  for (let row = 0; row < nRows; ++row) {\n    const start = broadcastStarts ? starts[0] : starts[row];\n    const limit = broadcastLimits ? limits[0] : limits[row];\n    const delta = broadcastDeltas ? deltas[0] : deltas[row];\n    if (delta === 0) {\n      throw new Error('Requires delta != 0');\n    }\n    let size: number;  // The number of elements in the specified range.\n    if (((delta > 0) && (limit < start)) || ((delta < 0) && (limit > start))) {\n      size = 0;\n    } else {\n      size = Math.ceil(Math.abs((limit - start) / delta));\n\n      if (size > INT32_MAX) {\n        throw new Error(`Requires ((limit - start) / delta) <= ${INT32_MAX}`);\n      }\n    }\n    rtNestedSplits[row + 1] = rtNestedSplits[row] + size;\n  }\n\n  const nVals = rtNestedSplits[nRows];\n\n  // Construct the rtDenseValues tensor.\n  const rtDenseValues =\n      util.getArrayFromDType(startsDType, nVals) as TypedArray;\n\n  let valueIndex = 0;\n  for (let row = 0; row < nRows; ++row) {\n    const rowSize = rtNestedSplits[row + 1] - rtNestedSplits[row];\n    let value = broadcastStarts ? starts[0] : starts[row];\n    const delta = broadcastDeltas ? deltas[0] : deltas[row];\n    for (let i = 0; i < rowSize; ++i) {\n      rtDenseValues[valueIndex++] = value;\n      value += delta;\n    }\n  }\n\n  return [rtNestedSplits, rtDenseValues];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}