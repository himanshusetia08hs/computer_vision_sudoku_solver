{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\n\n// function utils\n\n/**\n * Memoize a given function by caching the computed result.\n * The cache of a memoized function can be cleared by deleting the `cache`\n * property of the function.\n *\n * @param {function} fn                     The function to be memoized.\n *                                          Must be a pure function.\n * @param {function(args: Array)} [hasher]  A custom hash builder.\n *                                          Is JSON.stringify by default.\n * @return {function}                       Returns the memoized function\n */\nexport function memoize(fn, hasher) {\n  return function memoize() {\n    if (_typeof(memoize.cache) !== 'object') {\n      memoize.cache = {};\n    }\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n    var hash = hasher ? hasher(args) : JSON.stringify(args);\n    if (!(hash in memoize.cache)) {\n      memoize.cache[hash] = fn.apply(fn, args);\n    }\n    return memoize.cache[hash];\n  };\n}\n/**\n * Memoize a given function by caching all results and the arguments,\n * and comparing against the arguments of previous results before\n * executing again.\n * This is less performant than `memoize` which calculates a hash,\n * which is very fast to compare. Use `memoizeCompare` only when it is\n * not possible to create a unique serializable hash from the function\n * arguments.\n * The isEqual function must compare two sets of arguments\n * and return true when equal (can be a deep equality check for example).\n * @param {function} fn\n * @param {function(a: *, b: *) : boolean} isEqual\n * @returns {function}\n */\n\nexport function memoizeCompare(fn, isEqual) {\n  var memoize = function memoize() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n    for (var c = 0; c < memoize.cache.length; c++) {\n      var cached = memoize.cache[c];\n      if (isEqual(args, cached.args)) {\n        // TODO: move this cache entry to the top so recently used entries move up?\n        return cached.res;\n      }\n    }\n    var res = fn.apply(fn, args);\n    memoize.cache.unshift({\n      args: args,\n      res: res\n    });\n    return res;\n  };\n  memoize.cache = [];\n  return memoize;\n}\n/**\n * Find the maximum number of arguments expected by a typed function.\n * @param {function} fn   A typed function\n * @return {number} Returns the maximum number of expected arguments.\n *                  Returns -1 when no signatures where found on the function.\n */\n\nexport function maxArgumentCount(fn) {\n  return Object.keys(fn.signatures || {}).reduce(function (args, signature) {\n    var count = (signature.match(/,/g) || []).length + 1;\n    return Math.max(args, count);\n  }, -1);\n}","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","memoize","fn","hasher","cache","args","i","arguments","length","hash","JSON","stringify","apply","memoizeCompare","isEqual","c","cached","res","unshift","maxArgumentCount","Object","keys","signatures","reduce","signature","count","match","Math","max"],"sources":["F:/extension/SEM 7/NN/Lab/my lab/Project/temp/app/node_modules/mathjs/es/utils/function.js"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n// function utils\n\n/**\n * Memoize a given function by caching the computed result.\n * The cache of a memoized function can be cleared by deleting the `cache`\n * property of the function.\n *\n * @param {function} fn                     The function to be memoized.\n *                                          Must be a pure function.\n * @param {function(args: Array)} [hasher]  A custom hash builder.\n *                                          Is JSON.stringify by default.\n * @return {function}                       Returns the memoized function\n */\nexport function memoize(fn, hasher) {\n  return function memoize() {\n    if (_typeof(memoize.cache) !== 'object') {\n      memoize.cache = {};\n    }\n\n    var args = [];\n\n    for (var i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    var hash = hasher ? hasher(args) : JSON.stringify(args);\n\n    if (!(hash in memoize.cache)) {\n      memoize.cache[hash] = fn.apply(fn, args);\n    }\n\n    return memoize.cache[hash];\n  };\n}\n/**\n * Memoize a given function by caching all results and the arguments,\n * and comparing against the arguments of previous results before\n * executing again.\n * This is less performant than `memoize` which calculates a hash,\n * which is very fast to compare. Use `memoizeCompare` only when it is\n * not possible to create a unique serializable hash from the function\n * arguments.\n * The isEqual function must compare two sets of arguments\n * and return true when equal (can be a deep equality check for example).\n * @param {function} fn\n * @param {function(a: *, b: *) : boolean} isEqual\n * @returns {function}\n */\n\nexport function memoizeCompare(fn, isEqual) {\n  var memoize = function memoize() {\n    var args = [];\n\n    for (var i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    for (var c = 0; c < memoize.cache.length; c++) {\n      var cached = memoize.cache[c];\n\n      if (isEqual(args, cached.args)) {\n        // TODO: move this cache entry to the top so recently used entries move up?\n        return cached.res;\n      }\n    }\n\n    var res = fn.apply(fn, args);\n    memoize.cache.unshift({\n      args: args,\n      res: res\n    });\n    return res;\n  };\n\n  memoize.cache = [];\n  return memoize;\n}\n/**\n * Find the maximum number of arguments expected by a typed function.\n * @param {function} fn   A typed function\n * @return {number} Returns the maximum number of expected arguments.\n *                  Returns -1 when no signatures where found on the function.\n */\n\nexport function maxArgumentCount(fn) {\n  return Object.keys(fn.signatures || {}).reduce(function (args, signature) {\n    var count = (signature.match(/,/g) || []).length + 1;\n    return Math.max(args, count);\n  }, -1);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}