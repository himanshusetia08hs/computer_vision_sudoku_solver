{"ast":null,"code":"import { isOperatorNode } from '../../../utils/is';\nimport { factory } from '../../../utils/factory';\nimport { hasOwnProperty } from '../../../utils/object';\nvar name = 'simplifyUtil';\nvar dependencies = ['FunctionNode', 'OperatorNode', 'SymbolNode'];\nexport var createUtil = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var FunctionNode = _ref.FunctionNode,\n    OperatorNode = _ref.OperatorNode,\n    SymbolNode = _ref.SymbolNode;\n  // TODO commutative/associative properties rely on the arguments\n  // e.g. multiply is not commutative for matrices\n  // The properties should be calculated from an argument to simplify, or possibly something in math.config\n  // the other option is for typed() to specify a return type so that we can evaluate the type of arguments\n  var commutative = {\n    add: true,\n    multiply: true\n  };\n  var associative = {\n    add: true,\n    multiply: true\n  };\n  function isCommutative(node, context) {\n    if (!isOperatorNode(node)) {\n      return true;\n    }\n    var name = node.fn.toString();\n    if (context && hasOwnProperty(context, name) && hasOwnProperty(context[name], 'commutative')) {\n      return context[name].commutative;\n    }\n    return commutative[name] || false;\n  }\n  function isAssociative(node, context) {\n    if (!isOperatorNode(node)) {\n      return false;\n    }\n    var name = node.fn.toString();\n    if (context && hasOwnProperty(context, name) && hasOwnProperty(context[name], 'associative')) {\n      return context[name].associative;\n    }\n    return associative[name] || false;\n  }\n  /**\n   * Flatten all associative operators in an expression tree.\n   * Assumes parentheses have already been removed.\n   */\n\n  function flatten(node) {\n    if (!node.args || node.args.length === 0) {\n      return node;\n    }\n    node.args = allChildren(node);\n    for (var i = 0; i < node.args.length; i++) {\n      flatten(node.args[i]);\n    }\n  }\n  /**\n   * Get the children of a node as if it has been flattened.\n   * TODO implement for FunctionNodes\n   */\n\n  function allChildren(node) {\n    var op;\n    var children = [];\n    var findChildren = function findChildren(node) {\n      for (var i = 0; i < node.args.length; i++) {\n        var child = node.args[i];\n        if (isOperatorNode(child) && op === child.op) {\n          findChildren(child);\n        } else {\n          children.push(child);\n        }\n      }\n    };\n    if (isAssociative(node)) {\n      op = node.op;\n      findChildren(node);\n      return children;\n    } else {\n      return node.args;\n    }\n  }\n  /**\n   *  Unflatten all flattened operators to a right-heavy binary tree.\n   */\n\n  function unflattenr(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n    for (var i = 0; i < l; i++) {\n      unflattenr(node.args[i]);\n    }\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.pop();\n      while (node.args.length > 0) {\n        curnode = makeNode([node.args.pop(), curnode]);\n      }\n      node.args = curnode.args;\n    }\n  }\n  /**\n   *  Unflatten all flattened operators to a left-heavy binary tree.\n   */\n\n  function unflattenl(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n    for (var i = 0; i < l; i++) {\n      unflattenl(node.args[i]);\n    }\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.shift();\n      while (node.args.length > 0) {\n        curnode = makeNode([curnode, node.args.shift()]);\n      }\n      node.args = curnode.args;\n    }\n  }\n  function createMakeNodeFunction(node) {\n    if (isOperatorNode(node)) {\n      return function (args) {\n        try {\n          return new OperatorNode(node.op, node.fn, args, node.implicit);\n        } catch (err) {\n          console.error(err);\n          return [];\n        }\n      };\n    } else {\n      return function (args) {\n        return new FunctionNode(new SymbolNode(node.name), args);\n      };\n    }\n  }\n  return {\n    createMakeNodeFunction: createMakeNodeFunction,\n    isCommutative: isCommutative,\n    isAssociative: isAssociative,\n    flatten: flatten,\n    allChildren: allChildren,\n    unflattenr: unflattenr,\n    unflattenl: unflattenl\n  };\n});","map":{"version":3,"names":["isOperatorNode","factory","hasOwnProperty","name","dependencies","createUtil","_ref","FunctionNode","OperatorNode","SymbolNode","commutative","add","multiply","associative","isCommutative","node","context","fn","toString","isAssociative","flatten","args","length","allChildren","i","op","children","findChildren","child","push","unflattenr","makeNode","createMakeNodeFunction","l","curnode","pop","unflattenl","shift","implicit","err","console","error"],"sources":["F:/extension/SEM 7/NN/Lab/my lab/P/temp/app/node_modules/mathjs/es/function/algebra/simplify/util.js"],"sourcesContent":["import { isOperatorNode } from '../../../utils/is';\nimport { factory } from '../../../utils/factory';\nimport { hasOwnProperty } from '../../../utils/object';\nvar name = 'simplifyUtil';\nvar dependencies = ['FunctionNode', 'OperatorNode', 'SymbolNode'];\nexport var createUtil = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var FunctionNode = _ref.FunctionNode,\n      OperatorNode = _ref.OperatorNode,\n      SymbolNode = _ref.SymbolNode;\n  // TODO commutative/associative properties rely on the arguments\n  // e.g. multiply is not commutative for matrices\n  // The properties should be calculated from an argument to simplify, or possibly something in math.config\n  // the other option is for typed() to specify a return type so that we can evaluate the type of arguments\n  var commutative = {\n    add: true,\n    multiply: true\n  };\n  var associative = {\n    add: true,\n    multiply: true\n  };\n\n  function isCommutative(node, context) {\n    if (!isOperatorNode(node)) {\n      return true;\n    }\n\n    var name = node.fn.toString();\n\n    if (context && hasOwnProperty(context, name) && hasOwnProperty(context[name], 'commutative')) {\n      return context[name].commutative;\n    }\n\n    return commutative[name] || false;\n  }\n\n  function isAssociative(node, context) {\n    if (!isOperatorNode(node)) {\n      return false;\n    }\n\n    var name = node.fn.toString();\n\n    if (context && hasOwnProperty(context, name) && hasOwnProperty(context[name], 'associative')) {\n      return context[name].associative;\n    }\n\n    return associative[name] || false;\n  }\n  /**\n   * Flatten all associative operators in an expression tree.\n   * Assumes parentheses have already been removed.\n   */\n\n\n  function flatten(node) {\n    if (!node.args || node.args.length === 0) {\n      return node;\n    }\n\n    node.args = allChildren(node);\n\n    for (var i = 0; i < node.args.length; i++) {\n      flatten(node.args[i]);\n    }\n  }\n  /**\n   * Get the children of a node as if it has been flattened.\n   * TODO implement for FunctionNodes\n   */\n\n\n  function allChildren(node) {\n    var op;\n    var children = [];\n\n    var findChildren = function findChildren(node) {\n      for (var i = 0; i < node.args.length; i++) {\n        var child = node.args[i];\n\n        if (isOperatorNode(child) && op === child.op) {\n          findChildren(child);\n        } else {\n          children.push(child);\n        }\n      }\n    };\n\n    if (isAssociative(node)) {\n      op = node.op;\n      findChildren(node);\n      return children;\n    } else {\n      return node.args;\n    }\n  }\n  /**\n   *  Unflatten all flattened operators to a right-heavy binary tree.\n   */\n\n\n  function unflattenr(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n\n    for (var i = 0; i < l; i++) {\n      unflattenr(node.args[i]);\n    }\n\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.pop();\n\n      while (node.args.length > 0) {\n        curnode = makeNode([node.args.pop(), curnode]);\n      }\n\n      node.args = curnode.args;\n    }\n  }\n  /**\n   *  Unflatten all flattened operators to a left-heavy binary tree.\n   */\n\n\n  function unflattenl(node) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n\n    for (var i = 0; i < l; i++) {\n      unflattenl(node.args[i]);\n    }\n\n    if (l > 2 && isAssociative(node)) {\n      var curnode = node.args.shift();\n\n      while (node.args.length > 0) {\n        curnode = makeNode([curnode, node.args.shift()]);\n      }\n\n      node.args = curnode.args;\n    }\n  }\n\n  function createMakeNodeFunction(node) {\n    if (isOperatorNode(node)) {\n      return function (args) {\n        try {\n          return new OperatorNode(node.op, node.fn, args, node.implicit);\n        } catch (err) {\n          console.error(err);\n          return [];\n        }\n      };\n    } else {\n      return function (args) {\n        return new FunctionNode(new SymbolNode(node.name), args);\n      };\n    }\n  }\n\n  return {\n    createMakeNodeFunction: createMakeNodeFunction,\n    isCommutative: isCommutative,\n    isAssociative: isAssociative,\n    flatten: flatten,\n    allChildren: allChildren,\n    unflattenr: unflattenr,\n    unflattenl: unflattenl\n  };\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}