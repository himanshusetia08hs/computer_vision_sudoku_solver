{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeBilinearGrad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function resizeBilinearGrad(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    images,\n    dy\n  } = inputs;\n  const {\n    alignCorners\n  } = attrs;\n  assertNotComplex([dy, images], 'resizeBilinearGrad');\n  const imagesStrides = util.computeStrides(images.shape);\n  const [batch, xHeight, xWidth, depth] = images.shape;\n  const [, yHeight, yWidth] = dy.shape;\n  const output = new Float32Array(batch * xHeight * xWidth * depth);\n  // In the backwards pass, we want to find the pixels that were generated\n  // for each pixel in the input image the forward pass and add the\n  // corresponding coefficient from dy to the gradient (with some\n  // interpolation).\n  const effectiveXSize = [alignCorners && yHeight > 1 ? xHeight - 1 : xHeight, alignCorners && yWidth > 1 ? xWidth - 1 : xWidth];\n  const effectiveYSize = [alignCorners && yHeight > 1 ? yHeight - 1 : yHeight, alignCorners && yWidth > 1 ? yWidth - 1 : yWidth];\n  const heightScale = effectiveXSize[0] / effectiveYSize[0];\n  const widthScale = effectiveXSize[1] / effectiveYSize[1];\n  // Reference implementation\n  // tslint:disable-next-line:max-line-length\n  // https://github.com/tensorflow/tensorflow/blob/3039375c86a5bbc9610c7725dcaa95d635f87ba2/tensorflow/core/kernels/resize_bilinear_op.cc#L275\n  const dyValues = backend.data.get(dy.dataId).values;\n  let offset = 0;\n  for (let b = 0; b < batch; b++) {\n    const bOffset = b * imagesStrides[0];\n    for (let r = 0; r < yHeight; r++) {\n      const dxR = r * heightScale;\n      const topDxRIndex = Math.floor(dxR);\n      const bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);\n      const topDxROffset = bOffset + topDxRIndex * imagesStrides[1];\n      const bottomDxROffset = bOffset + bottomDxRIndex * imagesStrides[1];\n      const dxRLerp = dxR - topDxRIndex;\n      const inverseDxRLerp = 1.0 - dxRLerp;\n      for (let c = 0; c < yWidth; c++) {\n        const dxC = c * widthScale;\n        const leftDxCIndex = Math.floor(dxC);\n        const rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);\n        const dxCLerp = dxC - leftDxCIndex;\n        const inverseDxCLerp = 1.0 - dxCLerp;\n        const topLeftRCOffset = topDxROffset + leftDxCIndex * imagesStrides[2];\n        const topRightRCOffset = topDxROffset + rightDxCIndex * imagesStrides[2];\n        const bottomLeftRCOffset = bottomDxROffset + leftDxCIndex * imagesStrides[2];\n        const bottomRightRCOffset = bottomDxROffset + rightDxCIndex * imagesStrides[2];\n        const inverseDxRLerpTimesInverseDxCLerp = inverseDxRLerp * inverseDxCLerp;\n        const inverseDxRLerpTimesDxCLerp = inverseDxRLerp * dxCLerp;\n        const dxRLerpTimesInverseDxCLerp = dxRLerp * inverseDxCLerp;\n        const dxRLerpTimesDxCLerp = dxRLerp * dxCLerp;\n        for (let d = 0; d < depth; d++) {\n          const dyVal = dyValues[offset++];\n          output[topLeftRCOffset + d] += dyVal * inverseDxRLerpTimesInverseDxCLerp;\n          output[topRightRCOffset + d] += dyVal * inverseDxRLerpTimesDxCLerp;\n          output[bottomLeftRCOffset + d] += dyVal * dxRLerpTimesInverseDxCLerp;\n          output[bottomRightRCOffset + d] += dyVal * dxRLerpTimesDxCLerp;\n        }\n      }\n    }\n  }\n  return backend.makeTensorInfo([batch, xWidth, xHeight, depth], 'float32', output);\n}\nexport const resizeBilinearGradConfig = {\n  kernelName: ResizeBilinearGrad,\n  backendName: 'cpu',\n  kernelFunc: resizeBilinearGrad\n};","map":{"version":3,"sources":["../../src/kernels/ResizeBilinearGrad.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeBilinearGrad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function resizeBilinearGrad(args) {\n    const { inputs, backend, attrs } = args;\n    const { images, dy } = inputs;\n    const { alignCorners } = attrs;\n    assertNotComplex([dy, images], 'resizeBilinearGrad');\n    const imagesStrides = util.computeStrides(images.shape);\n    const [batch, xHeight, xWidth, depth] = images.shape;\n    const [, yHeight, yWidth] = dy.shape;\n    const output = new Float32Array(batch * xHeight * xWidth * depth);\n    // In the backwards pass, we want to find the pixels that were generated\n    // for each pixel in the input image the forward pass and add the\n    // corresponding coefficient from dy to the gradient (with some\n    // interpolation).\n    const effectiveXSize = [\n        (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n        (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n    ];\n    const effectiveYSize = [\n        (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n        (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n    ];\n    const heightScale = effectiveXSize[0] / effectiveYSize[0];\n    const widthScale = effectiveXSize[1] / effectiveYSize[1];\n    // Reference implementation\n    // tslint:disable-next-line:max-line-length\n    // https://github.com/tensorflow/tensorflow/blob/3039375c86a5bbc9610c7725dcaa95d635f87ba2/tensorflow/core/kernels/resize_bilinear_op.cc#L275\n    const dyValues = backend.data.get(dy.dataId).values;\n    let offset = 0;\n    for (let b = 0; b < batch; b++) {\n        const bOffset = b * imagesStrides[0];\n        for (let r = 0; r < yHeight; r++) {\n            const dxR = r * heightScale;\n            const topDxRIndex = Math.floor(dxR);\n            const bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);\n            const topDxROffset = bOffset + topDxRIndex * imagesStrides[1];\n            const bottomDxROffset = bOffset + bottomDxRIndex * imagesStrides[1];\n            const dxRLerp = dxR - topDxRIndex;\n            const inverseDxRLerp = 1.0 - dxRLerp;\n            for (let c = 0; c < yWidth; c++) {\n                const dxC = c * widthScale;\n                const leftDxCIndex = Math.floor(dxC);\n                const rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);\n                const dxCLerp = dxC - leftDxCIndex;\n                const inverseDxCLerp = 1.0 - dxCLerp;\n                const topLeftRCOffset = topDxROffset + leftDxCIndex * imagesStrides[2];\n                const topRightRCOffset = topDxROffset + rightDxCIndex * imagesStrides[2];\n                const bottomLeftRCOffset = bottomDxROffset + leftDxCIndex * imagesStrides[2];\n                const bottomRightRCOffset = bottomDxROffset + rightDxCIndex * imagesStrides[2];\n                const inverseDxRLerpTimesInverseDxCLerp = inverseDxRLerp * inverseDxCLerp;\n                const inverseDxRLerpTimesDxCLerp = inverseDxRLerp * dxCLerp;\n                const dxRLerpTimesInverseDxCLerp = dxRLerp * inverseDxCLerp;\n                const dxRLerpTimesDxCLerp = dxRLerp * dxCLerp;\n                for (let d = 0; d < depth; d++) {\n                    const dyVal = dyValues[offset++];\n                    output[topLeftRCOffset + d] +=\n                        dyVal * inverseDxRLerpTimesInverseDxCLerp;\n                    output[topRightRCOffset + d] += dyVal * inverseDxRLerpTimesDxCLerp;\n                    output[bottomLeftRCOffset + d] += dyVal * dxRLerpTimesInverseDxCLerp;\n                    output[bottomRightRCOffset + d] += dyVal * dxRLerpTimesDxCLerp;\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo([batch, xWidth, xHeight, depth], 'float32', output);\n}\nexport const resizeBilinearGradConfig = {\n    kernelName: ResizeBilinearGrad,\n    backendName: 'cpu',\n    kernelFunc: resizeBilinearGrad\n};\n//# sourceMappingURL=ResizeBilinearGrad.js.map"]},"metadata":{},"sourceType":"module"}