{"ast":null,"code":"/**\n * @license\n * Copyright 2022 CodeSmith LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { Layer } from '../../engine/topology';\nimport { serialization, tidy } from '@tensorflow/tfjs-core';\nimport { greater, greaterEqual, max, min } from '@tensorflow/tfjs-core';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../../utils/types_utils';\nimport { ValueError } from '../../errors';\nimport * as K from '../../backend/tfjs_backend';\nimport * as utils from './preprocessing_utils';\nexport class CategoryEncoding extends Layer {\n  constructor(args) {\n    super(args);\n    this.numTokens = args.numTokens;\n    if (args.outputMode) {\n      this.outputMode = args.outputMode;\n    } else {\n      this.outputMode = 'multiHot';\n    }\n  }\n  getConfig() {\n    const config = {\n      'numTokens': this.numTokens,\n      'outputMode': this.outputMode\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    if (inputShape == null) {\n      return [this.numTokens];\n    }\n    if (this.outputMode === 'oneHot' && inputShape[inputShape.length - 1] !== 1) {\n      inputShape.push(this.numTokens);\n      return inputShape;\n    }\n    inputShape[inputShape.length - 1] = this.numTokens;\n    return inputShape;\n  }\n  call(inputs, kwargs) {\n    return tidy(() => {\n      inputs = getExactlyOneTensor(inputs);\n      if (inputs.dtype !== 'int32') {\n        inputs = K.cast(inputs, 'int32');\n      }\n      let countWeights;\n      if (typeof kwargs['countWeights'] !== 'undefined') {\n        if (this.outputMode !== 'count') {\n          throw new ValueError(`countWeights is not used when outputMode !== count.\n              Received countWeights=${kwargs['countWeights']}`);\n        }\n        countWeights = getExactlyOneTensor(kwargs['countWeights']);\n      }\n      const maxValue = max(inputs);\n      const minValue = min(inputs);\n      const greaterEqualMax = greater(this.numTokens, maxValue).bufferSync().get(0);\n      const greaterMin = greaterEqual(minValue, 0).bufferSync().get(0);\n      if (!(greaterEqualMax && greaterMin)) {\n        throw new ValueError('Input values must be between 0 < values <=' + ` numTokens with numTokens=${this.numTokens}`);\n      }\n      return utils.encodeCategoricalInputs(inputs, this.outputMode, this.numTokens, countWeights);\n    });\n  }\n}\n/** @nocollapse */\nCategoryEncoding.className = 'CategoryEncoding';\nserialization.registerClass(CategoryEncoding);","map":{"version":3,"sources":["../../../../../../../tfjs-layers/src/layers/preprocessing/category_encoding.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2022 CodeSmith LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\nimport { LayerArgs, Layer } from '../../engine/topology';\nimport { serialization, Tensor, tidy, Tensor1D, Tensor2D} from '@tensorflow/tfjs-core';\nimport { greater, greaterEqual, max, min} from '@tensorflow/tfjs-core';\nimport { Shape } from '../../keras_format/common';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../../utils/types_utils';\nimport { Kwargs } from '../../types';\nimport { ValueError } from '../../errors';\nimport * as K from '../../backend/tfjs_backend';\nimport * as utils from './preprocessing_utils';\nimport { OutputMode } from './preprocessing_utils';\n\nexport declare interface CategoryEncodingArgs extends LayerArgs {\n  numTokens: number;\n  outputMode?: OutputMode;\n }\n\nexport class CategoryEncoding extends Layer {\n  /** @nocollapse */\n  static className = 'CategoryEncoding';\n  private readonly numTokens: number;\n  private readonly outputMode: OutputMode;\n\n  constructor(args: CategoryEncodingArgs) {\n    super(args);\n    this.numTokens = args.numTokens;\n\n    if(args.outputMode) {\n    this.outputMode = args.outputMode;\n    } else {\n      this.outputMode = 'multiHot';\n    }\n  }\n\n  override getConfig(): serialization.ConfigDict {\n    const config: serialization.ConfigDict = {\n      'numTokens': this.numTokens,\n      'outputMode': this.outputMode,\n    };\n\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n  override computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    inputShape = getExactlyOneShape(inputShape);\n\n    if(inputShape == null) {\n      return [this.numTokens];\n    }\n\n    if(this.outputMode === 'oneHot' && inputShape[inputShape.length - 1] !== 1){\n      inputShape.push(this.numTokens);\n      return inputShape;\n    }\n\n    inputShape[inputShape.length - 1] = this.numTokens;\n    return inputShape;\n  }\n\n  override call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor[]|Tensor {\n    return tidy(() => {\n\n        inputs = getExactlyOneTensor(inputs);\n        if(inputs.dtype !== 'int32') {\n          inputs = K.cast(inputs, 'int32');\n      }\n\n        let countWeights: Tensor1D | Tensor2D;\n\n        if((typeof kwargs['countWeights']) !== 'undefined') {\n\n          if(this.outputMode !== 'count') {\n            throw new ValueError(\n              `countWeights is not used when outputMode !== count.\n              Received countWeights=${kwargs['countWeights']}`);\n          }\n\n          countWeights\n            =  getExactlyOneTensor(kwargs['countWeights']) as Tensor1D|Tensor2D;\n        }\n\n        const maxValue = max(inputs);\n        const minValue = min(inputs);\n        const greaterEqualMax = greater(this.numTokens, maxValue)\n                                                    .bufferSync().get(0);\n\n        const greaterMin = greaterEqual(minValue, 0).bufferSync().get(0);\n\n        if(!(greaterEqualMax && greaterMin)) {\n\n          throw new ValueError('Input values must be between 0 < values <='\n            + ` numTokens with numTokens=${this.numTokens}`);\n        }\n\n        return utils.encodeCategoricalInputs(inputs,\n          this.outputMode, this.numTokens, countWeights);\n    });\n  }\n}\n\nserialization.registerClass(CategoryEncoding);\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}