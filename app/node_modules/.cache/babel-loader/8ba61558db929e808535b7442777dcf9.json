{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Sum, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { zeros } from '../utils/zeros_impl';\nimport { cast } from './Cast';\nimport { identity } from './Identity';\nimport { reshape } from './Reshape';\nimport { transpose } from './Transpose';\nexport function sum(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    x\n  } = inputs;\n  const {\n    axis,\n    keepDims\n  } = attrs;\n  assertNotComplex(x, 'sum');\n  let $x;\n  if (x.dtype === 'bool') {\n    $x = cast({\n      inputs: {\n        x\n      },\n      backend,\n      attrs: {\n        dtype: 'int32'\n      }\n    });\n  } else {\n    $x = identity({\n      inputs: {\n        x\n      },\n      backend\n    });\n  }\n  const xRank = $x.shape.length;\n  const axes = util.parseAxisParam(axis, $x.shape);\n  const permutation = backend_util.getAxesPermutation(axes, xRank);\n  let reductionAxes = axes;\n  let permutedX = $x;\n  if (permutation != null) {\n    permutedX = transpose({\n      inputs: {\n        x: $x\n      },\n      backend,\n      attrs: {\n        perm: permutation\n      }\n    });\n    reductionAxes = backend_util.getInnerMostAxes(reductionAxes.length, xRank);\n  }\n  backend_util.assertAxesAreInnerMostDims('sum', reductionAxes, permutedX.shape.length);\n  const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(permutedX.shape, reductionAxes);\n  const resultDtype = backend_util.upcastType(permutedX.dtype, 'int32');\n  let result = zeros(backend, outShape, resultDtype);\n  const reduceSize = util.sizeFromShape(reduceShape);\n  const vals = backend.data.get(result.dataId).values;\n  const aVals = backend.data.get(permutedX.dataId).values;\n  for (let i = 0; i < vals.length; ++i) {\n    const offset = i * reduceSize;\n    let sum = 0;\n    for (let j = 0; j < reduceSize; ++j) {\n      sum += aVals[offset + j];\n    }\n    vals[i] = sum;\n  }\n  if (keepDims) {\n    const newShape = backend_util.expandShapeToKeepDim(result.shape, axes);\n    const oldResult = result;\n    result = reshape({\n      inputs: {\n        x: result\n      },\n      backend,\n      attrs: {\n        shape: newShape\n      }\n    });\n    backend.disposeIntermediateTensorInfo(oldResult);\n  }\n  backend.disposeIntermediateTensorInfo($x);\n  if (permutation != null) {\n    backend.disposeIntermediateTensorInfo(permutedX);\n  }\n  return result;\n}\nexport const sumConfig = {\n  kernelName: Sum,\n  backendName: 'cpu',\n  kernelFunc: sum\n};","map":{"version":3,"sources":["../../../../../../tfjs-backend-cpu/src/kernels/Sum.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, KernelFunc, Sum, SumAttrs, SumInputs, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\nimport {zeros} from '../utils/zeros_impl';\nimport {cast} from './Cast';\nimport {identity} from './Identity';\nimport {reshape} from './Reshape';\nimport {transpose} from './Transpose';\n\nexport function sum(\n    args: {inputs: SumInputs, backend: MathBackendCPU, attrs: SumAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis, keepDims} = attrs;\n\n  assertNotComplex(x, 'sum');\n\n  let $x;\n  if (x.dtype === 'bool') {\n    $x = cast({inputs: {x}, backend, attrs: {dtype: 'int32'}});\n  } else {\n    $x = identity({inputs: {x}, backend});\n  }\n\n  const xRank = $x.shape.length;\n  const axes = util.parseAxisParam(axis, $x.shape);\n  const permutation = backend_util.getAxesPermutation(axes, xRank);\n\n  let reductionAxes = axes;\n  let permutedX = $x;\n  if (permutation != null) {\n    permutedX =\n        transpose({inputs: {x: $x}, backend, attrs: {perm: permutation}});\n    reductionAxes = backend_util.getInnerMostAxes(reductionAxes.length, xRank);\n  }\n\n  backend_util.assertAxesAreInnerMostDims(\n      'sum', reductionAxes, permutedX.shape.length);\n\n  const [outShape, reduceShape] =\n      backend_util.computeOutAndReduceShapes(permutedX.shape, reductionAxes);\n  const resultDtype = backend_util.upcastType(permutedX.dtype, 'int32');\n  let result = zeros(backend, outShape, resultDtype);\n  const reduceSize = util.sizeFromShape(reduceShape);\n  const vals = backend.data.get(result.dataId).values as TypedArray;\n\n  const aVals = backend.data.get(permutedX.dataId).values as TypedArray;\n  for (let i = 0; i < vals.length; ++i) {\n    const offset = i * reduceSize;\n    let sum = 0;\n    for (let j = 0; j < reduceSize; ++j) {\n      sum += aVals[offset + j];\n    }\n    vals[i] = sum;\n  }\n\n  if (keepDims) {\n    const newShape = backend_util.expandShapeToKeepDim(result.shape, axes);\n    const oldResult = result;\n    result = reshape({inputs: {x: result}, backend, attrs: {shape: newShape}});\n    backend.disposeIntermediateTensorInfo(oldResult);\n  }\n\n  backend.disposeIntermediateTensorInfo($x);\n\n  if (permutation != null) {\n    backend.disposeIntermediateTensorInfo(permutedX);\n  }\n\n  return result;\n}\n\nexport const sumConfig: KernelConfig = {\n  kernelName: Sum,\n  backendName: 'cpu',\n  kernelFunc: sum as {} as KernelFunc\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}