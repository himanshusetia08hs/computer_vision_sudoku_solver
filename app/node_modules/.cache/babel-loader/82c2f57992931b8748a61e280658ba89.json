{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original source: keras/callbacks.py */\nimport { add, div, keep, mul, nextFrame, tidy, util } from '@tensorflow/tfjs-core';\nimport { ValueError } from './errors';\nimport { resolveScalarsInLogs } from './logs';\nimport * as generic_utils from './utils/generic_utils';\n/** Verbosity logging level when fitting a model. */\nexport var ModelLoggingVerbosity;\n(function (ModelLoggingVerbosity) {\n  ModelLoggingVerbosity[ModelLoggingVerbosity[\"SILENT\"] = 0] = \"SILENT\";\n  ModelLoggingVerbosity[ModelLoggingVerbosity[\"VERBOSE\"] = 1] = \"VERBOSE\";\n})(ModelLoggingVerbosity || (ModelLoggingVerbosity = {}));\n/** How often to yield to the main thread when training (in ms). */\nexport const DEFAULT_YIELD_EVERY_MS = 125;\n/**\n * Abstract base class used to build new callbacks.\n *\n * The `logs` dictionary that callback methods take as argument will contain\n * keys for quantities relevant to the current batch or epoch.\n *\n * Currently, the `.fit()` method of the `Sequential` model class\n * will include the following quantities in the `logs` that\n * it passes to its callbacks:\n *\n * onEpochEnd: Logs include `acc` and `loss`, and optionally include `valLoss`\n *   (if validation is enabled in `fit`), and `valAcc` (if validation and\n *   accuracy monitoring are enabled).\n * onBatchBegin: Logs include `size`, the number of samples in the current\n *   batch.\n * onBatchEnd: Logs include `loss`, and optionally `acc` (if accuracy monitoring\n *   is enabled).\n */\nexport class BaseCallback {\n  constructor() {\n    // TODO(michaelterry): This type is a best guess.\n    this.validationData = null;\n  }\n  setParams(params) {\n    this.params = params;\n  }\n  async onEpochBegin(epoch, logs) {}\n  async onEpochEnd(epoch, logs) {}\n  async onBatchBegin(batch, logs) {}\n  async onBatchEnd(batch, logs) {}\n  async onTrainBegin(logs) {}\n  async onTrainEnd(logs) {}\n  // LayersModel needs to call Callback.setModel(), but cannot actually depend\n  // on Callback because that creates a cyclic dependency.  Providing this no-op\n  // method on BaseCallback breaks the cycle: this way LayersModel can depend on\n  // BaseCallback but not on Callback.  The argument is typed as `Container`\n  // (the superclass of LayersModel) to avoid recapitulating the cycle. Callback\n  // overrides this method and enforces that the argument is really a\n  // LayersModel.\n  setModel(model) {\n    // Do nothing. Use Callback instead of BaseCallback to track the model.\n  }\n}\n/**\n * Container abstracting a list of callbacks.\n */\nexport class CallbackList {\n  // TODO(cais): When the need arises, uncomment the following lines and\n  // implement the queue for time values.\n  // private deltaTBatch: number;\n  // private deltaTsBatchBegin: Array<number>;\n  // private deltaTsBatchEnd: Array<number>;\n  /**\n   * Constructor of CallbackList.\n   * @param callbacks Array of `Callback` instances.\n   * @param queueLength Queue length for keeping running statistics over\n   *   callback execution time.\n   */\n  constructor(callbacks) {\n    let queueLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n    // TODO(cais): Make use of queueLength when implementing the queue for time\n    // values.\n    if (callbacks == null) {\n      callbacks = [];\n    }\n    this.callbacks = callbacks;\n    this.queueLength = queueLength;\n  }\n  append(callback) {\n    this.callbacks.push(callback);\n  }\n  setParams(params) {\n    for (const callback of this.callbacks) {\n      callback.setParams(params);\n    }\n  }\n  setModel(model) {\n    for (const callback of this.callbacks) {\n      callback.setModel(model);\n    }\n  }\n  /**\n   * Called at the start of an epoch.\n   * @param epoch Index of epoch.\n   * @param logs Dictionary of logs.\n   */\n  async onEpochBegin(epoch, logs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onEpochBegin(epoch, logs);\n    }\n  }\n  /**\n   * Called at the end of an epoch.\n   * @param epoch Index of epoch.\n   * @param logs Dictionary of logs.\n   */\n  async onEpochEnd(epoch, logs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onEpochEnd(epoch, logs);\n    }\n  }\n  /**\n   * Called  right before processing a batch.\n   * @param batch Index of batch within the current epoch.\n   * @param logs Dictionary of logs.\n   */\n  async onBatchBegin(batch, logs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onBatchBegin(batch, logs);\n    }\n  }\n  /**\n   * Called at the end of a batch.\n   * @param batch Index of batch within the current epoch.\n   * @param logs Dictionary of logs.\n   */\n  async onBatchEnd(batch, logs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onBatchEnd(batch, logs);\n    }\n  }\n  /**\n   * Called at the beginning of training.\n   * @param logs Dictionary of logs.\n   */\n  async onTrainBegin(logs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onTrainBegin(logs);\n    }\n  }\n  /**\n   * Called at the end of training.\n   * @param logs Dictionary of logs.\n   */\n  async onTrainEnd(logs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onTrainEnd(logs);\n    }\n  }\n}\n/**\n * Callback that accumulates epoch averages of metrics.\n *\n * This callback is automatically applied to every LayersModel.\n */\nexport class BaseLogger extends BaseCallback {\n  constructor() {\n    super();\n  }\n  async onEpochBegin(epoch) {\n    this.seen = 0;\n    this.totals = {};\n  }\n  async onBatchEnd(batch, logs) {\n    if (logs == null) {\n      logs = {};\n    }\n    const batchSize = logs['size'] == null ? 0 : logs['size'];\n    this.seen += batchSize;\n    for (const key in logs) {\n      const value = logs[key];\n      if (typeof value === 'number') {\n        if (!this.totals.hasOwnProperty(key)) {\n          this.totals[key] = 0;\n        }\n        this.totals[key] = this.totals[key] + value * batchSize;\n      } else {\n        let oldTotalsToDispose;\n        if (key in this.totals) {\n          oldTotalsToDispose = this.totals[key];\n        } else {\n          this.totals[key] = 0;\n        }\n        const total = tidy(() => add(this.totals[key], mul(value, batchSize)));\n        this.totals[key] = total;\n        if (oldTotalsToDispose != null) {\n          oldTotalsToDispose.dispose();\n        }\n      }\n    }\n  }\n  async onEpochEnd(epoch, logs) {\n    if (logs != null) {\n      for (const key of this.params['metrics']) {\n        if (this.totals[key] == null) {\n          continue;\n        }\n        if (typeof this.totals[key] === 'number') {\n          logs[key] = this.totals[key] / this.seen;\n        } else {\n          tidy(() => {\n            const log = mul(div(1, this.seen), this.totals[key]);\n            logs[key] = log;\n            this.totals[key].dispose();\n            keep(logs[key]);\n          });\n        }\n      }\n    }\n  }\n}\n/**\n * Callback that records events into a `History` object. This callback is\n * automatically applied to every TF.js Layers model. The `History` object\n * gets returned by the `fit` method of models.\n */\nexport class History extends BaseCallback {\n  async onTrainBegin(logs) {\n    this.epoch = [];\n    this.history = {};\n  }\n  async onEpochEnd(epoch, logs) {\n    if (logs == null) {\n      logs = {};\n    }\n    this.epoch.push(epoch);\n    for (const key in logs) {\n      if (this.history[key] == null) {\n        this.history[key] = [];\n      }\n      this.history[key].push(logs[key]);\n    }\n  }\n  /**\n   * Await the values of all losses and metrics.\n   */\n  async syncData() {\n    const promises = [];\n    const keys = [];\n    const indices = [];\n    for (const key in this.history) {\n      const valueArray = this.history[key];\n      for (let i = 0; i < valueArray.length; ++i) {\n        if (typeof valueArray[i] !== 'number') {\n          const valueScalar = valueArray[i];\n          promises.push(valueScalar.data());\n          keys.push(key);\n          indices.push(i);\n        }\n      }\n    }\n    const values = await Promise.all(promises);\n    for (let n = 0; n < values.length; ++n) {\n      const tensorToDispose = this.history[keys[n]][indices[n]];\n      tensorToDispose.dispose();\n      this.history[keys[n]][indices[n]] = values[n][0];\n    }\n  }\n}\n/**\n * Custom callback for training.\n */\nexport class CustomCallback extends BaseCallback {\n  constructor(args, yieldEvery) {\n    super();\n    this.currentEpoch = 0;\n    this.nowFunc = args.nowFunc;\n    this.nextFrameFunc = args.nextFrameFunc || nextFrame;\n    this.yieldEvery = yieldEvery || 'auto';\n    if (this.yieldEvery === 'auto') {\n      this.yieldEvery = DEFAULT_YIELD_EVERY_MS;\n    }\n    if (this.yieldEvery === 'never' && args.onYield != null) {\n      throw new Error('yieldEvery is `never` but you provided an `onYield` callback. ' + 'Either change `yieldEvery` or remove the callback');\n    }\n    if (util.isNumber(this.yieldEvery)) {\n      // Decorate `maybeWait` so it will be called at most once every\n      // `yieldEvery` ms.\n      this.maybeWait = generic_utils.debounce(this.maybeWait.bind(this), this.yieldEvery, this.nowFunc);\n    }\n    this.trainBegin = args.onTrainBegin;\n    this.trainEnd = args.onTrainEnd;\n    this.epochBegin = args.onEpochBegin;\n    this.epochEnd = args.onEpochEnd;\n    this.batchBegin = args.onBatchBegin;\n    this.batchEnd = args.onBatchEnd;\n    this.yield = args.onYield;\n  }\n  async maybeWait(epoch, batch, logs) {\n    const ps = [];\n    if (this.yield != null) {\n      await resolveScalarsInLogs(logs);\n      ps.push(this.yield(epoch, batch, logs));\n    }\n    ps.push(this.nextFrameFunc());\n    await Promise.all(ps);\n  }\n  async onEpochBegin(epoch, logs) {\n    this.currentEpoch = epoch;\n    if (this.epochBegin != null) {\n      await resolveScalarsInLogs(logs);\n      await this.epochBegin(epoch, logs);\n    }\n  }\n  async onEpochEnd(epoch, logs) {\n    const ps = [];\n    if (this.epochEnd != null) {\n      await resolveScalarsInLogs(logs);\n      ps.push(this.epochEnd(epoch, logs));\n    }\n    if (this.yieldEvery === 'epoch') {\n      ps.push(this.nextFrameFunc());\n    }\n    await Promise.all(ps);\n  }\n  async onBatchBegin(batch, logs) {\n    if (this.batchBegin != null) {\n      await resolveScalarsInLogs(logs);\n      await this.batchBegin(batch, logs);\n    }\n  }\n  async onBatchEnd(batch, logs) {\n    const ps = [];\n    if (this.batchEnd != null) {\n      await resolveScalarsInLogs(logs);\n      ps.push(this.batchEnd(batch, logs));\n    }\n    if (this.yieldEvery === 'batch') {\n      ps.push(this.nextFrameFunc());\n    } else if (util.isNumber(this.yieldEvery)) {\n      ps.push(this.maybeWait(this.currentEpoch, batch, logs));\n    }\n    await Promise.all(ps);\n  }\n  async onTrainBegin(logs) {\n    if (this.trainBegin != null) {\n      await resolveScalarsInLogs(logs);\n      await this.trainBegin(logs);\n    }\n  }\n  async onTrainEnd(logs) {\n    if (this.trainEnd != null) {\n      await resolveScalarsInLogs(logs);\n      await this.trainEnd(logs);\n    }\n  }\n}\n/**\n * Standardize callbacks or configurations of them to an Array of callbacks.\n */\nexport function standardizeCallbacks(callbacks, yieldEvery) {\n  if (callbacks == null) {\n    callbacks = {};\n  }\n  if (callbacks instanceof BaseCallback) {\n    return [callbacks];\n  }\n  if (Array.isArray(callbacks) && callbacks[0] instanceof BaseCallback) {\n    return callbacks;\n  }\n  // Convert custom callback configs to custom callback objects.\n  const callbackConfigs = generic_utils.toList(callbacks);\n  return callbackConfigs.map(callbackConfig => new CustomCallback(callbackConfig, yieldEvery));\n}\n/**\n * A global registry for callback constructors to be used during\n * LayersModel.fit().\n */\nexport class CallbackConstructorRegistry {\n  /**\n   * Blocks public access to constructor.\n   */\n  constructor() {}\n  /**\n   * Register a tf.LayersModel.fit() callback constructor.\n   *\n   * The registered callback constructor will be used to instantiate\n   * callbacks for every tf.LayersModel.fit() call afterwards.\n   *\n   * @param verbosityLevel Level of verbosity at which the `callbackConstructor`\n   *   is to be reigstered.\n   * @param callbackConstructor A no-arg constructor for `tf.Callback`.\n   * @throws Error, if the same callbackConstructor has been registered before,\n   *   either at the same or a different `verbosityLevel`.\n   */\n  static registerCallbackConstructor(verbosityLevel, callbackConstructor) {\n    util.assert(verbosityLevel >= 0 && Number.isInteger(verbosityLevel), () => `Verbosity level is expected to be an integer >= 0, ` + `but got ${verbosityLevel}`);\n    CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);\n    if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {\n      CallbackConstructorRegistry.constructors[verbosityLevel] = [];\n    }\n    CallbackConstructorRegistry.constructors[verbosityLevel].push(callbackConstructor);\n  }\n  static checkForDuplicate(callbackConstructor) {\n    for (const levelName in CallbackConstructorRegistry.constructors) {\n      const constructors = CallbackConstructorRegistry.constructors[+levelName];\n      constructors.forEach(ctor => {\n        if (ctor === callbackConstructor) {\n          throw new ValueError('Duplicate callback constructor.');\n        }\n      });\n    }\n  }\n  /**\n   * Clear all registered callback constructors.\n   */\n  static clear() {\n    CallbackConstructorRegistry.constructors = {};\n  }\n  /**\n   * Create callbacks using the registered callback constructors.\n   *\n   * Given `verbosityLevel`, all constructors registered at that level or above\n   * will be called and the instantiated callbacks will be used.\n   *\n   * @param verbosityLevel: Level of verbosity.\n   */\n  static createCallbacks(verbosityLevel) {\n    const constructors = [];\n    for (const levelName in CallbackConstructorRegistry.constructors) {\n      const level = +levelName;\n      if (verbosityLevel >= level) {\n        constructors.push(...CallbackConstructorRegistry.constructors[level]);\n      }\n    }\n    return constructors.map(ctor => new ctor());\n  }\n}\nCallbackConstructorRegistry.constructors = {};\nexport function configureCallbacks(callbacks, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics) {\n  const history = new History();\n  const actualCallbacks = [new BaseLogger(), ...CallbackConstructorRegistry.createCallbacks(verbose)];\n  if (callbacks != null) {\n    actualCallbacks.push(...callbacks);\n  }\n  actualCallbacks.push(history);\n  const callbackList = new CallbackList(actualCallbacks);\n  // TODO(cais): Figure out when this LayersModel instance can have a\n  // dynamically\n  //   set property called 'callback_model' as in PyKeras.\n  callbackList.setParams({\n    epochs,\n    initialEpoch,\n    samples: numTrainSamples,\n    steps: stepsPerEpoch,\n    batchSize,\n    verbose,\n    doValidation,\n    metrics: callbackMetrics\n  });\n  return {\n    callbackList,\n    history\n  };\n}","map":{"version":3,"sources":["../../../../../tfjs-layers/src/base_callbacks.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/* Original source: keras/callbacks.py */\n\nimport {add, div, keep, mul, nextFrame, Scalar, Tensor, tidy, util} from '@tensorflow/tfjs-core';\n\nimport {Container} from './engine/container';\nimport {ValueError} from './errors';\nimport {Logs, resolveScalarsInLogs, UnresolvedLogs} from './logs';\nimport * as generic_utils from './utils/generic_utils';\n\n/** Verbosity logging level when fitting a model. */\nexport enum ModelLoggingVerbosity {\n  SILENT = 0,\n  VERBOSE = 1\n}\n\n/** How often to yield to the main thread when training (in ms). */\nexport const DEFAULT_YIELD_EVERY_MS = 125;\n\nexport type Params = {\n  [key: string]: number|string|boolean|number[]|string[]|boolean[];\n};\n\nexport type YieldEveryOptions = 'auto'|'batch'|'epoch'|'never'|number;\n\n/**\n * Abstract base class used to build new callbacks.\n *\n * The `logs` dictionary that callback methods take as argument will contain\n * keys for quantities relevant to the current batch or epoch.\n *\n * Currently, the `.fit()` method of the `Sequential` model class\n * will include the following quantities in the `logs` that\n * it passes to its callbacks:\n *\n * onEpochEnd: Logs include `acc` and `loss`, and optionally include `valLoss`\n *   (if validation is enabled in `fit`), and `valAcc` (if validation and\n *   accuracy monitoring are enabled).\n * onBatchBegin: Logs include `size`, the number of samples in the current\n *   batch.\n * onBatchEnd: Logs include `loss`, and optionally `acc` (if accuracy monitoring\n *   is enabled).\n */\nexport abstract class BaseCallback {\n  // TODO(michaelterry): This type is a best guess.\n  validationData: Tensor|Tensor[] = null;\n  /**\n   * Training parameters (eg. verbosity, batch size, number of epochs...).\n   */\n  params: Params;\n\n  setParams(params: Params): void {\n    this.params = params;\n  }\n\n  async onEpochBegin(epoch: number, logs?: UnresolvedLogs) {}\n\n  async onEpochEnd(epoch: number, logs?: UnresolvedLogs) {}\n\n  async onBatchBegin(batch: number, logs?: UnresolvedLogs) {}\n\n  async onBatchEnd(batch: number, logs?: UnresolvedLogs) {}\n\n  async onTrainBegin(logs?: UnresolvedLogs) {}\n\n  async onTrainEnd(logs?: UnresolvedLogs) {}\n\n  // LayersModel needs to call Callback.setModel(), but cannot actually depend\n  // on Callback because that creates a cyclic dependency.  Providing this no-op\n  // method on BaseCallback breaks the cycle: this way LayersModel can depend on\n  // BaseCallback but not on Callback.  The argument is typed as `Container`\n  // (the superclass of LayersModel) to avoid recapitulating the cycle. Callback\n  // overrides this method and enforces that the argument is really a\n  // LayersModel.\n  setModel(model: Container): void {\n    // Do nothing. Use Callback instead of BaseCallback to track the model.\n  }\n}\n\n/**\n * Container abstracting a list of callbacks.\n */\nexport class CallbackList {\n  callbacks: BaseCallback[];\n  queueLength: number;\n\n  // TODO(cais): When the need arises, uncomment the following lines and\n  // implement the queue for time values.\n  // private deltaTBatch: number;\n  // private deltaTsBatchBegin: Array<number>;\n  // private deltaTsBatchEnd: Array<number>;\n\n  /**\n   * Constructor of CallbackList.\n   * @param callbacks Array of `Callback` instances.\n   * @param queueLength Queue length for keeping running statistics over\n   *   callback execution time.\n   */\n  constructor(callbacks?: BaseCallback[], queueLength = 10) {\n    // TODO(cais): Make use of queueLength when implementing the queue for time\n    // values.\n    if (callbacks == null) {\n      callbacks = [];\n    }\n    this.callbacks = callbacks;\n    this.queueLength = queueLength;\n  }\n\n  append(callback: BaseCallback): void {\n    this.callbacks.push(callback);\n  }\n\n  setParams(params: Params): void {\n    for (const callback of this.callbacks) {\n      callback.setParams(params);\n    }\n  }\n\n  setModel(model: Container): void {\n    for (const callback of this.callbacks) {\n      callback.setModel(model);\n    }\n  }\n\n  /**\n   * Called at the start of an epoch.\n   * @param epoch Index of epoch.\n   * @param logs Dictionary of logs.\n   */\n  async onEpochBegin(epoch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onEpochBegin(epoch, logs);\n    }\n  }\n\n  /**\n   * Called at the end of an epoch.\n   * @param epoch Index of epoch.\n   * @param logs Dictionary of logs.\n   */\n  async onEpochEnd(epoch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onEpochEnd(epoch, logs);\n    }\n  }\n\n  /**\n   * Called  right before processing a batch.\n   * @param batch Index of batch within the current epoch.\n   * @param logs Dictionary of logs.\n   */\n  async onBatchBegin(batch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onBatchBegin(batch, logs);\n    }\n  }\n\n  /**\n   * Called at the end of a batch.\n   * @param batch Index of batch within the current epoch.\n   * @param logs Dictionary of logs.\n   */\n  async onBatchEnd(batch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onBatchEnd(batch, logs);\n    }\n  }\n\n  /**\n   * Called at the beginning of training.\n   * @param logs Dictionary of logs.\n   */\n  async onTrainBegin(logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onTrainBegin(logs);\n    }\n  }\n\n  /**\n   * Called at the end of training.\n   * @param logs Dictionary of logs.\n   */\n  async onTrainEnd(logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onTrainEnd(logs);\n    }\n  }\n}\n\n/**\n * Callback that accumulates epoch averages of metrics.\n *\n * This callback is automatically applied to every LayersModel.\n */\nexport class BaseLogger extends BaseCallback {\n  private seen: number;\n  private totals: UnresolvedLogs;\n\n  constructor() {\n    super();\n  }\n\n  override async onEpochBegin(epoch: number) {\n    this.seen = 0;\n    this.totals = {};\n  }\n\n  override async onBatchEnd(batch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    const batchSize = logs['size'] == null ? 0 : logs['size'] as number;\n    this.seen += batchSize;\n    for (const key in logs) {\n      const value = logs[key];\n      if (typeof value === 'number') {\n        if (!this.totals.hasOwnProperty(key)) {\n          this.totals[key] = 0;\n        }\n        this.totals[key] = this.totals[key] as number + value * batchSize;\n      } else {\n        let oldTotalsToDispose: Scalar;\n        if (key in this.totals) {\n          oldTotalsToDispose = this.totals[key] as Scalar;\n        } else {\n          this.totals[key] = 0;\n        }\n        const total: Scalar =\n            tidy(() => add((this.totals[key]), mul(value, batchSize)));\n        this.totals[key] = total;\n        if (oldTotalsToDispose != null) {\n          oldTotalsToDispose.dispose();\n        }\n      }\n    }\n  }\n\n  override async onEpochEnd(epoch: number, logs?: UnresolvedLogs) {\n    if (logs != null) {\n      for (const key of this.params['metrics'] as string[]) {\n        if (this.totals[key] == null) {\n          continue;\n        }\n        if (typeof this.totals[key] === 'number') {\n          logs[key] = this.totals[key] as number / this.seen;\n        } else {\n          tidy(() => {\n            const log: Scalar = mul(div(1, this.seen), this.totals[key]);\n            logs[key] = log;\n            (this.totals[key] as Tensor).dispose();\n            keep(logs[key] as Scalar);\n          });\n        }\n      }\n    }\n  }\n}\n\n/**\n * Callback that records events into a `History` object. This callback is\n * automatically applied to every TF.js Layers model. The `History` object\n * gets returned by the `fit` method of models.\n */\nexport class History extends BaseCallback {\n  epoch: number[];\n  history: {[key: string]: Array<number|Tensor>};\n\n  override async onTrainBegin(logs?: UnresolvedLogs) {\n    this.epoch = [];\n    this.history = {};\n  }\n\n  override async onEpochEnd(epoch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    this.epoch.push(epoch);\n    for (const key in logs) {\n      if (this.history[key] == null) {\n        this.history[key] = [];\n      }\n      this.history[key].push(logs[key]);\n    }\n  }\n\n  /**\n   * Await the values of all losses and metrics.\n   */\n  async syncData() {\n    const promises: Array<Promise<Float32Array|Int32Array|Uint8Array>> = [];\n    const keys: string[] = [];\n    const indices: number[] = [];\n    for (const key in this.history) {\n      const valueArray = this.history[key];\n      for (let i = 0; i < valueArray.length; ++i) {\n        if (typeof valueArray[i] !== 'number') {\n          const valueScalar = valueArray[i] as Tensor;\n          promises.push(valueScalar.data());\n          keys.push(key);\n          indices.push(i);\n        }\n      }\n    }\n    const values = await Promise.all(promises);\n    for (let n = 0; n < values.length; ++n) {\n      const tensorToDispose = this.history[keys[n]][indices[n]] as Tensor;\n      tensorToDispose.dispose();\n      this.history[keys[n]][indices[n]] = values[n][0];\n    }\n  }\n}\n\nexport interface CustomCallbackArgs {\n  onTrainBegin?: (logs?: Logs) => void | Promise<void>;\n  onTrainEnd?: (logs?: Logs) => void | Promise<void>;\n  onEpochBegin?: (epoch: number, logs?: Logs) => void | Promise<void>;\n  onEpochEnd?: (epoch: number, logs?: Logs) => void | Promise<void>;\n  onBatchBegin?: (batch: number, logs?: Logs) => void | Promise<void>;\n  onBatchEnd?: (batch: number, logs?: Logs) => void | Promise<void>;\n  onYield?: (epoch: number, batch: number, logs: Logs) => void | Promise<void>;\n  // Used for test DI mocking.\n  nowFunc?: Function;\n  nextFrameFunc?: Function;\n}\n\n/**\n * Custom callback for training.\n */\nexport class CustomCallback extends BaseCallback {\n  protected readonly trainBegin: (logs?: Logs) => void | Promise<void>;\n  protected readonly trainEnd: (logs?: Logs) => void | Promise<void>;\n  protected readonly epochBegin:\n      (epoch: number, logs?: Logs) => void | Promise<void>;\n  protected readonly epochEnd:\n      (epoch: number, logs?: Logs) => void | Promise<void>;\n  protected readonly batchBegin:\n      (batch: number, logs?: Logs) => void | Promise<void>;\n  protected readonly batchEnd:\n      (batch: number, logs?: Logs) => void | Promise<void>;\n  protected readonly yield:\n      (epoch: number, batch: number, logs: Logs) => void | Promise<void>;\n\n  private yieldEvery: YieldEveryOptions;\n  private currentEpoch = 0;\n  public nowFunc: Function;\n  public nextFrameFunc: Function;\n\n  constructor(args: CustomCallbackArgs, yieldEvery?: YieldEveryOptions) {\n    super();\n    this.nowFunc = args.nowFunc;\n    this.nextFrameFunc = args.nextFrameFunc || nextFrame;\n    this.yieldEvery = yieldEvery || 'auto';\n    if (this.yieldEvery === 'auto') {\n      this.yieldEvery = DEFAULT_YIELD_EVERY_MS;\n    }\n    if (this.yieldEvery === 'never' && args.onYield != null) {\n      throw new Error(\n          'yieldEvery is `never` but you provided an `onYield` callback. ' +\n          'Either change `yieldEvery` or remove the callback');\n    }\n    if (util.isNumber(this.yieldEvery)) {\n      // Decorate `maybeWait` so it will be called at most once every\n      // `yieldEvery` ms.\n      this.maybeWait = generic_utils.debounce(\n          this.maybeWait.bind(this), this.yieldEvery as number, this.nowFunc);\n    }\n    this.trainBegin = args.onTrainBegin;\n    this.trainEnd = args.onTrainEnd;\n    this.epochBegin = args.onEpochBegin;\n    this.epochEnd = args.onEpochEnd;\n    this.batchBegin = args.onBatchBegin;\n    this.batchEnd = args.onBatchEnd;\n    this.yield = args.onYield;\n  }\n\n  async maybeWait(epoch: number, batch: number, logs: UnresolvedLogs) {\n    const ps: Array<void|Promise<void>> = [];\n    if (this.yield != null) {\n      await resolveScalarsInLogs(logs);\n      ps.push(this.yield(epoch, batch, logs as Logs));\n    }\n    ps.push(this.nextFrameFunc());\n    await Promise.all(ps);\n  }\n\n  override async onEpochBegin(epoch: number, logs?: UnresolvedLogs):\n      Promise<void> {\n    this.currentEpoch = epoch;\n    if (this.epochBegin != null) {\n      await resolveScalarsInLogs(logs);\n      await this.epochBegin(epoch, logs as Logs);\n    }\n  }\n\n  override async onEpochEnd(epoch: number, logs?: UnresolvedLogs):\n      Promise<void> {\n    const ps: Array<void|Promise<void>> = [];\n    if (this.epochEnd != null) {\n      await resolveScalarsInLogs(logs);\n      ps.push(this.epochEnd(epoch, logs as Logs));\n    }\n    if (this.yieldEvery === 'epoch') {\n      ps.push(this.nextFrameFunc());\n    }\n    await Promise.all(ps);\n  }\n\n  override async onBatchBegin(batch: number, logs?: UnresolvedLogs):\n      Promise<void> {\n    if (this.batchBegin != null) {\n      await resolveScalarsInLogs(logs);\n      await this.batchBegin(batch, logs as Logs);\n    }\n  }\n\n  override async onBatchEnd(batch: number, logs?: UnresolvedLogs):\n      Promise<void> {\n    const ps: Array<void|Promise<void>> = [];\n    if (this.batchEnd != null) {\n      await resolveScalarsInLogs(logs);\n      ps.push(this.batchEnd(batch, logs as Logs));\n    }\n    if (this.yieldEvery === 'batch') {\n      ps.push(this.nextFrameFunc());\n    } else if (util.isNumber(this.yieldEvery)) {\n      ps.push(this.maybeWait(this.currentEpoch, batch, logs));\n    }\n    await Promise.all(ps);\n  }\n\n  override async onTrainBegin(logs?: UnresolvedLogs): Promise<void> {\n    if (this.trainBegin != null) {\n      await resolveScalarsInLogs(logs);\n      await this.trainBegin(logs as Logs);\n    }\n  }\n\n  override async onTrainEnd(logs?: UnresolvedLogs): Promise<void> {\n    if (this.trainEnd != null) {\n      await resolveScalarsInLogs(logs);\n      await this.trainEnd(logs as Logs);\n    }\n  }\n}\n\n/**\n * Standardize callbacks or configurations of them to an Array of callbacks.\n */\nexport function standardizeCallbacks(\n    callbacks: BaseCallback|BaseCallback[]|CustomCallbackArgs|\n    CustomCallbackArgs[],\n    yieldEvery: YieldEveryOptions): BaseCallback[] {\n  if (callbacks == null) {\n    callbacks = {} as BaseCallback;\n  }\n  if (callbacks instanceof BaseCallback) {\n    return [callbacks];\n  }\n  if (Array.isArray(callbacks) && callbacks[0] instanceof BaseCallback) {\n    return callbacks as BaseCallback[];\n  }\n  // Convert custom callback configs to custom callback objects.\n  const callbackConfigs =\n      generic_utils.toList(callbacks) as CustomCallbackArgs[];\n  return callbackConfigs.map(\n      callbackConfig => new CustomCallback(callbackConfig, yieldEvery));\n}\n\nexport declare type BaseCallbackConstructor = {\n  new (): BaseCallback\n};\n\n/**\n * A global registry for callback constructors to be used during\n * LayersModel.fit().\n */\nexport class CallbackConstructorRegistry {\n  private static constructors:\n      {[verbosityLevel: number]: BaseCallbackConstructor[]} = {};\n\n  /**\n   * Blocks public access to constructor.\n   */\n  private constructor() {}\n\n  /**\n   * Register a tf.LayersModel.fit() callback constructor.\n   *\n   * The registered callback constructor will be used to instantiate\n   * callbacks for every tf.LayersModel.fit() call afterwards.\n   *\n   * @param verbosityLevel Level of verbosity at which the `callbackConstructor`\n   *   is to be reigstered.\n   * @param callbackConstructor A no-arg constructor for `tf.Callback`.\n   * @throws Error, if the same callbackConstructor has been registered before,\n   *   either at the same or a different `verbosityLevel`.\n   */\n  static registerCallbackConstructor(\n      verbosityLevel: number, callbackConstructor: BaseCallbackConstructor) {\n    util.assert(\n        verbosityLevel >= 0 && Number.isInteger(verbosityLevel),\n        () => `Verbosity level is expected to be an integer >= 0, ` +\n            `but got ${verbosityLevel}`);\n    CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);\n    if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {\n      CallbackConstructorRegistry.constructors[verbosityLevel] = [];\n    }\n    CallbackConstructorRegistry.constructors[verbosityLevel].push(\n        callbackConstructor);\n  }\n\n  private static checkForDuplicate(callbackConstructor:\n                                       BaseCallbackConstructor) {\n    for (const levelName in CallbackConstructorRegistry.constructors) {\n      const constructors = CallbackConstructorRegistry.constructors[+levelName];\n      constructors.forEach(ctor => {\n        if (ctor === callbackConstructor) {\n          throw new ValueError('Duplicate callback constructor.');\n        }\n      });\n    }\n  }\n\n  /**\n   * Clear all registered callback constructors.\n   */\n  protected static clear() {\n    CallbackConstructorRegistry.constructors = {};\n  }\n\n  /**\n   * Create callbacks using the registered callback constructors.\n   *\n   * Given `verbosityLevel`, all constructors registered at that level or above\n   * will be called and the instantiated callbacks will be used.\n   *\n   * @param verbosityLevel: Level of verbosity.\n   */\n  static createCallbacks(verbosityLevel: number): BaseCallback[] {\n    const constructors: BaseCallbackConstructor[] = [];\n    for (const levelName in CallbackConstructorRegistry.constructors) {\n      const level = +levelName;\n      if (verbosityLevel >= level) {\n        constructors.push(...CallbackConstructorRegistry.constructors[level]);\n      }\n    }\n    return constructors.map(ctor => new ctor());\n  }\n}\n\nexport function configureCallbacks(\n    callbacks: BaseCallback[], verbose: ModelLoggingVerbosity, epochs: number,\n    initialEpoch: number, numTrainSamples: number, stepsPerEpoch: number,\n    batchSize: number, doValidation: boolean,\n    callbackMetrics: string[]): {callbackList: CallbackList, history: History} {\n  const history = new History();\n  const actualCallbacks: BaseCallback[] = [\n    new BaseLogger(), ...CallbackConstructorRegistry.createCallbacks(verbose)\n  ];\n  if (callbacks != null) {\n    actualCallbacks.push(...callbacks);\n  }\n  actualCallbacks.push(history);\n  const callbackList = new CallbackList(actualCallbacks);\n\n  // TODO(cais): Figure out when this LayersModel instance can have a\n  // dynamically\n  //   set property called 'callback_model' as in PyKeras.\n\n  callbackList.setParams({\n    epochs,\n    initialEpoch,\n    samples: numTrainSamples,\n    steps: stepsPerEpoch,\n    batchSize,\n    verbose,\n    doValidation,\n    metrics: callbackMetrics,\n  });\n  return {callbackList, history};\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}