{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nimport { isBigNumber, isConstantNode, isNode, isRangeNode, isSymbolNode } from '../../utils/is';\nimport { map } from '../../utils/array';\nimport { escape } from '../../utils/string';\nimport { factory } from '../../utils/factory';\nimport { getSafeProperty } from '../../utils/customs';\nvar name = 'IndexNode';\nvar dependencies = ['Range', 'Node', 'size'];\nexport var createIndexNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Range = _ref.Range,\n    Node = _ref.Node,\n    size = _ref.size;\n\n  /**\n   * @constructor IndexNode\n   * @extends Node\n   *\n   * Describes a subset of a matrix or an object property.\n   * Cannot be used on its own, needs to be used within an AccessorNode or\n   * AssignmentNode.\n   *\n   * @param {Node[]} dimensions\n   * @param {boolean} [dotNotation=false]  Optional property describing whether\n   *                                       this index was written using dot\n   *                                       notation like `a.b`, or using bracket\n   *                                       notation like `a[\"b\"]` (default).\n   *                                       Used to stringify an IndexNode.\n   */\n  function IndexNode(dimensions, dotNotation) {\n    if (!(this instanceof IndexNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n    this.dimensions = dimensions;\n    this.dotNotation = dotNotation || false; // validate input\n\n    if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n    }\n    if (this.dotNotation && !this.isObjectProperty()) {\n      throw new Error('dotNotation only applicable for object properties');\n    }\n  }\n  IndexNode.prototype = new Node();\n  IndexNode.prototype.type = 'IndexNode';\n  IndexNode.prototype.isIndexNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  IndexNode.prototype._compile = function (math, argNames) {\n    // TODO: implement support for bignumber (currently bignumbers are silently\n    //       reduced to numbers when changing the value to zero-based)\n    // TODO: Optimization: when the range values are ConstantNodes,\n    //       we can beforehand resolve the zero-based value\n    // optimization for a simple object property\n    var evalDimensions = map(this.dimensions, function (range, i) {\n      if (isRangeNode(range)) {\n        if (range.needsEnd()) {\n          // create a range containing end (like '4:end')\n          var childArgNames = Object.create(argNames);\n          childArgNames.end = true;\n          var evalStart = range.start._compile(math, childArgNames);\n          var evalEnd = range.end._compile(math, childArgNames);\n          var evalStep = range.step ? range.step._compile(math, childArgNames) : function () {\n            return 1;\n          };\n          return function evalDimension(scope, args, context) {\n            var s = size(context).valueOf();\n            var childArgs = Object.create(args);\n            childArgs.end = s[i];\n            return createRange(evalStart(scope, childArgs, context), evalEnd(scope, childArgs, context), evalStep(scope, childArgs, context));\n          };\n        } else {\n          // create range\n          var _evalStart = range.start._compile(math, argNames);\n          var _evalEnd = range.end._compile(math, argNames);\n          var _evalStep = range.step ? range.step._compile(math, argNames) : function () {\n            return 1;\n          };\n          return function evalDimension(scope, args, context) {\n            return createRange(_evalStart(scope, args, context), _evalEnd(scope, args, context), _evalStep(scope, args, context));\n          };\n        }\n      } else if (isSymbolNode(range) && range.name === 'end') {\n        // SymbolNode 'end'\n        var _childArgNames = Object.create(argNames);\n        _childArgNames.end = true;\n        var evalRange = range._compile(math, _childArgNames);\n        return function evalDimension(scope, args, context) {\n          var s = size(context).valueOf();\n          var childArgs = Object.create(args);\n          childArgs.end = s[i];\n          return evalRange(scope, childArgs, context);\n        };\n      } else {\n        // ConstantNode\n        var _evalRange = range._compile(math, argNames);\n        return function evalDimension(scope, args, context) {\n          return _evalRange(scope, args, context);\n        };\n      }\n    });\n    var index = getSafeProperty(math, 'index');\n    return function evalIndexNode(scope, args, context) {\n      var dimensions = map(evalDimensions, function (evalDimension) {\n        return evalDimension(scope, args, context);\n      });\n      return index.apply(void 0, _toConsumableArray(dimensions));\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n  IndexNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.dimensions.length; i++) {\n      callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new IndexNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {IndexNode} Returns a transformed copy of the node\n   */\n\n  IndexNode.prototype.map = function (callback) {\n    var dimensions = [];\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n    }\n    return new IndexNode(dimensions, this.dotNotation);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {IndexNode}\n   */\n\n  IndexNode.prototype.clone = function () {\n    return new IndexNode(this.dimensions.slice(0), this.dotNotation);\n  };\n  /**\n   * Test whether this IndexNode contains a single property name\n   * @return {boolean}\n   */\n\n  IndexNode.prototype.isObjectProperty = function () {\n    return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n  };\n  /**\n   * Returns the property name if IndexNode contains a property.\n   * If not, returns null.\n   * @return {string | null}\n   */\n\n  IndexNode.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this.dimensions[0].value : null;\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  IndexNode.prototype._toString = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n  IndexNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'IndexNode',\n      dimensions: this.dimensions,\n      dotNotation: this.dotNotation\n    };\n  };\n  /**\n   * Instantiate an IndexNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n   *                       where mathjs is optional\n   * @returns {IndexNode}\n   */\n\n  IndexNode.fromJSON = function (json) {\n    return new IndexNode(json.dimensions, json.dotNotation);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  IndexNode.prototype.toHTML = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    var dimensions = [];\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this.dimensions[i].toHTML();\n    }\n    if (this.dotNotation) {\n      return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + escape(this.getObjectProperty()) + '</span>';\n    } else {\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n  IndexNode.prototype._toTex = function (options) {\n    var dimensions = this.dimensions.map(function (range) {\n      return range.toTex(options);\n    });\n    return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n  }; // helper function to create a Range from start, step and end\n\n  function createRange(start, end, step) {\n    return new Range(isBigNumber(start) ? start.toNumber() : start, isBigNumber(end) ? end.toNumber() : end, isBigNumber(step) ? step.toNumber() : step);\n  }\n  return IndexNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","iter","Symbol","iterator","isArray","len","length","i","arr2","isBigNumber","isConstantNode","isNode","isRangeNode","isSymbolNode","map","escape","factory","getSafeProperty","dependencies","createIndexNode","_ref","Range","Node","size","IndexNode","dimensions","dotNotation","SyntaxError","every","isObjectProperty","Error","type","isIndexNode","_compile","math","argNames","evalDimensions","range","needsEnd","childArgNames","create","end","evalStart","start","evalEnd","evalStep","step","evalDimension","scope","args","context","s","valueOf","childArgs","createRange","_evalStart","_evalEnd","_evalStep","_childArgNames","evalRange","_evalRange","index","evalIndexNode","apply","forEach","callback","_ifNode","clone","value","getObjectProperty","_toString","options","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","toNumber","isClass"],"sources":["F:/extension/SEM 7/NN/Lab/my lab/Project/temp/app/node_modules/mathjs/es/expression/node/IndexNode.js"],"sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { isBigNumber, isConstantNode, isNode, isRangeNode, isSymbolNode } from '../../utils/is';\nimport { map } from '../../utils/array';\nimport { escape } from '../../utils/string';\nimport { factory } from '../../utils/factory';\nimport { getSafeProperty } from '../../utils/customs';\nvar name = 'IndexNode';\nvar dependencies = ['Range', 'Node', 'size'];\nexport var createIndexNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Range = _ref.Range,\n      Node = _ref.Node,\n      size = _ref.size;\n\n  /**\n   * @constructor IndexNode\n   * @extends Node\n   *\n   * Describes a subset of a matrix or an object property.\n   * Cannot be used on its own, needs to be used within an AccessorNode or\n   * AssignmentNode.\n   *\n   * @param {Node[]} dimensions\n   * @param {boolean} [dotNotation=false]  Optional property describing whether\n   *                                       this index was written using dot\n   *                                       notation like `a.b`, or using bracket\n   *                                       notation like `a[\"b\"]` (default).\n   *                                       Used to stringify an IndexNode.\n   */\n  function IndexNode(dimensions, dotNotation) {\n    if (!(this instanceof IndexNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.dimensions = dimensions;\n    this.dotNotation = dotNotation || false; // validate input\n\n    if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n    }\n\n    if (this.dotNotation && !this.isObjectProperty()) {\n      throw new Error('dotNotation only applicable for object properties');\n    }\n  }\n\n  IndexNode.prototype = new Node();\n  IndexNode.prototype.type = 'IndexNode';\n  IndexNode.prototype.isIndexNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  IndexNode.prototype._compile = function (math, argNames) {\n    // TODO: implement support for bignumber (currently bignumbers are silently\n    //       reduced to numbers when changing the value to zero-based)\n    // TODO: Optimization: when the range values are ConstantNodes,\n    //       we can beforehand resolve the zero-based value\n    // optimization for a simple object property\n    var evalDimensions = map(this.dimensions, function (range, i) {\n      if (isRangeNode(range)) {\n        if (range.needsEnd()) {\n          // create a range containing end (like '4:end')\n          var childArgNames = Object.create(argNames);\n          childArgNames.end = true;\n\n          var evalStart = range.start._compile(math, childArgNames);\n\n          var evalEnd = range.end._compile(math, childArgNames);\n\n          var evalStep = range.step ? range.step._compile(math, childArgNames) : function () {\n            return 1;\n          };\n          return function evalDimension(scope, args, context) {\n            var s = size(context).valueOf();\n            var childArgs = Object.create(args);\n            childArgs.end = s[i];\n            return createRange(evalStart(scope, childArgs, context), evalEnd(scope, childArgs, context), evalStep(scope, childArgs, context));\n          };\n        } else {\n          // create range\n          var _evalStart = range.start._compile(math, argNames);\n\n          var _evalEnd = range.end._compile(math, argNames);\n\n          var _evalStep = range.step ? range.step._compile(math, argNames) : function () {\n            return 1;\n          };\n\n          return function evalDimension(scope, args, context) {\n            return createRange(_evalStart(scope, args, context), _evalEnd(scope, args, context), _evalStep(scope, args, context));\n          };\n        }\n      } else if (isSymbolNode(range) && range.name === 'end') {\n        // SymbolNode 'end'\n        var _childArgNames = Object.create(argNames);\n\n        _childArgNames.end = true;\n\n        var evalRange = range._compile(math, _childArgNames);\n\n        return function evalDimension(scope, args, context) {\n          var s = size(context).valueOf();\n          var childArgs = Object.create(args);\n          childArgs.end = s[i];\n          return evalRange(scope, childArgs, context);\n        };\n      } else {\n        // ConstantNode\n        var _evalRange = range._compile(math, argNames);\n\n        return function evalDimension(scope, args, context) {\n          return _evalRange(scope, args, context);\n        };\n      }\n    });\n    var index = getSafeProperty(math, 'index');\n    return function evalIndexNode(scope, args, context) {\n      var dimensions = map(evalDimensions, function (evalDimension) {\n        return evalDimension(scope, args, context);\n      });\n      return index.apply(void 0, _toConsumableArray(dimensions));\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  IndexNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.dimensions.length; i++) {\n      callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new IndexNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {IndexNode} Returns a transformed copy of the node\n   */\n\n\n  IndexNode.prototype.map = function (callback) {\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n    }\n\n    return new IndexNode(dimensions, this.dotNotation);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {IndexNode}\n   */\n\n\n  IndexNode.prototype.clone = function () {\n    return new IndexNode(this.dimensions.slice(0), this.dotNotation);\n  };\n  /**\n   * Test whether this IndexNode contains a single property name\n   * @return {boolean}\n   */\n\n\n  IndexNode.prototype.isObjectProperty = function () {\n    return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n  };\n  /**\n   * Returns the property name if IndexNode contains a property.\n   * If not, returns null.\n   * @return {string | null}\n   */\n\n\n  IndexNode.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this.dimensions[0].value : null;\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toString = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  IndexNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'IndexNode',\n      dimensions: this.dimensions,\n      dotNotation: this.dotNotation\n    };\n  };\n  /**\n   * Instantiate an IndexNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n   *                       where mathjs is optional\n   * @returns {IndexNode}\n   */\n\n\n  IndexNode.fromJSON = function (json) {\n    return new IndexNode(json.dimensions, json.dotNotation);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype.toHTML = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this.dimensions[i].toHTML();\n    }\n\n    if (this.dotNotation) {\n      return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + escape(this.getObjectProperty()) + '</span>';\n    } else {\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toTex = function (options) {\n    var dimensions = this.dimensions.map(function (range) {\n      return range.toTex(options);\n    });\n    return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n  }; // helper function to create a Range from start, step and end\n\n\n  function createRange(start, end, step) {\n    return new Range(isBigNumber(start) ? start.toNumber() : start, isBigNumber(end) ? end.toNumber() : end, isBigNumber(step) ? step.toNumber() : step);\n  }\n\n  return IndexNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}