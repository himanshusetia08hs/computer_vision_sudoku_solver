{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Padding Layers.\n */\n// Porting Note: In Python Keras, the padding layers are in convolutional.py,\n//   but we decided to put them in a separate file (padding.ts) for clarity.\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy } from '@tensorflow/tfjs-core';\nimport { imageDataFormat } from '../backend/common';\nimport { InputSpec, Layer } from '../engine/topology';\nimport { ValueError } from '../errors';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../utils/types_utils';\n/**\n * Pads the middle dimension of a 3D tensor.\n *\n * @param x Input `tf.Tensor` to be padded.\n * @param padding `Array` of 2 integers, how many zeros to add at the start and\n *   end of the middle dimension (i.e., dimension 1).\n * @return A padded 3D `tf.Tensor`.\n */\nexport function temporalPadding(x, padding) {\n  return tidy(() => {\n    if (x.rank !== 3) {\n      throw new ValueError(`temporalPadding expects input tensor to be 3-D, but received a ` + `${x.rank}-D tensor.`);\n    }\n    if (padding == null) {\n      padding = [1, 1];\n    }\n    if (padding.length !== 2) {\n      throw new ValueError(`temporalPadding expects input padding pattern to be a length-2 ` + `array, but received a length-${padding.length} array.`);\n    }\n    const pattern = [[0, 0], padding, [0, 0]];\n    return tfc.pad(x, pattern);\n  });\n}\n/**\n * Pads the 2nd and 3rd dimensions of a 4D tensor.\n *\n * @param x Input `tf.Tensor` to be padded.\n * @param padding `Array` of two `Array`s, each of which is an `Array` of two\n *   integers. The amount of padding at the beginning and end of the 2nd and 3rd\n *   dimensions, respectively.\n * @param dataFormat 'channelsLast' (default) or 'channelsFirst'.\n * @return Padded 4D `tf.Tensor`.\n */\nexport function spatial2dPadding(x, padding, dataFormat) {\n  return tidy(() => {\n    if (x.rank !== 4) {\n      throw new ValueError(`temporalPadding expects input tensor to be 4-D, but received a ` + `${x.rank}-D tensor.`);\n    }\n    if (padding == null) {\n      padding = [[1, 1], [1, 1]];\n    }\n    if (padding.length !== 2 || padding[0].length !== 2 || padding[1].length !== 2) {\n      throw new ValueError('spatial2dPadding expects `padding` to be an Array of two Arrays, ' + 'each of which is an Array of two integers.');\n    }\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n    if (dataFormat !== 'channelsLast' && dataFormat !== 'channelsFirst') {\n      throw new ValueError(`Unknown data format: ${dataFormat}. ` + `Supported data formats are 'channelsLast' and 'channelsFirst.`);\n    }\n    let pattern;\n    if (dataFormat === 'channelsFirst') {\n      pattern = [[0, 0], [0, 0], padding[0], padding[1]];\n    } else {\n      pattern = [[0, 0], padding[0], padding[1], [0, 0]];\n    }\n    return tfc.pad(x, pattern);\n  });\n}\nexport class ZeroPadding2D extends Layer {\n  constructor(args) {\n    if (args == null) {\n      args = {};\n    }\n    super(args);\n    this.dataFormat = args.dataFormat == null ? imageDataFormat() : args.dataFormat;\n    // TODO(cais): Maybe refactor the following logic surrounding `padding`\n    //   into a helper method.\n    if (args.padding == null) {\n      this.padding = [[1, 1], [1, 1]];\n    } else if (typeof args.padding === 'number') {\n      this.padding = [[args.padding, args.padding], [args.padding, args.padding]];\n    } else {\n      args.padding = args.padding;\n      if (args.padding.length !== 2) {\n        throw new ValueError(`ZeroPadding2D expects padding to be a length-2 array, but ` + `received a length-${args.padding.length} array.`);\n      }\n      let heightPadding;\n      let widthPadding;\n      if (typeof args.padding[0] === 'number') {\n        heightPadding = [args.padding[0], args.padding[0]];\n        widthPadding = [args.padding[1], args.padding[1]];\n      } else {\n        args.padding = args.padding;\n        if (args.padding[0].length !== 2) {\n          throw new ValueError(`ZeroPadding2D expects height padding to be a length-2 array, ` + `but received a length-${args.padding[0].length} array.`);\n        }\n        heightPadding = args.padding[0];\n        if (args.padding[1].length !== 2) {\n          throw new ValueError(`ZeroPadding2D expects width padding to be a length-2 array, ` + `but received a length-${args.padding[1].length} array.`);\n        }\n        widthPadding = args.padding[1];\n      }\n      this.padding = [heightPadding, widthPadding];\n    }\n    this.inputSpec = [new InputSpec({\n      ndim: 4\n    })];\n  }\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    let rows;\n    let cols;\n    if (this.dataFormat === 'channelsFirst') {\n      if (inputShape[2] != null && inputShape[2] >= 0) {\n        rows = inputShape[2] + this.padding[0][0] + this.padding[0][1];\n      } else {\n        rows = null;\n      }\n      if (inputShape[3] != null && inputShape[3] >= 0) {\n        cols = inputShape[3] + this.padding[1][0] + this.padding[1][1];\n      } else {\n        cols = null;\n      }\n      return [inputShape[0], inputShape[1], rows, cols];\n    } else {\n      if (inputShape[1] != null && inputShape[1] >= 0) {\n        rows = inputShape[1] + this.padding[0][0] + this.padding[0][1];\n      } else {\n        rows = null;\n      }\n      if (inputShape[2] != null && inputShape[2] >= 0) {\n        cols = inputShape[2] + this.padding[1][0] + this.padding[1][1];\n      } else {\n        cols = null;\n      }\n      return [inputShape[0], rows, cols, inputShape[3]];\n    }\n  }\n  call(inputs, kwargs) {\n    return tidy(() => spatial2dPadding(getExactlyOneTensor(inputs), this.padding, this.dataFormat));\n  }\n  getConfig() {\n    const config = {\n      padding: this.padding,\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\n/** @nocollapse */\nZeroPadding2D.className = 'ZeroPadding2D';\nserialization.registerClass(ZeroPadding2D);","map":{"version":3,"sources":["../../src/layers/padding.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Padding Layers.\n */\n// Porting Note: In Python Keras, the padding layers are in convolutional.py,\n//   but we decided to put them in a separate file (padding.ts) for clarity.\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy } from '@tensorflow/tfjs-core';\nimport { imageDataFormat } from '../backend/common';\nimport { InputSpec, Layer } from '../engine/topology';\nimport { ValueError } from '../errors';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../utils/types_utils';\n/**\n * Pads the middle dimension of a 3D tensor.\n *\n * @param x Input `tf.Tensor` to be padded.\n * @param padding `Array` of 2 integers, how many zeros to add at the start and\n *   end of the middle dimension (i.e., dimension 1).\n * @return A padded 3D `tf.Tensor`.\n */\nexport function temporalPadding(x, padding) {\n    return tidy(() => {\n        if (x.rank !== 3) {\n            throw new ValueError(`temporalPadding expects input tensor to be 3-D, but received a ` +\n                `${x.rank}-D tensor.`);\n        }\n        if (padding == null) {\n            padding = [1, 1];\n        }\n        if (padding.length !== 2) {\n            throw new ValueError(`temporalPadding expects input padding pattern to be a length-2 ` +\n                `array, but received a length-${padding.length} array.`);\n        }\n        const pattern = [[0, 0], padding, [0, 0]];\n        return tfc.pad(x, pattern);\n    });\n}\n/**\n * Pads the 2nd and 3rd dimensions of a 4D tensor.\n *\n * @param x Input `tf.Tensor` to be padded.\n * @param padding `Array` of two `Array`s, each of which is an `Array` of two\n *   integers. The amount of padding at the beginning and end of the 2nd and 3rd\n *   dimensions, respectively.\n * @param dataFormat 'channelsLast' (default) or 'channelsFirst'.\n * @return Padded 4D `tf.Tensor`.\n */\nexport function spatial2dPadding(x, padding, dataFormat) {\n    return tidy(() => {\n        if (x.rank !== 4) {\n            throw new ValueError(`temporalPadding expects input tensor to be 4-D, but received a ` +\n                `${x.rank}-D tensor.`);\n        }\n        if (padding == null) {\n            padding = [[1, 1], [1, 1]];\n        }\n        if (padding.length !== 2 || padding[0].length !== 2 ||\n            padding[1].length !== 2) {\n            throw new ValueError('spatial2dPadding expects `padding` to be an Array of two Arrays, ' +\n                'each of which is an Array of two integers.');\n        }\n        if (dataFormat == null) {\n            dataFormat = imageDataFormat();\n        }\n        if (dataFormat !== 'channelsLast' && dataFormat !== 'channelsFirst') {\n            throw new ValueError(`Unknown data format: ${dataFormat}. ` +\n                `Supported data formats are 'channelsLast' and 'channelsFirst.`);\n        }\n        let pattern;\n        if (dataFormat === 'channelsFirst') {\n            pattern = [[0, 0], [0, 0], padding[0], padding[1]];\n        }\n        else {\n            pattern = [[0, 0], padding[0], padding[1], [0, 0]];\n        }\n        return tfc.pad(x, pattern);\n    });\n}\nexport class ZeroPadding2D extends Layer {\n    constructor(args) {\n        if (args == null) {\n            args = {};\n        }\n        super(args);\n        this.dataFormat =\n            args.dataFormat == null ? imageDataFormat() : args.dataFormat;\n        // TODO(cais): Maybe refactor the following logic surrounding `padding`\n        //   into a helper method.\n        if (args.padding == null) {\n            this.padding = [[1, 1], [1, 1]];\n        }\n        else if (typeof args.padding === 'number') {\n            this.padding =\n                [[args.padding, args.padding], [args.padding, args.padding]];\n        }\n        else {\n            args.padding = args.padding;\n            if (args.padding.length !== 2) {\n                throw new ValueError(`ZeroPadding2D expects padding to be a length-2 array, but ` +\n                    `received a length-${args.padding.length} array.`);\n            }\n            let heightPadding;\n            let widthPadding;\n            if (typeof args.padding[0] === 'number') {\n                heightPadding = [args.padding[0], args.padding[0]];\n                widthPadding = [args.padding[1], args.padding[1]];\n            }\n            else {\n                args.padding = args.padding;\n                if (args.padding[0].length !== 2) {\n                    throw new ValueError(`ZeroPadding2D expects height padding to be a length-2 array, ` +\n                        `but received a length-${args.padding[0].length} array.`);\n                }\n                heightPadding = args.padding[0];\n                if (args.padding[1].length !== 2) {\n                    throw new ValueError(`ZeroPadding2D expects width padding to be a length-2 array, ` +\n                        `but received a length-${args.padding[1].length} array.`);\n                }\n                widthPadding = args.padding[1];\n            }\n            this.padding = [heightPadding, widthPadding];\n        }\n        this.inputSpec = [new InputSpec({ ndim: 4 })];\n    }\n    computeOutputShape(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        let rows;\n        let cols;\n        if (this.dataFormat === 'channelsFirst') {\n            if (inputShape[2] != null && inputShape[2] >= 0) {\n                rows = inputShape[2] + this.padding[0][0] + this.padding[0][1];\n            }\n            else {\n                rows = null;\n            }\n            if (inputShape[3] != null && inputShape[3] >= 0) {\n                cols = inputShape[3] + this.padding[1][0] + this.padding[1][1];\n            }\n            else {\n                cols = null;\n            }\n            return [inputShape[0], inputShape[1], rows, cols];\n        }\n        else {\n            if (inputShape[1] != null && inputShape[1] >= 0) {\n                rows = inputShape[1] + this.padding[0][0] + this.padding[0][1];\n            }\n            else {\n                rows = null;\n            }\n            if (inputShape[2] != null && inputShape[2] >= 0) {\n                cols = inputShape[2] + this.padding[1][0] + this.padding[1][1];\n            }\n            else {\n                cols = null;\n            }\n            return [inputShape[0], rows, cols, inputShape[3]];\n        }\n    }\n    call(inputs, kwargs) {\n        return tidy(() => spatial2dPadding(getExactlyOneTensor(inputs), this.padding, this.dataFormat));\n    }\n    getConfig() {\n        const config = {\n            padding: this.padding,\n            dataFormat: this.dataFormat,\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\n/** @nocollapse */\nZeroPadding2D.className = 'ZeroPadding2D';\nserialization.registerClass(ZeroPadding2D);\n//# sourceMappingURL=padding.js.map"]},"metadata":{},"sourceType":"module"}