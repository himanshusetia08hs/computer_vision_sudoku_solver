{"ast":null,"code":"export class ConnectedRegion {\n  constructor(points, topLeft, bottomRight) {\n    this.points = void 0;\n    this.bounds = void 0;\n    this.points = points;\n    this.bounds = {\n      topLeft,\n      bottomRight\n    };\n  }\n  get width() {\n    return this.bounds.bottomRight.x - this.bounds.topLeft.x;\n  }\n  get height() {\n    return this.bounds.bottomRight.y - this.bounds.topLeft.y;\n  }\n  get aspectRatio() {\n    return this.width / this.height;\n  }\n}\nexport function getConnectedComponent(image, x, y) {\n  const {\n    width,\n    height,\n    bytes\n  } = image;\n  let minX = x;\n  let minY = y;\n  let maxX = x;\n  let maxY = y;\n  const points = [];\n  const frontier = [];\n  points.push({\n    x,\n    y\n  });\n  frontier.push({\n    x,\n    y\n  });\n  bytes[y * width + x] = 0;\n  while (frontier.length > 0) {\n    const seed = frontier.pop();\n    minX = Math.min(seed.x, minX);\n    maxX = Math.max(seed.x, maxX);\n    minY = Math.min(seed.y, minY);\n    maxY = Math.max(seed.y, maxY);\n    for (let dy = Math.max(0, seed.y - 1); dy < height && dy <= seed.y + 1; dy++) {\n      for (let dx = Math.max(0, seed.x - 1); dx < width && dx <= seed.x + 1; dx++) {\n        if (bytes[dy * width + dx] === 255) {\n          points.push({\n            x: dx,\n            y: dy\n          });\n          frontier.push({\n            x: dx,\n            y: dy\n          });\n          bytes[dy * width + dx] = 0;\n        }\n      }\n    }\n  }\n  return new ConnectedRegion(points, {\n    x: minX,\n    y: minY\n  }, {\n    x: maxX,\n    y: maxY\n  });\n}\nexport default function getLargestConnectedComponent(image, _ref) {\n  let {\n    minAspectRatio,\n    maxAspectRatio,\n    minSize,\n    maxSize\n  } = _ref;\n  let maxRegion = null;\n  const tmp = image.clone();\n  const {\n    width,\n    height,\n    bytes\n  } = tmp;\n  for (let y = 0; y < height; y++) {\n    const row = y * width;\n    for (let x = 0; x < width; x++) {\n      if (bytes[row + x] === 255) {\n        const region = getConnectedComponent(tmp, x, y);\n        const width = region.bounds.bottomRight.x - region.bounds.topLeft.x;\n        const height = region.bounds.bottomRight.y - region.bounds.topLeft.y;\n        if (region.aspectRatio >= minAspectRatio && region.aspectRatio <= maxAspectRatio && height >= minSize && width >= minSize && height <= maxSize && width <= maxSize) {\n          if (!maxRegion || region.points.length > maxRegion.points.length) {\n            maxRegion = region;\n          }\n        }\n      }\n    }\n  }\n  return maxRegion;\n}","map":{"version":3,"names":["ConnectedRegion","constructor","points","topLeft","bottomRight","bounds","width","x","height","y","aspectRatio","getConnectedComponent","image","bytes","minX","minY","maxX","maxY","frontier","push","length","seed","pop","Math","min","max","dy","dx","getLargestConnectedComponent","minAspectRatio","maxAspectRatio","minSize","maxSize","maxRegion","tmp","clone","row","region"],"sources":["F:/extension/SEM 7/NN/Lab/my lab/Project/temp/app/src/augmentedReality/imageProcessing/getLargestConnectedComponent.ts"],"sourcesContent":["import Image from \"./Image\";\n\nexport interface Point {\n  x: number;\n  y: number;\n}\n\nexport class ConnectedRegion {\n  public points: Point[];\n  public bounds: { topLeft: Point; bottomRight: Point };\n  constructor(points: Point[], topLeft: Point, bottomRight: Point) {\n    this.points = points;\n    this.bounds = { topLeft, bottomRight };\n  }\n  get width() {\n    return this.bounds.bottomRight.x - this.bounds.topLeft.x;\n  }\n  get height() {\n    return this.bounds.bottomRight.y - this.bounds.topLeft.y;\n  }\n  get aspectRatio() {\n    return this.width / this.height;\n  }\n}\n\nexport function getConnectedComponent(\n  image: Image,\n  x: number,\n  y: number\n): ConnectedRegion {\n  const { width, height, bytes } = image;\n  let minX = x;\n  let minY = y;\n  let maxX = x;\n  let maxY = y;\n  const points: Point[] = [];\n  const frontier: Point[] = [];\n  points.push({ x, y });\n  frontier.push({ x, y });\n  bytes[y * width + x] = 0;\n  while (frontier.length > 0) {\n    const seed = frontier.pop()!;\n    minX = Math.min(seed.x, minX);\n    maxX = Math.max(seed.x, maxX);\n    minY = Math.min(seed.y, minY);\n    maxY = Math.max(seed.y, maxY);\n    for (\n      let dy = Math.max(0, seed.y - 1);\n      dy < height && dy <= seed.y + 1;\n      dy++\n    ) {\n      for (\n        let dx = Math.max(0, seed.x - 1);\n        dx < width && dx <= seed.x + 1;\n        dx++\n      ) {\n        if (bytes[dy * width + dx] === 255) {\n          points.push({ x: dx, y: dy });\n          frontier.push({ x: dx, y: dy });\n          bytes[dy * width + dx] = 0;\n        }\n      }\n    }\n  }\n  return new ConnectedRegion(\n    points,\n    { x: minX, y: minY },\n    { x: maxX, y: maxY }\n  );\n}\n\ntype ConnectedComponentOptions = {\n  minAspectRatio: number;\n  maxAspectRatio: number;\n  minSize: number;\n  maxSize: number;\n};\n\nexport default function getLargestConnectedComponent(\n  image: Image,\n  {\n    minAspectRatio,\n    maxAspectRatio,\n    minSize,\n    maxSize,\n  }: ConnectedComponentOptions\n): ConnectedRegion | null {\n  let maxRegion: ConnectedRegion | null = null;\n  const tmp = image.clone();\n  const { width, height, bytes } = tmp;\n  for (let y = 0; y < height; y++) {\n    const row = y * width;\n    for (let x = 0; x < width; x++) {\n      if (bytes[row + x] === 255) {\n        const region = getConnectedComponent(tmp, x, y);\n        const width = region.bounds.bottomRight.x - region.bounds.topLeft.x;\n        const height = region.bounds.bottomRight.y - region.bounds.topLeft.y;\n        if (\n          region.aspectRatio >= minAspectRatio &&\n          region.aspectRatio <= maxAspectRatio &&\n          height >= minSize &&\n          width >= minSize &&\n          height <= maxSize &&\n          width <= maxSize\n        ) {\n          if (!maxRegion || region.points.length > maxRegion.points.length) {\n            maxRegion = region;\n          }\n        }\n      }\n    }\n  }\n  return maxRegion;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}