{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, broadcastTo, reshape, tidy, util } from '@tensorflow/tfjs-core';\nvar RowPartitionType = backend_util.RowPartitionType;\n// Based on\n// https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc\nclass RaggedTensorToTensorOp {\n  constructor(shape, shapeShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypeStrings) {\n    this.shape = shape;\n    this.shapeShape = shapeShape;\n    this.values = values;\n    this.valuesShape = valuesShape;\n    this.valuesDType = valuesDType;\n    this.defaultValue = defaultValue;\n    this.defaultValueShape = defaultValueShape;\n    this.rowPartitionValues = rowPartitionValues;\n    this.rowPartitionValuesShapes = rowPartitionValuesShapes;\n    this.rowPartitionTypes = backend_util.getRowPartitionTypesHelper(rowPartitionTypeStrings);\n    this.raggedRank = backend_util.getRaggedRank(this.rowPartitionTypes);\n  }\n  getRowPartitionTypeByDimension(dimension) {\n    if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n      return this.rowPartitionTypes[dimension + 1];\n    } else {\n      return this.rowPartitionTypes[dimension];\n    }\n  }\n  // Returns the relationship between dimension and dimension + 1.\n  getRowPartitionTensor(dimension) {\n    if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n      return this.rowPartitionValues[dimension + 1];\n    } else {\n      return this.rowPartitionValues[dimension];\n    }\n  }\n  getMaxWidth(dimension) {\n    const rowPartitionTensor = this.getRowPartitionTensor(dimension - 1);\n    switch (this.getRowPartitionTypeByDimension(dimension - 1)) {\n      case RowPartitionType.VALUE_ROWIDS:\n        return RaggedTensorToTensorOp.getMaxWidthValueRowID(rowPartitionTensor);\n      case RowPartitionType.ROW_SPLITS:\n        return RaggedTensorToTensorOp.getMaxWidthRowSplit(rowPartitionTensor);\n      default:\n        throw new Error(`Cannot handle partition type ${RowPartitionType[this.getRowPartitionTypeByDimension(dimension - 1)]}`);\n    }\n  }\n  static getMaxWidthRowSplit(rowSplit) {\n    const tensorLength = rowSplit.length;\n    if (tensorLength === 0 || tensorLength === 1) {\n      return 0;\n    }\n    let maxWidth = 0;\n    for (let i = 0; i < tensorLength - 1; ++i) {\n      const currentWidth = rowSplit[i + 1] - rowSplit[i];\n      if (currentWidth > maxWidth) {\n        maxWidth = currentWidth;\n      }\n    }\n    return maxWidth;\n  }\n  static getMaxWidthValueRowID(valueRowIds) {\n    const indexLength = valueRowIds.length;\n    if (indexLength === 0) {\n      return 0;\n    }\n    let firstEqualIndex = 0;\n    let firstEqualIndexValue = valueRowIds[0];\n    let maxWidth = 0;\n    for (let i = 1; i < indexLength; ++i) {\n      const value = valueRowIds[i];\n      if (value !== firstEqualIndexValue) {\n        firstEqualIndexValue = value;\n        maxWidth = Math.max(i - firstEqualIndex, maxWidth);\n        firstEqualIndex = i;\n      }\n    }\n    return Math.max(indexLength - firstEqualIndex, maxWidth);\n  }\n  tensorShapeFromTensor(t, tShape) {\n    let isPartial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (tShape.length === 0) {\n      if (t[0] === -1) {\n        return [];\n      }\n      throw new Error(`The only valid scalar shape tensor is the fully unknown shape specified as -1.`);\n    }\n    // MakePartialShape/MakeShapeHelper.\n    return makeShape(t, isPartial);\n  }\n  calculateOutputSize(firstDim) {\n    const valueShape = this.valuesShape;\n    const defaultValueShape = this.defaultValueShape;\n    backend_util.validateDefaultValueShape(defaultValueShape, valueShape);\n    const shape = this.tensorShapeFromTensor(this.shape, this.shapeShape);\n    const outputShape = backend_util.combineRaggedTensorToTensorShapes(this.raggedRank, shape, valueShape);\n    const result = outputShape;\n    if (result[0] < 0) {\n      result[0] = firstDim;\n    }\n    for (let i = 1; i <= this.raggedRank; ++i) {\n      if (result[i] < 0) {\n        result[i] = this.getMaxWidth(i);\n      }\n    }\n    return result;\n  }\n  /**\n   * The outputIndex represents the index in the output tensor\n   * where the first element of a particular dimension would be written.\n   * If it is -1, it indicates that the index is out of scope.\n   * Example, given firstDimension = 10, firstDimensionOutput = 6,\n   * and outputIndexMultiplier = 100:\n   * result = [0 100 200 300 400 500 -1 -1 -1 -1]\n   * If firstDimensionOutput = 11 instead, then:\n   * result = [0 100 200 300 400 500 600 700 800 900]\n   */\n  calculateFirstParentOutputIndex(firstDimension, outputIndexMultiplier, firstDimensionOutput) {\n    const minDimension = Math.min(firstDimension, firstDimensionOutput);\n    const result = [];\n    let currentOutputIndex = 0;\n    for (let i = 0; i < minDimension; ++i, currentOutputIndex += outputIndexMultiplier) {\n      result.push(currentOutputIndex);\n    }\n    for (let i = minDimension; i < firstDimension; ++i) {\n      result.push(-1);\n    }\n    util.assert(result.length === firstDimension, () => 'Final length of result must be equal to firstDimension.');\n    return result;\n  }\n  calculateOutputIndexRowSplit(rowSplit, parentOutputIndex, outputIndexMultiplier, outputSize) {\n    const rowSplitSize = rowSplit.length;\n    const result = [];\n    for (let i = 0; i < rowSplitSize - 1; ++i) {\n      const rowLength = rowSplit[i + 1] - rowSplit[i];\n      let realLength = Math.min(outputSize, rowLength);\n      let parentOutputIndexCurrent = parentOutputIndex[i];\n      if (parentOutputIndexCurrent === -1) {\n        realLength = 0;\n      }\n      for (let j = 0; j < realLength; ++j) {\n        result.push(parentOutputIndexCurrent);\n        parentOutputIndexCurrent += outputIndexMultiplier;\n      }\n      for (let j = 0; j < rowLength - realLength; ++j) {\n        result.push(-1);\n      }\n    }\n    if (rowSplitSize > 0 && result.length !== rowSplit[rowSplitSize - 1]) {\n      throw new Error('Invalid row split size.');\n    }\n    return result;\n  }\n  // Calculate the output index of the first element of a list.\n  // The parentOutputIndex is the same computation for the previous list.\n  // -1 indicates an element or list that is out of range.\n  // The outputIndexMultiplier is the number of output indices one moves\n  // forward for each column.\n  // E.g., given:\n  // valueRowIds:[0 1 2 2 2 3 5 5 6]\n  // parentOutputIndex:[1000 1100 2000 2100 -1 3000 4000]\n  // outputIndexMultiplier: 10\n  // outputSize: 2\n  // You get:\n  // result = [1000 1100 2000 2010 -1 2100 -1 -1 3000]\n  // result[0] = parentOutputIndex[valueRowIds[0]]\n  // result[1] = parentOutputIndex[valueRowIds[1]]\n  // result[2] = parentOutputIndex[valueRowIds[2]]\n  // result[3] = parentOutputIndex[valueRowIds[2] + 10]\n  // result[4] = -1 because it is the third element the size is 2.\n  // result[5] = parentOutputIndex[valueRowIds[3]]\n  // result[6] = -1 because parentOutputIndex[valueRowIds[6]] == -1\n  // result[7] = -1 because parentOutputIndex[valueRowIds[6]] == -1\n  // result[8] = parentOutputIndex[valueRowIds[7]]\n  calculateOutputIndexValueRowID(valueRowIds, parentOutputIndex, outputIndexMultiplier, outputSize) {\n    const indexSize = valueRowIds.length;\n    const result = [];\n    if (indexSize === 0) {\n      return [];\n    }\n    let currentOutputColumn = 0;\n    let currentValueRowId = valueRowIds[0];\n    if (currentValueRowId >= parentOutputIndex.length) {\n      throw new Error(`Got currentValueRowId=${currentValueRowId}, which is not less than ${parentOutputIndex.length}`);\n    }\n    let currentOutputIndex = parentOutputIndex[currentValueRowId];\n    result.push(currentOutputIndex);\n    for (let i = 1; i < indexSize; ++i) {\n      const nextValueRowId = valueRowIds[i];\n      if (nextValueRowId === currentValueRowId) {\n        if (currentOutputIndex >= 0) {\n          ++currentOutputColumn;\n          if (currentOutputColumn < outputSize) {\n            currentOutputIndex += outputIndexMultiplier;\n          } else {\n            currentOutputIndex = -1;\n          }\n        }\n      } else {\n        currentOutputColumn = 0;\n        currentValueRowId = nextValueRowId;\n        if (nextValueRowId >= parentOutputIndex.length) {\n          throw new Error(`Got nextValueRowId=${nextValueRowId} which is not less than ${parentOutputIndex.length}`);\n        }\n        currentOutputIndex = parentOutputIndex[nextValueRowId];\n      }\n      result.push(currentOutputIndex);\n    }\n    if (result.length !== valueRowIds.length) {\n      throw new Error('Invalid row ids.');\n    }\n    return result;\n  }\n  calculateOutputIndex(dimension, parentOutputIndex, outputIndexMultiplier, outputSize) {\n    const rowPartitionTensor = this.getRowPartitionTensor(dimension);\n    const partitionType = this.getRowPartitionTypeByDimension(dimension);\n    switch (partitionType) {\n      case RowPartitionType.VALUE_ROWIDS:\n        return this.calculateOutputIndexValueRowID(rowPartitionTensor, parentOutputIndex, outputIndexMultiplier, outputSize);\n      case RowPartitionType.ROW_SPLITS:\n        if (rowPartitionTensor.length - 1 > parentOutputIndex.length) {\n          throw new Error(`Row partition size is greater than output size: ${rowPartitionTensor.length - 1} > ${parentOutputIndex.length}`);\n        }\n        return this.calculateOutputIndexRowSplit(rowPartitionTensor, parentOutputIndex, outputIndexMultiplier, outputSize);\n      default:\n        throw new Error(`Unsupported partition type: ${RowPartitionType[partitionType]}`);\n    }\n  }\n  getFirstDimensionSize() {\n    const firstPartitionTensor = this.rowPartitionValues[0];\n    if (this.rowPartitionTypes.length === 0) {\n      throw new Error('No row_partition_types given.');\n    }\n    const firstPartitionType = this.rowPartitionTypes[0];\n    switch (firstPartitionType) {\n      case RowPartitionType.FIRST_DIM_SIZE:\n        return firstPartitionTensor[0];\n      case RowPartitionType.VALUE_ROWIDS:\n        throw new Error('Cannot handle VALUE_ROWIDS in first dimension.');\n      case RowPartitionType.ROW_SPLITS:\n        return this.rowPartitionValuesShapes[0][0] - 1;\n      default:\n        throw new Error(`Cannot handle type ${RowPartitionType[firstPartitionType]}`);\n    }\n  }\n  compute() {\n    const firstPartitionTensor = this.rowPartitionValues[0];\n    if (firstPartitionTensor.length <= 0) {\n      throw new Error('Invalid first partition input. ' + 'Tensor requires at least one element.');\n    }\n    const firstDimension = this.getFirstDimensionSize();\n    const outputSize = this.calculateOutputSize(firstDimension);\n    const multiplier = new Array(this.raggedRank + 1);\n    multiplier[multiplier.length - 1] = 1;\n    for (let i = multiplier.length - 2; i >= 0; --i) {\n      multiplier[i] = multiplier[i + 1] * outputSize[i + 1];\n    }\n    // Full size of the tensor.\n    const outputShape = makeShape(outputSize, false);\n    const outputTensor = util.getArrayFromDType(this.valuesDType, util.sizeFromShape(outputShape));\n    const fullSize = multiplier[0] * outputSize[0];\n    if (fullSize > 0) {\n      let outputIndex = this.calculateFirstParentOutputIndex(firstDimension, multiplier[0], outputSize[0]);\n      for (let i = 1; i <= this.raggedRank; ++i) {\n        const newOutputIndex = this.calculateOutputIndex(i - 1, outputIndex, multiplier[i], outputSize[i]);\n        outputIndex = newOutputIndex;\n      }\n      this.setOutput(this.raggedRank, outputIndex, outputTensor, outputShape);\n    }\n    return [outputShape, outputTensor];\n  }\n  setOutput(raggedRank, outputIndex, outputTensor, outputShape) {\n    if (outputTensor.length === 0) {\n      return;\n    }\n    const valuesBase = this.values;\n    const outputBase = outputTensor;\n    let elementShape = outputShape.slice();\n    elementShape = elementShape.slice(raggedRank + 1);\n    const valueElementSize = util.sizeFromShape(elementShape);\n    const outputIndexSize = outputIndex.length;\n    // Broadcast the default value to value_element_size.  (We can skip this\n    // if defaultValueTensor.size == 1, since we use fill when that's true.)\n    let defaultValue = this.defaultValue;\n    if (defaultValue.length !== valueElementSize && defaultValue.length !== 1) {\n      const srcShape = this.defaultValueShape;\n      tidy(() => {\n        const defaultValueTensor = reshape(defaultValue, srcShape);\n        const bCastDefault = broadcastTo(defaultValueTensor, elementShape);\n        defaultValue = bCastDefault.dataSync();\n      });\n    }\n    // Loop through the outputIndex array, finding contiguous regions that\n    // should be copied.  Once we find the end of a contiguous region, copy it\n    // and add any necessary padding (with defaultValue).\n    let srcStart = 0; // Start of contiguous region (in values)\n    let dstStart = 0; // Destination for contiguous region (in output)\n    let dstEnd = 0; // Destination for contiguous region (in output)\n    for (let srcI = 0; srcI <= outputIndexSize; ++srcI) {\n      // dstI is the destination where the value at srcI should be copied.\n      let dstI = srcI < outputIndexSize ? outputIndex[srcI] : -1;\n      // If we're still in a contiguous region, then update dstEnd go to the\n      // next srcI.\n      if (dstI === dstEnd) {\n        ++dstEnd;\n        continue;\n      }\n      // We found the end of contiguous region.  This can be because we found\n      // a gap (dstI > dstEnd), or a source value that shouldn't be copied\n      // because it's out-of-bounds (dstI == -1), or the end of the tensor\n      // (dstI === -1).\n      if (dstStart < dstEnd) {\n        // Copy the contiguous region.\n        const src = valuesBase.subarray(srcStart * valueElementSize);\n        const dst = outputBase.subarray(dstStart * valueElementSize);\n        const nVals = (dstEnd - dstStart) * valueElementSize;\n        copyArray(dst, src, nVals);\n      }\n      // Add any necessary padding (w/ defaultValue).\n      if (srcI >= outputIndexSize) {\n        // We reached the end of values: pad to the end of output.\n        const outputSize = outputTensor.length;\n        dstI = Math.floor(outputSize / valueElementSize);\n      }\n      if (dstI > dstEnd) {\n        if (this.defaultValue.length === 1) {\n          outputBase.subarray(dstEnd * valueElementSize, dstI * valueElementSize).fill(this.defaultValue[0]);\n          dstEnd = dstI;\n        } else {\n          while (dstI > dstEnd) {\n            const dst = outputBase.slice(dstEnd * valueElementSize);\n            copyArray(dst, defaultValue, valueElementSize);\n            ++dstEnd;\n          }\n        }\n      }\n      // Update indices.\n      if (dstI < 0) {\n        // srcI should be skipped -- leave it out of the contiguous region.\n        srcStart = srcI + 1;\n        dstStart = dstEnd;\n      } else {\n        // srcI should be copied -- include it in the contiguous region.\n        srcStart = srcI;\n        dstStart = dstEnd;\n        dstEnd = dstStart + 1;\n      }\n    }\n  }\n}\nfunction copyArray(dst, src, size) {\n  for (let i = 0; i < size; i++) {\n    dst[i] = src[i];\n  }\n}\nfunction makeShape(shape, isPartial) {\n  const out = [];\n  for (let dim of shape) {\n    if (dim < 0) {\n      if (!isPartial) {\n        throw new Error(`Dimension ${dim} must be >= 0`);\n      }\n      if (dim < -1) {\n        throw new Error(`Dimension ${dim} must be >= -1`);\n      }\n      dim = -1;\n    }\n    out.push(dim);\n  }\n  return out;\n}\nexport function raggedTensorToTensorImpl(shape, shapesShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes) {\n  return new RaggedTensorToTensorOp(shape, shapesShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes).compute();\n}","map":{"version":3,"sources":["../../../../../../tfjs-backend-cpu/src/kernels/RaggedTensorToTensor_impl.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, broadcastTo, DataType, reshape, tidy, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport RowPartitionType = backend_util.RowPartitionType;\n// Based on\n// https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc\nclass RaggedTensorToTensorOp {\n  private readonly rowPartitionTypes: RowPartitionType[];\n  private readonly raggedRank: number;\n  constructor(\n      private shape: TypedArray, private shapeShape: number[],\n      private values: TypedArray, private valuesShape: number[],\n      private valuesDType: DataType, private defaultValue: TypedArray,\n      private defaultValueShape: number[],\n      private readonly rowPartitionValues: TypedArray[],\n      private readonly rowPartitionValuesShapes: number[][],\n      rowPartitionTypeStrings: string[]) {\n    this.rowPartitionTypes =\n        backend_util.getRowPartitionTypesHelper(rowPartitionTypeStrings);\n    this.raggedRank = backend_util.getRaggedRank(this.rowPartitionTypes);\n  }\n\n  private getRowPartitionTypeByDimension(dimension: number) {\n    if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n      return this.rowPartitionTypes[dimension + 1];\n    } else {\n      return this.rowPartitionTypes[dimension];\n    }\n  }\n\n  // Returns the relationship between dimension and dimension + 1.\n  private getRowPartitionTensor(dimension: number) {\n    if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n      return this.rowPartitionValues[dimension + 1];\n    } else {\n      return this.rowPartitionValues[dimension];\n    }\n  }\n\n  private getMaxWidth(dimension: number) {\n    const rowPartitionTensor = this.getRowPartitionTensor(dimension - 1);\n    switch (this.getRowPartitionTypeByDimension(dimension - 1)) {\n      case RowPartitionType.VALUE_ROWIDS:\n        return RaggedTensorToTensorOp.getMaxWidthValueRowID(rowPartitionTensor);\n      case RowPartitionType.ROW_SPLITS:\n        return RaggedTensorToTensorOp.getMaxWidthRowSplit(rowPartitionTensor);\n      default:\n        throw new Error(`Cannot handle partition type ${\n            RowPartitionType[this.getRowPartitionTypeByDimension(\n                dimension - 1)]}`);\n    }\n  }\n\n  static getMaxWidthRowSplit(rowSplit: TypedArray) {\n    const tensorLength = rowSplit.length;\n    if (tensorLength === 0 || tensorLength === 1) {\n      return 0;\n    }\n    let maxWidth = 0;\n    for (let i = 0; i < tensorLength - 1; ++i) {\n      const currentWidth = rowSplit[i + 1] - rowSplit[i];\n      if (currentWidth > maxWidth) {\n        maxWidth = currentWidth;\n      }\n    }\n    return maxWidth;\n  }\n\n  static getMaxWidthValueRowID(valueRowIds: TypedArray) {\n    const indexLength = valueRowIds.length;\n    if (indexLength === 0) {\n      return 0;\n    }\n    let firstEqualIndex = 0;\n    let firstEqualIndexValue = valueRowIds[0];\n    let maxWidth = 0;\n    for (let i = 1; i < indexLength; ++i) {\n      const value = valueRowIds[i];\n      if (value !== firstEqualIndexValue) {\n        firstEqualIndexValue = value;\n        maxWidth = Math.max(i - firstEqualIndex, maxWidth);\n        firstEqualIndex = i;\n      }\n    }\n    return Math.max(indexLength - firstEqualIndex, maxWidth);\n  }\n\n  private tensorShapeFromTensor(\n      t: TypedArray, tShape: number[], isPartial = true) {\n    if (tShape.length === 0) {\n      if (t[0] === -1) {\n        return [];\n      }\n      throw new Error(\n          `The only valid scalar shape tensor is the fully unknown shape specified as -1.`);\n    }\n    // MakePartialShape/MakeShapeHelper.\n    return makeShape(t, isPartial);\n  }\n\n  private calculateOutputSize(firstDim: number) {\n    const valueShape = this.valuesShape;\n    const defaultValueShape = this.defaultValueShape;\n\n    backend_util.validateDefaultValueShape(defaultValueShape, valueShape);\n\n    const shape = this.tensorShapeFromTensor(this.shape, this.shapeShape);\n    const outputShape = backend_util.combineRaggedTensorToTensorShapes(\n        this.raggedRank, shape, valueShape);\n\n    const result = outputShape;\n\n    if (result[0] < 0) {\n      result[0] = firstDim;\n    }\n    for (let i = 1; i <= this.raggedRank; ++i) {\n      if (result[i] < 0) {\n        result[i] = this.getMaxWidth(i);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * The outputIndex represents the index in the output tensor\n   * where the first element of a particular dimension would be written.\n   * If it is -1, it indicates that the index is out of scope.\n   * Example, given firstDimension = 10, firstDimensionOutput = 6,\n   * and outputIndexMultiplier = 100:\n   * result = [0 100 200 300 400 500 -1 -1 -1 -1]\n   * If firstDimensionOutput = 11 instead, then:\n   * result = [0 100 200 300 400 500 600 700 800 900]\n   */\n  private calculateFirstParentOutputIndex(\n      firstDimension: number, outputIndexMultiplier: number,\n      firstDimensionOutput: number) {\n    const minDimension = Math.min(firstDimension, firstDimensionOutput);\n    const result: number[] = [];\n    let currentOutputIndex = 0;\n    for (let i = 0; i < minDimension;\n         ++i, currentOutputIndex += outputIndexMultiplier) {\n      result.push(currentOutputIndex);\n    }\n    for (let i = minDimension; i < firstDimension; ++i) {\n      result.push(-1);\n    }\n    util.assert(\n        result.length === firstDimension,\n        () => 'Final length of result must be equal to firstDimension.');\n\n    return result;\n  }\n\n  private calculateOutputIndexRowSplit(\n      rowSplit: TypedArray, parentOutputIndex: number[],\n      outputIndexMultiplier: number, outputSize: number) {\n    const rowSplitSize = rowSplit.length;\n    const result: number[] = [];\n    for (let i = 0; i < rowSplitSize - 1; ++i) {\n      const rowLength = rowSplit[i + 1] - rowSplit[i];\n      let realLength = Math.min(outputSize, rowLength);\n      let parentOutputIndexCurrent = parentOutputIndex[i];\n\n      if (parentOutputIndexCurrent === -1) {\n        realLength = 0;\n      }\n      for (let j = 0; j < realLength; ++j) {\n        result.push(parentOutputIndexCurrent);\n        parentOutputIndexCurrent += outputIndexMultiplier;\n      }\n      for (let j = 0; j < rowLength - realLength; ++j) {\n        result.push(-1);\n      }\n    }\n    if (rowSplitSize > 0 && result.length !== rowSplit[rowSplitSize - 1]) {\n      throw new Error('Invalid row split size.');\n    }\n\n    return result;\n  }\n\n  // Calculate the output index of the first element of a list.\n  // The parentOutputIndex is the same computation for the previous list.\n  // -1 indicates an element or list that is out of range.\n  // The outputIndexMultiplier is the number of output indices one moves\n  // forward for each column.\n  // E.g., given:\n  // valueRowIds:[0 1 2 2 2 3 5 5 6]\n  // parentOutputIndex:[1000 1100 2000 2100 -1 3000 4000]\n  // outputIndexMultiplier: 10\n  // outputSize: 2\n  // You get:\n  // result = [1000 1100 2000 2010 -1 2100 -1 -1 3000]\n  // result[0] = parentOutputIndex[valueRowIds[0]]\n  // result[1] = parentOutputIndex[valueRowIds[1]]\n  // result[2] = parentOutputIndex[valueRowIds[2]]\n  // result[3] = parentOutputIndex[valueRowIds[2] + 10]\n  // result[4] = -1 because it is the third element the size is 2.\n  // result[5] = parentOutputIndex[valueRowIds[3]]\n  // result[6] = -1 because parentOutputIndex[valueRowIds[6]] == -1\n  // result[7] = -1 because parentOutputIndex[valueRowIds[6]] == -1\n  // result[8] = parentOutputIndex[valueRowIds[7]]\n  private calculateOutputIndexValueRowID(\n      valueRowIds: TypedArray, parentOutputIndex: number[],\n      outputIndexMultiplier: number, outputSize: number) {\n    const indexSize = valueRowIds.length;\n    const result: number[] = [];\n    if (indexSize === 0) {\n      return [];\n    }\n\n    let currentOutputColumn = 0;\n    let currentValueRowId = valueRowIds[0];\n\n    if (currentValueRowId >= parentOutputIndex.length) {\n      throw new Error(\n          `Got currentValueRowId=${currentValueRowId}, which is not less than ${\n              parentOutputIndex.length}`);\n    }\n\n    let currentOutputIndex = parentOutputIndex[currentValueRowId];\n    result.push(currentOutputIndex);\n    for (let i = 1; i < indexSize; ++i) {\n      const nextValueRowId = valueRowIds[i];\n      if (nextValueRowId === currentValueRowId) {\n        if (currentOutputIndex >= 0) {\n          ++currentOutputColumn;\n          if (currentOutputColumn < outputSize) {\n            currentOutputIndex += outputIndexMultiplier;\n          } else {\n            currentOutputIndex = -1;\n          }\n        }\n      } else {\n        currentOutputColumn = 0;\n        currentValueRowId = nextValueRowId;\n\n        if (nextValueRowId >= parentOutputIndex.length) {\n          throw new Error(\n              `Got nextValueRowId=${nextValueRowId} which is not less than ${\n                  parentOutputIndex.length}`);\n        }\n\n        currentOutputIndex = parentOutputIndex[nextValueRowId];\n      }\n      result.push(currentOutputIndex);\n    }\n\n    if (result.length !== valueRowIds.length) {\n      throw new Error('Invalid row ids.');\n    }\n\n    return result;\n  }\n\n  private calculateOutputIndex(\n      dimension: number, parentOutputIndex: number[],\n      outputIndexMultiplier: number, outputSize: number) {\n    const rowPartitionTensor = this.getRowPartitionTensor(dimension);\n    const partitionType = this.getRowPartitionTypeByDimension(dimension);\n    switch (partitionType) {\n      case RowPartitionType.VALUE_ROWIDS:\n        return this.calculateOutputIndexValueRowID(\n            rowPartitionTensor, parentOutputIndex, outputIndexMultiplier,\n            outputSize);\n      case RowPartitionType.ROW_SPLITS:\n        if (rowPartitionTensor.length - 1 > parentOutputIndex.length) {\n          throw new Error(`Row partition size is greater than output size: ${\n              rowPartitionTensor.length - 1} > ${parentOutputIndex.length}`);\n        }\n        return this.calculateOutputIndexRowSplit(\n            rowPartitionTensor, parentOutputIndex, outputIndexMultiplier,\n            outputSize);\n      default:\n        throw new Error(\n            `Unsupported partition type: ${RowPartitionType[partitionType]}`);\n    }\n  }\n\n  private getFirstDimensionSize() {\n    const firstPartitionTensor = this.rowPartitionValues[0];\n    if (this.rowPartitionTypes.length === 0) {\n      throw new Error('No row_partition_types given.');\n    }\n    const firstPartitionType = this.rowPartitionTypes[0];\n    switch (firstPartitionType) {\n      case RowPartitionType.FIRST_DIM_SIZE:\n        return firstPartitionTensor[0];\n      case RowPartitionType.VALUE_ROWIDS:\n        throw new Error('Cannot handle VALUE_ROWIDS in first dimension.');\n      case RowPartitionType.ROW_SPLITS:\n        return this.rowPartitionValuesShapes[0][0] - 1;\n      default:\n        throw new Error(\n            `Cannot handle type ${RowPartitionType[firstPartitionType]}`);\n    }\n  }\n\n  compute(): [number[], TypedArray] {\n    const firstPartitionTensor = this.rowPartitionValues[0];\n    if (firstPartitionTensor.length <= 0) {\n      throw new Error(\n          'Invalid first partition input. ' +\n          'Tensor requires at least one element.');\n    }\n    const firstDimension = this.getFirstDimensionSize();\n    const outputSize = this.calculateOutputSize(firstDimension);\n    const multiplier: number[] = new Array(this.raggedRank + 1);\n\n    multiplier[multiplier.length - 1] = 1;\n    for (let i = multiplier.length - 2; i >= 0; --i) {\n      multiplier[i] = multiplier[i + 1] * outputSize[i + 1];\n    }\n    // Full size of the tensor.\n    const outputShape: number[] = makeShape(outputSize, false);\n    const outputTensor =\n        util.getArrayFromDType(\n            this.valuesDType, util.sizeFromShape(outputShape)) as TypedArray;\n\n    const fullSize = multiplier[0] * outputSize[0];\n    if (fullSize > 0) {\n      let outputIndex = this.calculateFirstParentOutputIndex(\n          firstDimension, multiplier[0], outputSize[0]);\n      for (let i = 1; i <= this.raggedRank; ++i) {\n        const newOutputIndex = this.calculateOutputIndex(\n            i - 1, outputIndex, multiplier[i], outputSize[i]);\n        outputIndex = newOutputIndex;\n      }\n\n      this.setOutput(this.raggedRank, outputIndex, outputTensor, outputShape);\n    }\n\n    return [outputShape, outputTensor];\n  }\n  setOutput(\n      raggedRank: number, outputIndex: number[], outputTensor: TypedArray,\n      outputShape: number[]) {\n    if (outputTensor.length === 0) {\n      return;\n    }\n\n    const valuesBase = this.values;\n    const outputBase = outputTensor;\n\n    let elementShape = outputShape.slice();\n    elementShape = elementShape.slice(raggedRank + 1);\n    const valueElementSize = util.sizeFromShape(elementShape);\n    const outputIndexSize = outputIndex.length;\n\n    // Broadcast the default value to value_element_size.  (We can skip this\n    // if defaultValueTensor.size == 1, since we use fill when that's true.)\n    let defaultValue = this.defaultValue;\n    if (defaultValue.length !== valueElementSize && defaultValue.length !== 1) {\n      const srcShape = this.defaultValueShape;\n      tidy(() => {\n        const defaultValueTensor = reshape(defaultValue, srcShape);\n        const bCastDefault = broadcastTo(defaultValueTensor, elementShape);\n        defaultValue = bCastDefault.dataSync();\n      });\n    }\n\n    // Loop through the outputIndex array, finding contiguous regions that\n    // should be copied.  Once we find the end of a contiguous region, copy it\n    // and add any necessary padding (with defaultValue).\n    let srcStart = 0;  // Start of contiguous region (in values)\n    let dstStart = 0;  // Destination for contiguous region (in output)\n    let dstEnd = 0;    // Destination for contiguous region (in output)\n    for (let srcI = 0; srcI <= outputIndexSize; ++srcI) {\n      // dstI is the destination where the value at srcI should be copied.\n      let dstI = srcI < outputIndexSize ? outputIndex[srcI] : -1;\n\n      // If we're still in a contiguous region, then update dstEnd go to the\n      // next srcI.\n      if (dstI === dstEnd) {\n        ++dstEnd;\n        continue;\n      }\n\n      // We found the end of contiguous region.  This can be because we found\n      // a gap (dstI > dstEnd), or a source value that shouldn't be copied\n      // because it's out-of-bounds (dstI == -1), or the end of the tensor\n      // (dstI === -1).\n      if (dstStart < dstEnd) {\n        // Copy the contiguous region.\n        const src = valuesBase.subarray(srcStart * valueElementSize);\n        const dst = outputBase.subarray(dstStart * valueElementSize);\n        const nVals = (dstEnd - dstStart) * valueElementSize;\n        copyArray(dst, src, nVals);\n      }\n\n      // Add any necessary padding (w/ defaultValue).\n      if (srcI >= outputIndexSize) {\n        // We reached the end of values: pad to the end of output.\n        const outputSize = outputTensor.length;\n        dstI = Math.floor(outputSize / valueElementSize);\n      }\n      if (dstI > dstEnd) {\n        if (this.defaultValue.length === 1) {\n          outputBase\n              .subarray(dstEnd * valueElementSize, dstI * valueElementSize)\n              .fill(this.defaultValue[0]);\n          dstEnd = dstI;\n        } else {\n          while (dstI > dstEnd) {\n            const dst = outputBase.slice(dstEnd * valueElementSize);\n            copyArray(dst, defaultValue, valueElementSize);\n            ++dstEnd;\n          }\n        }\n      }\n\n      // Update indices.\n      if (dstI < 0) {\n        // srcI should be skipped -- leave it out of the contiguous region.\n        srcStart = srcI + 1;\n        dstStart = dstEnd;\n      } else {\n        // srcI should be copied -- include it in the contiguous region.\n        srcStart = srcI;\n        dstStart = dstEnd;\n        dstEnd = dstStart + 1;\n      }\n    }\n  }\n}\n\nfunction copyArray(dst: TypedArray, src: TypedArray, size: number) {\n  for (let i = 0; i < size; i++) {\n    dst[i] = src[i];\n  }\n}\n\nfunction makeShape(shape: number[]|TypedArray, isPartial: boolean) {\n  const out: number[] = [];\n  for (let dim of shape) {\n    if (dim < 0) {\n      if (!isPartial) {\n        throw new Error(`Dimension ${dim} must be >= 0`);\n      }\n      if (dim < -1) {\n        throw new Error(`Dimension ${dim} must be >= -1`);\n      }\n      dim = -1;\n    }\n    out.push(dim);\n  }\n\n  return out;\n}\n\nexport function raggedTensorToTensorImpl(\n    shape: TypedArray, shapesShape: number[], values: TypedArray,\n    valuesShape: number[], valuesDType: DataType, defaultValue: TypedArray,\n    defaultValueShape: number[], rowPartitionValues: TypedArray[],\n    rowPartitionValuesShapes: number[][],\n    rowPartitionTypes: string[]): [number[], TypedArray] {\n  return new RaggedTensorToTensorOp(\n             shape, shapesShape, values, valuesShape, valuesDType, defaultValue,\n             defaultValueShape, rowPartitionValues, rowPartitionValuesShapes,\n             rowPartitionTypes)\n      .compute();\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}