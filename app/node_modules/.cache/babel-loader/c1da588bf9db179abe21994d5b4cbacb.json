{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { serialization } from '@tensorflow/tfjs-core';\nimport { getUid } from '../backend/state';\nimport { ValueError } from '../errors';\nimport { Layer, Node, SymbolicTensor } from './topology';\nexport class InputLayer extends Layer {\n  constructor(args) {\n    super({\n      dtype: args.dtype,\n      name: args.name != null ? args.name : getUid('input').toString()\n    });\n    // Normalize config.batchSize and config.sparse\n    if (args.batchSize == null) {\n      args.batchSize = null;\n    }\n    if (args.sparse == null) {\n      args.sparse = false;\n    }\n    this.trainable = false;\n    this.built = true;\n    this.sparse = args.sparse;\n    if (args.inputShape != null && args.batchInputShape != null) {\n      throw new ValueError('Only provide the inputShape OR ' + 'batchInputShape argument to inputLayer, not both at the same time.');\n    }\n    let batchInputShape = args.batchInputShape;\n    if (batchInputShape == null) {\n      if (args.inputShape == null) {\n        throw new ValueError('An InputLayer should be passed either a ' + '`batchInputShape` or an `inputShape`.');\n      } else {\n        batchInputShape = [args.batchSize].concat(args.inputShape);\n      }\n    } else {\n      // TODO(michaelterry): Backport to PyKeras\n      if (args.batchSize != null) {\n        throw new ValueError('Cannot specify batchSize if batchInputShape is ' + 'specified when creating an InputLayer.');\n      }\n    }\n    const dtype = args.dtype || 'float32';\n    this.batchInputShape = batchInputShape;\n    this.dtype = dtype;\n    // TODO(michaelterry): Backport this to PyKeras?\n    this.inputSpec = [{\n      shape: batchInputShape\n    }];\n    const inputTensor = new SymbolicTensor(this.dtype, this.batchInputShape, this, [], {}, this.name);\n    inputTensor.nodeIndex = 0;\n    inputTensor.tensorIndex = 0;\n    // Create an input node to add to this.outboundNode.\n    // (This call has side effects.)\n    // tslint:disable-next-line:no-unused-expression\n    new Node({\n      outboundLayer: this,\n      inboundLayers: [],\n      nodeIndices: [],\n      tensorIndices: [],\n      inputTensors: [inputTensor],\n      outputTensors: [inputTensor],\n      inputMasks: [null],\n      outputMasks: [null],\n      inputShapes: [batchInputShape],\n      outputShapes: [batchInputShape]\n    });\n  }\n  apply(inputs, kwargs) {\n    throw new ValueError('Cannot pass any input to an ' + `InputLayer's apply() method. InputLayer name: ${this.name}`);\n  }\n  dispose() {\n    // dispose() for InputLayer is overridden as no-op.\n    return {\n      refCountAfterDispose: this._refCount,\n      numDisposedVariables: 0\n    };\n  }\n  getConfig() {\n    return {\n      batchInputShape: this.batchInputShape,\n      dtype: this.dtype,\n      sparse: this.sparse,\n      name: this.name\n    };\n  }\n}\n/** @nocollapse */\nInputLayer.className = 'InputLayer';\nserialization.registerClass(InputLayer);\nexport function Input(config) {\n  if (config.batchShape == null && config.shape == null) {\n    throw new Error('Please provide to Input either a `shape`' + ' or a `batchShape` argument. Note that ' + '`shape` does not include the batch ' + 'dimension.');\n  }\n  if (config.batchShape != null && config.shape != null) {\n    // TODO(michaelterry): Backport to PyKeras.\n    throw new ValueError('Please provide either a `shape` or `batchShape` ' + 'argument to Input, but not both.');\n  }\n  let batchShape = config.batchShape;\n  if (config.shape != null && batchShape == null) {\n    batchShape = [null].concat(config.shape);\n  }\n  let dtype = config.dtype;\n  if (dtype == null) {\n    dtype = 'float32';\n  }\n  const inputLayer = new InputLayer({\n    batchInputShape: batchShape,\n    name: config.name,\n    dtype,\n    sparse: config.sparse\n  });\n  const outputs = inputLayer.inboundNodes[0].outputTensors;\n  return outputs[0];\n}","map":{"version":3,"sources":["../../src/engine/input_layer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { serialization } from '@tensorflow/tfjs-core';\nimport { getUid } from '../backend/state';\nimport { ValueError } from '../errors';\nimport { Layer, Node, SymbolicTensor } from './topology';\nexport class InputLayer extends Layer {\n    constructor(args) {\n        super({\n            dtype: args.dtype,\n            name: args.name != null ? args.name : getUid('input').toString()\n        });\n        // Normalize config.batchSize and config.sparse\n        if (args.batchSize == null) {\n            args.batchSize = null;\n        }\n        if (args.sparse == null) {\n            args.sparse = false;\n        }\n        this.trainable = false;\n        this.built = true;\n        this.sparse = args.sparse;\n        if (args.inputShape != null && args.batchInputShape != null) {\n            throw new ValueError('Only provide the inputShape OR ' +\n                'batchInputShape argument to inputLayer, not both at the same time.');\n        }\n        let batchInputShape = args.batchInputShape;\n        if (batchInputShape == null) {\n            if (args.inputShape == null) {\n                throw new ValueError('An InputLayer should be passed either a ' +\n                    '`batchInputShape` or an `inputShape`.');\n            }\n            else {\n                batchInputShape = [args.batchSize].concat(args.inputShape);\n            }\n        }\n        else {\n            // TODO(michaelterry): Backport to PyKeras\n            if (args.batchSize != null) {\n                throw new ValueError('Cannot specify batchSize if batchInputShape is ' +\n                    'specified when creating an InputLayer.');\n            }\n        }\n        const dtype = args.dtype || 'float32';\n        this.batchInputShape = batchInputShape;\n        this.dtype = dtype;\n        // TODO(michaelterry): Backport this to PyKeras?\n        this.inputSpec = [{ shape: batchInputShape }];\n        const inputTensor = new SymbolicTensor(this.dtype, this.batchInputShape, this, [], {}, this.name);\n        inputTensor.nodeIndex = 0;\n        inputTensor.tensorIndex = 0;\n        // Create an input node to add to this.outboundNode.\n        // (This call has side effects.)\n        // tslint:disable-next-line:no-unused-expression\n        new Node({\n            outboundLayer: this,\n            inboundLayers: [],\n            nodeIndices: [],\n            tensorIndices: [],\n            inputTensors: [inputTensor],\n            outputTensors: [inputTensor],\n            inputMasks: [null],\n            outputMasks: [null],\n            inputShapes: [batchInputShape],\n            outputShapes: [batchInputShape]\n        });\n    }\n    apply(inputs, kwargs) {\n        throw new ValueError('Cannot pass any input to an ' +\n            `InputLayer's apply() method. InputLayer name: ${this.name}`);\n    }\n    dispose() {\n        // dispose() for InputLayer is overridden as no-op.\n        return { refCountAfterDispose: this._refCount, numDisposedVariables: 0 };\n    }\n    getConfig() {\n        return {\n            batchInputShape: this.batchInputShape,\n            dtype: this.dtype,\n            sparse: this.sparse,\n            name: this.name\n        };\n    }\n}\n/** @nocollapse */\nInputLayer.className = 'InputLayer';\nserialization.registerClass(InputLayer);\nexport function Input(config) {\n    if (config.batchShape == null && config.shape == null) {\n        throw new Error('Please provide to Input either a `shape`' +\n            ' or a `batchShape` argument. Note that ' +\n            '`shape` does not include the batch ' +\n            'dimension.');\n    }\n    if (config.batchShape != null && config.shape != null) {\n        // TODO(michaelterry): Backport to PyKeras.\n        throw new ValueError('Please provide either a `shape` or `batchShape` ' +\n            'argument to Input, but not both.');\n    }\n    let batchShape = config.batchShape;\n    if (config.shape != null && batchShape == null) {\n        batchShape = [null].concat(config.shape);\n    }\n    let dtype = config.dtype;\n    if (dtype == null) {\n        dtype = 'float32';\n    }\n    const inputLayer = new InputLayer({\n        batchInputShape: batchShape,\n        name: config.name,\n        dtype,\n        sparse: config.sparse\n    });\n    const outputs = inputLayer.inboundNodes[0].outputTensors;\n    return outputs[0];\n}\n//# sourceMappingURL=input_layer.js.map"]},"metadata":{},"sourceType":"module"}