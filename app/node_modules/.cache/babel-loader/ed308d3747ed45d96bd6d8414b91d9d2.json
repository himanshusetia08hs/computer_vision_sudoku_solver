{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * TensorFlow.js Layers: Merge Layers.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy, util } from '@tensorflow/tfjs-core';\nimport * as K from '../backend/tfjs_backend';\nimport { Layer } from '../engine/topology';\nimport { NotImplementedError, ValueError } from '../errors';\nimport { l2Normalize } from '../losses';\nimport * as generic_utils from '../utils/generic_utils';\nimport * as mathUtils from '../utils/math_utils';\nimport { getExactlyOneShape } from '../utils/types_utils';\n/**\n * Generic Merge layer for element-wise merge functions.\n *\n * Used to implement `Sum`, `Average`, `Concatenate`, etc.\n */\nexport class Merge extends Layer {\n  constructor(args) {\n    super(args || {});\n    this.supportsMasking = true;\n  }\n  /**\n   * Logic for merging multiple tensors, to be overridden by subclasses.\n   * @param inputs\n   */\n  mergeFunction(inputs) {\n    throw new NotImplementedError();\n  }\n  /**\n   * Computes the shape of the result of an elementwise operation.\n   *\n   * @param shape1: Shape of the first tensor.\n   * @param shape2: Shape of the second tensor.\n   * @returns Expected output shape when an elementwise operation is carried\n   *   out on 2 tensors with shapes `shape1` and `shape2`.\n   * @throws ValueError: If `shape1` and `shape2` are not compatible for\n   *   element-wise operations.\n   */\n  computeElementwiseOpOutputShape(shape1, shape2) {\n    if (shape1 == null || shape2 == null) {\n      return null;\n    } else if (shape1.length < shape2.length) {\n      return this.computeElementwiseOpOutputShape(shape2, shape1);\n    } else if (shape2.length === 0) {\n      return shape1;\n    }\n    const outputShape = shape1.slice(0, shape1.length - shape2.length);\n    for (let k = 0; k < shape2.length; ++k) {\n      const i = shape1[shape1.length - shape2.length + k];\n      const j = shape2[k];\n      if (i == null || j == null || i < 0 || j < 0) {\n        outputShape.push(null);\n      } else if (i === 1) {\n        outputShape.push(j);\n      } else if (j === 1) {\n        outputShape.push(i);\n      } else {\n        if (i !== j) {\n          throw new ValueError('Operands could not be broadcast together with shapes ' + JSON.stringify(shape1) + ' ' + JSON.stringify(shape2));\n        }\n        outputShape.push(i);\n      }\n    }\n    return outputShape;\n  }\n  build(inputShape) {\n    // Used purely for shape validation.\n    if (Array.isArray(inputShape) && !Array.isArray(inputShape[0])) {\n      // Make sure that inputShape is an Array of shape.\n      inputShape = [getExactlyOneShape(inputShape)];\n    }\n    inputShape = inputShape;\n    if (inputShape.length < 2) {\n      throw new ValueError('A merge layer should be called on an Array of at least 2 inputs.' + ` Got ${inputShape.length} input(s).`);\n    }\n    // Make sure that there is at most one unique batch size among the input\n    // shapes.\n    let batchSizes = [];\n    for (const shape of inputShape) {\n      if (shape != null && shape[0] !== null) {\n        batchSizes.push(shape[0]);\n      }\n    }\n    batchSizes = generic_utils.unique(batchSizes);\n    if (batchSizes.length > 1) {\n      throw new ValueError(`Can not merge tensors with different batch sizes. ` + `Got tensors with shapes: ${JSON.stringify(inputShape)}.`);\n    }\n    let outputShape = inputShape[0] == null ? null : inputShape[0].slice(1);\n    for (let i = 1; i < inputShape.length; ++i) {\n      const shape = inputShape[i] == null ? null : inputShape[i].slice(1);\n      outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);\n    }\n    // If the inputs have different ranks, we have to reshape them to make them\n    // broadcastable.\n    const allRanks = inputShape.map(shape => shape.length);\n    if (inputShape.indexOf(null) === -1 && generic_utils.unique(allRanks).length === 1) {\n      this.reshapeRequired = false;\n    } else {\n      this.reshapeRequired = true;\n    }\n  }\n  call(inputs, kwargs) {\n    return tidy(() => {\n      inputs = inputs;\n      if (this.reshapeRequired) {\n        const reshapedInputs = [];\n        const inputDims = inputs.map(input => input.rank);\n        if (inputDims.indexOf(null) === -1) {\n          // If ranks of all inputs are available, we simply expand each of them\n          // at axis=1 until all of them have the same rank.\n          const maxNDim = mathUtils.max(inputDims);\n          for (let x of inputs) {\n            const xNDim = x.rank;\n            for (let k = 0; k < maxNDim - xNDim; ++k) {\n              x = K.expandDims(x, 1);\n            }\n            reshapedInputs.push(x);\n          }\n          return this.mergeFunction(reshapedInputs);\n        } else {\n          // Transpose all inputs so that batch size is the last dimension.\n          // [batchSize, dim1, dim2, ...] -> [dim1, dim2, ..., batchSize]\n          let transposed = false;\n          for (const x of inputs) {\n            const xNDim = x.rank;\n            if (xNDim == null) {\n              const xShape = x.shape;\n              const batchSize = xShape[0];\n              const newShape = xShape.slice(1).concat([batchSize]);\n              let xTransposed = x.reshape([batchSize].concat(mathUtils.arrayProd(xShape.slice(1))));\n              xTransposed = tfc.transpose(xTransposed, [1, 0]);\n              xTransposed = xTransposed.reshape(newShape);\n              reshapedInputs.push(xTransposed);\n              transposed = true;\n            } else if (xNDim > 1) {\n              const dims = mathUtils.range(1, xNDim).concat([0]);\n              reshapedInputs.push(tfc.transpose(x, dims));\n              transposed = true;\n            } else {\n              // We don't transpose inputs if they are 1D vectors or scalars.\n              reshapedInputs.push(x);\n            }\n          }\n          let y = this.mergeFunction(reshapedInputs);\n          const yNDim = y.rank;\n          if (transposed) {\n            // If inputs have been transposed, we have to transpose the output\n            // too.\n            if (yNDim == null) {\n              const yShape = y.shape;\n              const yNDim = yShape.length;\n              const batchSize = yShape[yNDim - 1];\n              const newShape = [batchSize].concat(yShape.slice(0, yShape.length - 1));\n              y = tfc.transpose(y.reshape([-1, batchSize]), [1, 0]).reshape(newShape);\n            } else if (yNDim > 1) {\n              const dims = [yNDim - 1].concat(mathUtils.range(0, yNDim - 1));\n              y = tfc.transpose(y, dims);\n            }\n          }\n          return y;\n        }\n      } else {\n        return this.mergeFunction(inputs);\n      }\n    });\n  }\n  computeOutputShape(inputShape) {\n    inputShape = inputShape;\n    let outputShape;\n    if (inputShape[0] == null) {\n      outputShape = null;\n    } else {\n      outputShape = inputShape[0].slice(1);\n    }\n    for (let i = 1; i < inputShape.length; ++i) {\n      const shape = inputShape[i] == null ? null : inputShape[i].slice(1);\n      outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);\n    }\n    let batchSizes = [];\n    for (const shape of inputShape) {\n      if (shape != null && shape[0] !== null) {\n        batchSizes.push(shape[0]);\n      }\n    }\n    batchSizes = generic_utils.unique(batchSizes);\n    if (batchSizes.length === 1) {\n      outputShape = batchSizes.concat(outputShape);\n    } else {\n      outputShape = [null].concat(outputShape);\n    }\n    return outputShape;\n  }\n  computeMask(inputs, mask) {\n    return tfc.tidy(() => {\n      if (mask == null) {\n        return null;\n      }\n      if (!Array.isArray(mask)) {\n        throw new ValueError('`mask` should be an Array');\n      }\n      if (!Array.isArray(inputs)) {\n        throw new ValueError('`inputs` should be an Array');\n      }\n      if (mask.length !== inputs.length) {\n        throw new ValueError(`The Array 'inputs' and 'mask' are expected to have the same ` + `length, but have different lengths ` + `(${inputs.length} vs ${mask.length})`);\n      }\n      if (mask.every(m => m == null)) {\n        return null;\n      }\n      mask = mask.map(m => m == null ? m : tfc.expandDims(m, 0));\n      let output = mask[0];\n      for (let i = 1; i < mask.length - 1; ++i) {\n        output = tfc.logicalAnd(output, mask[i]);\n      }\n      return output;\n    });\n  }\n}\nexport class Add extends Merge {\n  constructor(args) {\n    super(args);\n  }\n  mergeFunction(inputs) {\n    return tidy(() => {\n      let output = inputs[0].clone();\n      for (let i = 1; i < inputs.length; ++i) {\n        output = tfc.add(output, inputs[i]);\n      }\n      return output;\n    });\n  }\n}\n/** @nocollapse */\nAdd.className = 'Add';\nserialization.registerClass(Add);\n/**\n * Calculate the element-wise sum of inputs, which all have the same shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Add` layer, by using no input argument\n *    or a single configuration argument. The resultant `Add` layer can then\n *    be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const addLayer = tf.layers.add();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = addLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.add([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n * const input2 = tf.tensor2d([10, 20, 30, 40], [2, 2]);\n * tf.layers.add([input1, input2]).print();\n * // Gives [[11, 22], [33, 44]].\n *\n */\nexport function add(config) {\n  if (Array.isArray(config)) {\n    const layer = new Add({});\n    return layer.apply(config);\n  } else {\n    return new Add(config);\n  }\n}\nexport class Multiply extends Merge {\n  constructor(args) {\n    super(args);\n  }\n  mergeFunction(inputs) {\n    return tidy(() => {\n      let output = inputs[0].clone();\n      for (let i = 1; i < inputs.length; ++i) {\n        output = tfc.mul(output, inputs[i]);\n      }\n      return output;\n    });\n  }\n}\n/** @nocollapse */\nMultiply.className = 'Multiply';\nserialization.registerClass(Multiply);\n/**\n * Calculate the element-wise product of inputs, which all have the same shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Multiply` layer, by using no input argument\n *    or a single configuration argument. The resultant `Multiply` layer can\n *    then be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const multiplyLayer = tf.layers.multiply();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = multiplyLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.multiply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n * const input2 = tf.tensor2d([10, 20, 30, 40], [2, 2]);\n * tf.layers.multiply([input1, input2]).print();\n * // Gives [[10, 40], [90, 160]].\n *\n */\nexport function multiply(config) {\n  if (Array.isArray(config)) {\n    const layer = new Multiply({});\n    return layer.apply(config);\n  } else {\n    return new Multiply(config);\n  }\n}\nexport class Average extends Merge {\n  constructor(args) {\n    super(args);\n  }\n  mergeFunction(inputs) {\n    return tidy(() => {\n      let output = inputs[0].clone();\n      for (let i = 1; i < inputs.length; ++i) {\n        output = tfc.add(output, inputs[i]);\n      }\n      return tfc.mul(1 / inputs.length, output);\n    });\n  }\n}\n/** @nocollapse */\nAverage.className = 'Average';\nserialization.registerClass(Average);\n/**\n * Calculate the element-wise arithmetic mean of inputs, which all have the same\n * shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Average` layer, by using no input argument\n *    or a single configuration argument. The resultant `Average` layer can then\n *    be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const averageLayer = tf.layers.average();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = averageLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.average([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n * const input2 = tf.tensor2d([10, 20, 30, 40], [2, 2]);\n * tf.layers.average([input1, input2]).print();\n * // Gives [[5.5, 11], [16.5, 22]].\n *\n */\nexport function average(config) {\n  if (Array.isArray(config)) {\n    const layer = new Average({});\n    return layer.apply(config);\n  } else {\n    return new Average(config);\n  }\n}\nexport class Maximum extends Merge {\n  constructor(args) {\n    super(args);\n  }\n  mergeFunction(inputs) {\n    return tidy(() => {\n      let output = inputs[0];\n      for (let i = 1; i < inputs.length; ++i) {\n        output = tfc.maximum(output, inputs[i]);\n      }\n      return output;\n    });\n  }\n}\n/** @nocollapse */\nMaximum.className = 'Maximum';\nserialization.registerClass(Maximum);\n/**\n * Calculate the element-wise maximum of inputs, which all have the same shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Maximum` layer, by using no input argument\n *    or a single configuration argument. The resultant `Maximum` layer can then\n *    be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const maximumLayer = tf.layers.maximum();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = maximumLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.maximum([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 20, 3, 40], [2, 2]);\n * const input2 = tf.tensor2d([10, 2, 30, 4], [2, 2]);\n * tf.layers.maximum([input1, input2]).print();\n * // Gives [[10, 20], [30, 40]].\n *\n */\nexport function maximum(config) {\n  if (Array.isArray(config)) {\n    const layer = new Maximum({});\n    return layer.apply(config);\n  } else {\n    return new Maximum(config);\n  }\n}\nexport class Minimum extends Merge {\n  constructor(args) {\n    super(args);\n  }\n  mergeFunction(inputs) {\n    return tidy(() => {\n      let output = inputs[0];\n      for (let i = 1; i < inputs.length; ++i) {\n        output = tfc.minimum(output, inputs[i]);\n      }\n      return output;\n    });\n  }\n}\n/** @nocollapse */\nMinimum.className = 'Minimum';\nserialization.registerClass(Minimum);\n/**\n * Calculate the element-wise minimum of inputs, which all have the same shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Minimum` layer, by using no input argument\n *    or a single configuration argument. The resultant `Minimum` layer can then\n *    be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const minimumLayer = tf.layers.minimum();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = minimumLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.minimum([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 20, 3, 40], [2, 2]);\n * const input2 = tf.tensor2d([10, 2, 30, 4], [2, 2]);\n * tf.layers.minimum([input1, input2]).print();\n * // Gives [[1, 2], [3, 4]].\n *\n */\nexport function minimum(config) {\n  if (Array.isArray(config)) {\n    const layer = new Minimum({});\n    return layer.apply(config);\n  } else {\n    return new Minimum(config);\n  }\n}\nexport class Concatenate extends Merge {\n  constructor(args) {\n    super(args);\n    this.DEFAULT_AXIS = -1;\n    if (args == null) {\n      args = {};\n    }\n    this.axis = args.axis == null ? this.DEFAULT_AXIS : args.axis;\n    this.supportsMasking = true;\n    this.reshapeRequired = false;\n  }\n  build(inputShape) {\n    // Used purely for shape validation.]\n    if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0])) || inputShape.length === 1) {\n      throw new ValueError('A `Concatenate` layer should be called on a list of at least 2 ' + 'inputs');\n    }\n    inputShape = inputShape;\n    let allNoneShape = true;\n    for (const shape of inputShape) {\n      if (shape != null) {\n        allNoneShape = false;\n        break;\n      }\n    }\n    if (allNoneShape) {\n      return;\n    }\n    const shapeSet = [];\n    for (let i = 0; i < inputShape.length; ++i) {\n      const shapeWithoutConcatAxis = inputShape[i].slice();\n      shapeWithoutConcatAxis.splice(this.axis, 1);\n      let exists = false;\n      for (const shape of shapeSet) {\n        if (util.arraysEqual(shape, shapeWithoutConcatAxis)) {\n          exists = true;\n          break;\n        }\n      }\n      if (!exists) {\n        shapeSet.push(shapeWithoutConcatAxis);\n      }\n    }\n    if (shapeSet.length > 1) {\n      throw new ValueError('A `Concatenate` layer requires inputs with matching shapes ' + 'except for the concat axis. Got input shapes: ' + JSON.stringify(inputShape));\n    }\n  }\n  mergeFunction(inputs) {\n    return tidy(() => {\n      return K.concatenate(inputs, this.axis);\n    });\n  }\n  computeOutputShape(inputShape) {\n    if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0]))) {\n      throw new ValueError('A `Concatenate` layer should be called on a list of inputs.');\n    }\n    const inputShapes = inputShape;\n    const outputShape = inputShapes[0].slice();\n    const axis = this.axis < 0 ? outputShape.length + this.axis : this.axis;\n    // Porting Note: the line above is because TypeScript doesn't support\n    //   negative indices.\n    for (const shape of inputShapes.slice(1)) {\n      if (outputShape[axis] == null || shape[axis] == null) {\n        outputShape[axis] = null;\n        break;\n      }\n      outputShape[axis] += shape[axis];\n    }\n    return outputShape;\n  }\n  computeMask(inputs, mask) {\n    if (mask == null) {\n      return null;\n    }\n    if (!Array.isArray(mask)) {\n      throw new ValueError('`mask` should be an array for Concatenate');\n    }\n    if (!Array.isArray(inputs)) {\n      throw new ValueError('`inputs` should be an array for Concatenate');\n    }\n    if (mask.length !== inputs.length) {\n      throw new ValueError(`Mismatch in the length of mask (${mask.length}) ` + `and the legnth of inputs (${inputs.length})`);\n    }\n    return tfc.tidy(() => {\n      let allNullMasks = true;\n      mask.forEach(m => {\n        if (m != null) {\n          allNullMasks = false;\n          return;\n        }\n      });\n      if (allNullMasks) {\n        return null;\n      }\n      const outputMasks = [];\n      for (let i = 0; i < inputs.length; ++i) {\n        if (mask[i] == null) {\n          // Input is unmasked. Append all 1's to masks.\n          outputMasks.push(tfc.onesLike(inputs[i]).asType('bool'));\n        } else if (mask[i].rank < inputs[i].rank) {\n          // Mask is smaller than the input, expand it.\n          outputMasks.push(tfc.expandDims(mask[i], -1));\n        } else {\n          outputMasks.push(mask[i]);\n        }\n      }\n      const concatenatedMasks = tfc.concat(outputMasks, this.axis);\n      return tfc.all(concatenatedMasks, -1, false);\n    });\n  }\n  getConfig() {\n    const config = {\n      'axis': this.axis\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\n/** @nocollapse */\nConcatenate.className = 'Concatenate';\nserialization.registerClass(Concatenate);\n/**\n * Concatenate an `Array` of inputs.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Concatenate` layer, by using no input argument\n *    or a single configuration argument. The resultant `Concatenate` layer can\n *    then be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const concatLayer = tf.layers.concatenate();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 3]});\n * const input2 = tf.input({shape: [2, 4]});\n * const output = concatLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 7], with the first dimension as the undetermined batch\n * // dimension and the last dimension as the result of concatenating the\n * // last dimensions of the two inputs.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 3]});\n * const input2 = tf.input({shape: [2, 4]});\n * const output = tf.layers.concatenate([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension and the last dimension as the result of concatenating the\n * // last dimensions of the two inputs.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([[1, 2], [3, 4]], [2, 2]);\n * const input2 = tf.tensor2d([[10, 20], [30, 40]], [2, 2]);\n * tf.layers.concatenate([input1, input2]).print();\n * // Gives [[1, 2, 10, 20], [3, 4, 30, 40]].\n *\n */\nexport function concatenate(config) {\n  if (Array.isArray(config)) {\n    const layer = new Concatenate({});\n    return layer.apply(config);\n  } else {\n    return new Concatenate(config);\n  }\n}\n/**\n * Interpretable potentially negative axis index.\n *\n * For example, given axis = -1, and dim = 3, this function will return 2.\n *\n * @param axis The axis index, may be a positive, zero or negative integer.\n * @param dim Total number of dimensions, a positive integer.\n * @returns A non-negative axis index equivalent to the input `axis`.\n */\nfunction interpretAxis(axis, dim) {\n  while (axis < 0) {\n    axis += dim;\n  }\n  return axis;\n}\nfunction batchDot(x, y, axes) {\n  if (x.shape.length > 3 || y.shape.length > 3) {\n    throw new NotImplementedError('batchDot is not implemented for tensors of 4D or higher rank yet');\n  }\n  tfc.util.assert(x.shape.length >= 2, () => `batchDot requires the rank of x to be >= 2, ` + `but got ${x.shape.length}`);\n  tfc.util.assert(x.shape.length >= 2, () => `batchDot requires the rank of y to be >= 2, ` + `but got ${y.shape.length}`);\n  if (typeof axes === 'number') {\n    axes = [axes, axes];\n  }\n  if (x.dtype === 'complex64' || y.dtype === 'complex64') {\n    throw new NotImplementedError('batchDot is not implemented for complex64-type Tensors yet.');\n  }\n  const xNDim = x.shape.length;\n  const yNDim = y.shape.length;\n  if (axes == null) {\n    // Behave like batchMatmul by default.\n    axes = [xNDim - 1, yNDim - 2];\n  }\n  const axesArray = axes;\n  return tfc.tidy(() => {\n    let diff;\n    if (xNDim > yNDim) {\n      diff = xNDim - yNDim;\n      const diffShape = [];\n      for (let i = 0; i < diff; ++i) {\n        diffShape.push(1);\n      }\n      y = y.reshape(y.shape.concat(diffShape));\n    } else if (yNDim > xNDim) {\n      diff = yNDim - xNDim;\n      const diffShape = [];\n      for (let i = 0; i < diff; ++i) {\n        diffShape.push(1);\n      }\n      x = x.reshape(x.shape.concat(diffShape));\n    } else {\n      diff = 0;\n    }\n    let out;\n    if (x.shape.length === 2 && y.shape.length === 2) {\n      if (axesArray[0] === axesArray[1]) {\n        out = x.mul(y).sum(axesArray[0]);\n      } else {\n        out = x.transpose([1, 0]).mul(y).sum(axesArray[1]);\n      }\n    } else {\n      const adjX = axesArray[0] !== x.shape.length - 1;\n      const adjY = axesArray[1] === y.shape.length - 1;\n      out = x.matMul(y, adjX, adjY);\n    }\n    if (diff > 0) {\n      let idx;\n      if (xNDim > yNDim) {\n        idx = xNDim + yNDim - 3;\n      } else {\n        idx = xNDim - 1;\n      }\n      const squeezeAxes = [];\n      for (let i = idx; i < idx + diff; ++i) {\n        squeezeAxes.push(i);\n      }\n      out = out.squeeze(squeezeAxes);\n    }\n    if (out.shape.length === 1) {\n      out = out.expandDims(1);\n    }\n    return out;\n  });\n}\nexport class Dot extends Merge {\n  constructor(args) {\n    super(args);\n    this.axes = args.axes;\n    this.normalize = args.normalize == null ? false : args.normalize;\n    this.supportsMasking = true;\n    this.reshapeRequired = false;\n  }\n  build(inputShape) {\n    tfc.util.assert(Array.isArray(inputShape) && inputShape.length === 2 && Array.isArray(inputShape[0]) && Array.isArray(inputShape[1]), () => 'A `Dot` layer should be called on a list of exactly 2 inputs.');\n    const shape1 = inputShape[0];\n    const shape2 = inputShape[1];\n    if (shape1.length > 3 || shape2.length > 3) {\n      throw new NotImplementedError('Dot layer does not support tensors of 4D or higher rank yet.');\n    }\n    const axes = this.interpretAxes(shape1, shape2);\n    if (shape1[axes[0]] !== shape2[axes[1]]) {\n      throw new ValueError(`Dimension incompatibility: ` + `${shape1[axes[0]]} !== ${shape2[axes[1]]}`);\n    }\n  }\n  mergeFunction(inputs) {\n    if (inputs.length !== 2) {\n      throw new ValueError('A `Dot` layer must be called on exactly 2 inputs, ' + `but received ${inputs.length} input(s).`);\n    }\n    let x1 = inputs[0];\n    let x2 = inputs[1];\n    let axes;\n    if (!Array.isArray(this.axes)) {\n      axes = [interpretAxis(this.axes, x1.shape.length), interpretAxis(this.axes, x2.shape.length)];\n    } else {\n      axes = this.axes.map((axis, i) => interpretAxis(axis, inputs[i].shape.length));\n    }\n    if (this.normalize) {\n      x1 = l2Normalize(x1, axes[0]);\n      x2 = l2Normalize(x2, axes[1]);\n    }\n    return batchDot(x1, x2, axes);\n  }\n  interpretAxes(shape1, shape2) {\n    let axes;\n    if (!Array.isArray(this.axes)) {\n      // `this.axes` is a single integer.\n      axes = [interpretAxis(this.axes, shape1.length), interpretAxis(this.axes, shape2.length)];\n    } else {\n      // `this.axes` is an Array of integers.\n      axes = this.axes;\n    }\n    return axes;\n  }\n  computeOutputShape(inputShape) {\n    tfc.util.assert(Array.isArray(inputShape) && inputShape.length === 2 && Array.isArray(inputShape[0]) && Array.isArray(inputShape[1]), () => 'A `Dot` layer should be called on a list of exactly 2 inputs.');\n    const shape1 = inputShape[0].slice();\n    const shape2 = inputShape[1].slice();\n    if (shape1.length > 3 || shape2.length > 3) {\n      throw new NotImplementedError('Dot layer does not support tensors of 4D or higher rank yet.');\n    }\n    const axes = this.interpretAxes(shape1, shape2);\n    shape1.splice(axes[0], 1);\n    shape2.splice(axes[1], 1);\n    shape2.splice(0, 1);\n    const outputShape = shape1.concat(shape2);\n    if (outputShape.length === 1) {\n      outputShape.push(1);\n    }\n    return outputShape;\n  }\n  computeMask(inputs, mask) {\n    return null;\n  }\n  getConfig() {\n    const config = {\n      'axes': this.axes,\n      'normalize': this.normalize\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\n/** @nocollapse */\nDot.className = 'Dot';\nserialization.registerClass(Dot);\n// TODO(cais): Add functional interfaces for the merge layers.","map":{"version":3,"sources":["../../src/layers/merge.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * TensorFlow.js Layers: Merge Layers.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy, util } from '@tensorflow/tfjs-core';\nimport * as K from '../backend/tfjs_backend';\nimport { Layer } from '../engine/topology';\nimport { NotImplementedError, ValueError } from '../errors';\nimport { l2Normalize } from '../losses';\nimport * as generic_utils from '../utils/generic_utils';\nimport * as mathUtils from '../utils/math_utils';\nimport { getExactlyOneShape } from '../utils/types_utils';\n/**\n * Generic Merge layer for element-wise merge functions.\n *\n * Used to implement `Sum`, `Average`, `Concatenate`, etc.\n */\nexport class Merge extends Layer {\n    constructor(args) {\n        super(args || {});\n        this.supportsMasking = true;\n    }\n    /**\n     * Logic for merging multiple tensors, to be overridden by subclasses.\n     * @param inputs\n     */\n    mergeFunction(inputs) {\n        throw new NotImplementedError();\n    }\n    /**\n     * Computes the shape of the result of an elementwise operation.\n     *\n     * @param shape1: Shape of the first tensor.\n     * @param shape2: Shape of the second tensor.\n     * @returns Expected output shape when an elementwise operation is carried\n     *   out on 2 tensors with shapes `shape1` and `shape2`.\n     * @throws ValueError: If `shape1` and `shape2` are not compatible for\n     *   element-wise operations.\n     */\n    computeElementwiseOpOutputShape(shape1, shape2) {\n        if (shape1 == null || shape2 == null) {\n            return null;\n        }\n        else if (shape1.length < shape2.length) {\n            return this.computeElementwiseOpOutputShape(shape2, shape1);\n        }\n        else if (shape2.length === 0) {\n            return shape1;\n        }\n        const outputShape = shape1.slice(0, shape1.length - shape2.length);\n        for (let k = 0; k < shape2.length; ++k) {\n            const i = shape1[shape1.length - shape2.length + k];\n            const j = shape2[k];\n            if (i == null || j == null || i < 0 || j < 0) {\n                outputShape.push(null);\n            }\n            else if (i === 1) {\n                outputShape.push(j);\n            }\n            else if (j === 1) {\n                outputShape.push(i);\n            }\n            else {\n                if (i !== j) {\n                    throw new ValueError('Operands could not be broadcast together with shapes ' +\n                        JSON.stringify(shape1) + ' ' + JSON.stringify(shape2));\n                }\n                outputShape.push(i);\n            }\n        }\n        return outputShape;\n    }\n    build(inputShape) {\n        // Used purely for shape validation.\n        if (Array.isArray(inputShape) && !Array.isArray(inputShape[0])) {\n            // Make sure that inputShape is an Array of shape.\n            inputShape = [getExactlyOneShape(inputShape)];\n        }\n        inputShape = inputShape;\n        if (inputShape.length < 2) {\n            throw new ValueError('A merge layer should be called on an Array of at least 2 inputs.' +\n                ` Got ${inputShape.length} input(s).`);\n        }\n        // Make sure that there is at most one unique batch size among the input\n        // shapes.\n        let batchSizes = [];\n        for (const shape of inputShape) {\n            if (shape != null && shape[0] !== null) {\n                batchSizes.push(shape[0]);\n            }\n        }\n        batchSizes = generic_utils.unique(batchSizes);\n        if (batchSizes.length > 1) {\n            throw new ValueError(`Can not merge tensors with different batch sizes. ` +\n                `Got tensors with shapes: ${JSON.stringify(inputShape)}.`);\n        }\n        let outputShape = inputShape[0] == null ? null : inputShape[0].slice(1);\n        for (let i = 1; i < inputShape.length; ++i) {\n            const shape = inputShape[i] == null ? null : inputShape[i].slice(1);\n            outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);\n        }\n        // If the inputs have different ranks, we have to reshape them to make them\n        // broadcastable.\n        const allRanks = inputShape.map(shape => shape.length);\n        if (inputShape.indexOf(null) === -1 &&\n            generic_utils.unique(allRanks).length === 1) {\n            this.reshapeRequired = false;\n        }\n        else {\n            this.reshapeRequired = true;\n        }\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            inputs = inputs;\n            if (this.reshapeRequired) {\n                const reshapedInputs = [];\n                const inputDims = inputs.map(input => input.rank);\n                if (inputDims.indexOf(null) === -1) {\n                    // If ranks of all inputs are available, we simply expand each of them\n                    // at axis=1 until all of them have the same rank.\n                    const maxNDim = mathUtils.max(inputDims);\n                    for (let x of inputs) {\n                        const xNDim = x.rank;\n                        for (let k = 0; k < maxNDim - xNDim; ++k) {\n                            x = K.expandDims(x, 1);\n                        }\n                        reshapedInputs.push(x);\n                    }\n                    return this.mergeFunction(reshapedInputs);\n                }\n                else {\n                    // Transpose all inputs so that batch size is the last dimension.\n                    // [batchSize, dim1, dim2, ...] -> [dim1, dim2, ..., batchSize]\n                    let transposed = false;\n                    for (const x of inputs) {\n                        const xNDim = x.rank;\n                        if (xNDim == null) {\n                            const xShape = x.shape;\n                            const batchSize = xShape[0];\n                            const newShape = xShape.slice(1).concat([batchSize]);\n                            let xTransposed = x.reshape([batchSize].concat(mathUtils.arrayProd(xShape.slice(1))));\n                            xTransposed = tfc.transpose(xTransposed, [1, 0]);\n                            xTransposed = xTransposed.reshape(newShape);\n                            reshapedInputs.push(xTransposed);\n                            transposed = true;\n                        }\n                        else if (xNDim > 1) {\n                            const dims = mathUtils.range(1, xNDim).concat([0]);\n                            reshapedInputs.push(tfc.transpose(x, dims));\n                            transposed = true;\n                        }\n                        else {\n                            // We don't transpose inputs if they are 1D vectors or scalars.\n                            reshapedInputs.push(x);\n                        }\n                    }\n                    let y = this.mergeFunction(reshapedInputs);\n                    const yNDim = y.rank;\n                    if (transposed) {\n                        // If inputs have been transposed, we have to transpose the output\n                        // too.\n                        if (yNDim == null) {\n                            const yShape = y.shape;\n                            const yNDim = yShape.length;\n                            const batchSize = yShape[yNDim - 1];\n                            const newShape = [batchSize].concat(yShape.slice(0, yShape.length - 1));\n                            y = tfc.transpose(y.reshape([-1, batchSize]), [1, 0])\n                                .reshape(newShape);\n                        }\n                        else if (yNDim > 1) {\n                            const dims = [yNDim - 1].concat(mathUtils.range(0, yNDim - 1));\n                            y = tfc.transpose(y, dims);\n                        }\n                    }\n                    return y;\n                }\n            }\n            else {\n                return this.mergeFunction(inputs);\n            }\n        });\n    }\n    computeOutputShape(inputShape) {\n        inputShape = inputShape;\n        let outputShape;\n        if (inputShape[0] == null) {\n            outputShape = null;\n        }\n        else {\n            outputShape = inputShape[0].slice(1);\n        }\n        for (let i = 1; i < inputShape.length; ++i) {\n            const shape = inputShape[i] == null ? null : inputShape[i].slice(1);\n            outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);\n        }\n        let batchSizes = [];\n        for (const shape of inputShape) {\n            if (shape != null && shape[0] !== null) {\n                batchSizes.push(shape[0]);\n            }\n        }\n        batchSizes = generic_utils.unique(batchSizes);\n        if (batchSizes.length === 1) {\n            outputShape = batchSizes.concat(outputShape);\n        }\n        else {\n            outputShape = [null].concat(outputShape);\n        }\n        return outputShape;\n    }\n    computeMask(inputs, mask) {\n        return tfc.tidy(() => {\n            if (mask == null) {\n                return null;\n            }\n            if (!Array.isArray(mask)) {\n                throw new ValueError('`mask` should be an Array');\n            }\n            if (!Array.isArray(inputs)) {\n                throw new ValueError('`inputs` should be an Array');\n            }\n            if (mask.length !== inputs.length) {\n                throw new ValueError(`The Array 'inputs' and 'mask' are expected to have the same ` +\n                    `length, but have different lengths ` +\n                    `(${inputs.length} vs ${mask.length})`);\n            }\n            if (mask.every(m => m == null)) {\n                return null;\n            }\n            mask = mask.map(m => m == null ? m : tfc.expandDims(m, 0));\n            let output = mask[0];\n            for (let i = 1; i < mask.length - 1; ++i) {\n                output = tfc.logicalAnd(output, mask[i]);\n            }\n            return output;\n        });\n    }\n}\nexport class Add extends Merge {\n    constructor(args) {\n        super(args);\n    }\n    mergeFunction(inputs) {\n        return tidy(() => {\n            let output = inputs[0].clone();\n            for (let i = 1; i < inputs.length; ++i) {\n                output = tfc.add(output, inputs[i]);\n            }\n            return output;\n        });\n    }\n}\n/** @nocollapse */\nAdd.className = 'Add';\nserialization.registerClass(Add);\n/**\n * Calculate the element-wise sum of inputs, which all have the same shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Add` layer, by using no input argument\n *    or a single configuration argument. The resultant `Add` layer can then\n *    be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const addLayer = tf.layers.add();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = addLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.add([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n * const input2 = tf.tensor2d([10, 20, 30, 40], [2, 2]);\n * tf.layers.add([input1, input2]).print();\n * // Gives [[11, 22], [33, 44]].\n *\n */\nexport function add(config) {\n    if (Array.isArray(config)) {\n        const layer = new Add({});\n        return layer.apply(config);\n    }\n    else {\n        return new Add(config);\n    }\n}\nexport class Multiply extends Merge {\n    constructor(args) {\n        super(args);\n    }\n    mergeFunction(inputs) {\n        return tidy(() => {\n            let output = inputs[0].clone();\n            for (let i = 1; i < inputs.length; ++i) {\n                output = tfc.mul(output, inputs[i]);\n            }\n            return output;\n        });\n    }\n}\n/** @nocollapse */\nMultiply.className = 'Multiply';\nserialization.registerClass(Multiply);\n/**\n * Calculate the element-wise product of inputs, which all have the same shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Multiply` layer, by using no input argument\n *    or a single configuration argument. The resultant `Multiply` layer can\n *    then be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const multiplyLayer = tf.layers.multiply();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = multiplyLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.multiply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n * const input2 = tf.tensor2d([10, 20, 30, 40], [2, 2]);\n * tf.layers.multiply([input1, input2]).print();\n * // Gives [[10, 40], [90, 160]].\n *\n */\nexport function multiply(config) {\n    if (Array.isArray(config)) {\n        const layer = new Multiply({});\n        return layer.apply(config);\n    }\n    else {\n        return new Multiply(config);\n    }\n}\nexport class Average extends Merge {\n    constructor(args) {\n        super(args);\n    }\n    mergeFunction(inputs) {\n        return tidy(() => {\n            let output = inputs[0].clone();\n            for (let i = 1; i < inputs.length; ++i) {\n                output = tfc.add(output, inputs[i]);\n            }\n            return tfc.mul(1 / inputs.length, output);\n        });\n    }\n}\n/** @nocollapse */\nAverage.className = 'Average';\nserialization.registerClass(Average);\n/**\n * Calculate the element-wise arithmetic mean of inputs, which all have the same\n * shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Average` layer, by using no input argument\n *    or a single configuration argument. The resultant `Average` layer can then\n *    be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const averageLayer = tf.layers.average();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = averageLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.average([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n * const input2 = tf.tensor2d([10, 20, 30, 40], [2, 2]);\n * tf.layers.average([input1, input2]).print();\n * // Gives [[5.5, 11], [16.5, 22]].\n *\n */\nexport function average(config) {\n    if (Array.isArray(config)) {\n        const layer = new Average({});\n        return layer.apply(config);\n    }\n    else {\n        return new Average(config);\n    }\n}\nexport class Maximum extends Merge {\n    constructor(args) {\n        super(args);\n    }\n    mergeFunction(inputs) {\n        return tidy(() => {\n            let output = inputs[0];\n            for (let i = 1; i < inputs.length; ++i) {\n                output = tfc.maximum(output, inputs[i]);\n            }\n            return output;\n        });\n    }\n}\n/** @nocollapse */\nMaximum.className = 'Maximum';\nserialization.registerClass(Maximum);\n/**\n * Calculate the element-wise maximum of inputs, which all have the same shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Maximum` layer, by using no input argument\n *    or a single configuration argument. The resultant `Maximum` layer can then\n *    be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const maximumLayer = tf.layers.maximum();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = maximumLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.maximum([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 20, 3, 40], [2, 2]);\n * const input2 = tf.tensor2d([10, 2, 30, 4], [2, 2]);\n * tf.layers.maximum([input1, input2]).print();\n * // Gives [[10, 20], [30, 40]].\n *\n */\nexport function maximum(config) {\n    if (Array.isArray(config)) {\n        const layer = new Maximum({});\n        return layer.apply(config);\n    }\n    else {\n        return new Maximum(config);\n    }\n}\nexport class Minimum extends Merge {\n    constructor(args) {\n        super(args);\n    }\n    mergeFunction(inputs) {\n        return tidy(() => {\n            let output = inputs[0];\n            for (let i = 1; i < inputs.length; ++i) {\n                output = tfc.minimum(output, inputs[i]);\n            }\n            return output;\n        });\n    }\n}\n/** @nocollapse */\nMinimum.className = 'Minimum';\nserialization.registerClass(Minimum);\n/**\n * Calculate the element-wise minimum of inputs, which all have the same shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Minimum` layer, by using no input argument\n *    or a single configuration argument. The resultant `Minimum` layer can then\n *    be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const minimumLayer = tf.layers.minimum();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = minimumLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.minimum([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 20, 3, 40], [2, 2]);\n * const input2 = tf.tensor2d([10, 2, 30, 4], [2, 2]);\n * tf.layers.minimum([input1, input2]).print();\n * // Gives [[1, 2], [3, 4]].\n *\n */\nexport function minimum(config) {\n    if (Array.isArray(config)) {\n        const layer = new Minimum({});\n        return layer.apply(config);\n    }\n    else {\n        return new Minimum(config);\n    }\n}\nexport class Concatenate extends Merge {\n    constructor(args) {\n        super(args);\n        this.DEFAULT_AXIS = -1;\n        if (args == null) {\n            args = {};\n        }\n        this.axis = args.axis == null ? this.DEFAULT_AXIS : args.axis;\n        this.supportsMasking = true;\n        this.reshapeRequired = false;\n    }\n    build(inputShape) {\n        // Used purely for shape validation.]\n        if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0])) ||\n            inputShape.length === 1) {\n            throw new ValueError('A `Concatenate` layer should be called on a list of at least 2 ' +\n                'inputs');\n        }\n        inputShape = inputShape;\n        let allNoneShape = true;\n        for (const shape of inputShape) {\n            if (shape != null) {\n                allNoneShape = false;\n                break;\n            }\n        }\n        if (allNoneShape) {\n            return;\n        }\n        const shapeSet = [];\n        for (let i = 0; i < inputShape.length; ++i) {\n            const shapeWithoutConcatAxis = inputShape[i].slice();\n            shapeWithoutConcatAxis.splice(this.axis, 1);\n            let exists = false;\n            for (const shape of shapeSet) {\n                if (util.arraysEqual(shape, shapeWithoutConcatAxis)) {\n                    exists = true;\n                    break;\n                }\n            }\n            if (!exists) {\n                shapeSet.push(shapeWithoutConcatAxis);\n            }\n        }\n        if (shapeSet.length > 1) {\n            throw new ValueError('A `Concatenate` layer requires inputs with matching shapes ' +\n                'except for the concat axis. Got input shapes: ' +\n                JSON.stringify(inputShape));\n        }\n    }\n    mergeFunction(inputs) {\n        return tidy(() => {\n            return K.concatenate(inputs, this.axis);\n        });\n    }\n    computeOutputShape(inputShape) {\n        if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0]))) {\n            throw new ValueError('A `Concatenate` layer should be called on a list of inputs.');\n        }\n        const inputShapes = inputShape;\n        const outputShape = inputShapes[0].slice();\n        const axis = this.axis < 0 ? outputShape.length + this.axis : this.axis;\n        // Porting Note: the line above is because TypeScript doesn't support\n        //   negative indices.\n        for (const shape of inputShapes.slice(1)) {\n            if (outputShape[axis] == null || shape[axis] == null) {\n                outputShape[axis] = null;\n                break;\n            }\n            outputShape[axis] += shape[axis];\n        }\n        return outputShape;\n    }\n    computeMask(inputs, mask) {\n        if (mask == null) {\n            return null;\n        }\n        if (!Array.isArray(mask)) {\n            throw new ValueError('`mask` should be an array for Concatenate');\n        }\n        if (!Array.isArray(inputs)) {\n            throw new ValueError('`inputs` should be an array for Concatenate');\n        }\n        if (mask.length !== inputs.length) {\n            throw new ValueError(`Mismatch in the length of mask (${mask.length}) ` +\n                `and the legnth of inputs (${inputs.length})`);\n        }\n        return tfc.tidy(() => {\n            let allNullMasks = true;\n            mask.forEach(m => {\n                if (m != null) {\n                    allNullMasks = false;\n                    return;\n                }\n            });\n            if (allNullMasks) {\n                return null;\n            }\n            const outputMasks = [];\n            for (let i = 0; i < inputs.length; ++i) {\n                if (mask[i] == null) {\n                    // Input is unmasked. Append all 1's to masks.\n                    outputMasks.push(tfc.onesLike(inputs[i]).asType('bool'));\n                }\n                else if (mask[i].rank < inputs[i].rank) {\n                    // Mask is smaller than the input, expand it.\n                    outputMasks.push(tfc.expandDims(mask[i], -1));\n                }\n                else {\n                    outputMasks.push(mask[i]);\n                }\n            }\n            const concatenatedMasks = tfc.concat(outputMasks, this.axis);\n            return tfc.all(concatenatedMasks, -1, false);\n        });\n    }\n    getConfig() {\n        const config = {\n            'axis': this.axis,\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\n/** @nocollapse */\nConcatenate.className = 'Concatenate';\nserialization.registerClass(Concatenate);\n/**\n * Concatenate an `Array` of inputs.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Concatenate` layer, by using no input argument\n *    or a single configuration argument. The resultant `Concatenate` layer can\n *    then be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const concatLayer = tf.layers.concatenate();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 3]});\n * const input2 = tf.input({shape: [2, 4]});\n * const output = concatLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 7], with the first dimension as the undetermined batch\n * // dimension and the last dimension as the result of concatenating the\n * // last dimensions of the two inputs.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 3]});\n * const input2 = tf.input({shape: [2, 4]});\n * const output = tf.layers.concatenate([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension and the last dimension as the result of concatenating the\n * // last dimensions of the two inputs.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([[1, 2], [3, 4]], [2, 2]);\n * const input2 = tf.tensor2d([[10, 20], [30, 40]], [2, 2]);\n * tf.layers.concatenate([input1, input2]).print();\n * // Gives [[1, 2, 10, 20], [3, 4, 30, 40]].\n *\n */\nexport function concatenate(config) {\n    if (Array.isArray(config)) {\n        const layer = new Concatenate({});\n        return layer.apply(config);\n    }\n    else {\n        return new Concatenate(config);\n    }\n}\n/**\n * Interpretable potentially negative axis index.\n *\n * For example, given axis = -1, and dim = 3, this function will return 2.\n *\n * @param axis The axis index, may be a positive, zero or negative integer.\n * @param dim Total number of dimensions, a positive integer.\n * @returns A non-negative axis index equivalent to the input `axis`.\n */\nfunction interpretAxis(axis, dim) {\n    while (axis < 0) {\n        axis += dim;\n    }\n    return axis;\n}\nfunction batchDot(x, y, axes) {\n    if (x.shape.length > 3 || y.shape.length > 3) {\n        throw new NotImplementedError('batchDot is not implemented for tensors of 4D or higher rank yet');\n    }\n    tfc.util.assert(x.shape.length >= 2, () => `batchDot requires the rank of x to be >= 2, ` +\n        `but got ${x.shape.length}`);\n    tfc.util.assert(x.shape.length >= 2, () => `batchDot requires the rank of y to be >= 2, ` +\n        `but got ${y.shape.length}`);\n    if (typeof axes === 'number') {\n        axes = [axes, axes];\n    }\n    if (x.dtype === 'complex64' || y.dtype === 'complex64') {\n        throw new NotImplementedError('batchDot is not implemented for complex64-type Tensors yet.');\n    }\n    const xNDim = x.shape.length;\n    const yNDim = y.shape.length;\n    if (axes == null) {\n        // Behave like batchMatmul by default.\n        axes = [xNDim - 1, yNDim - 2];\n    }\n    const axesArray = axes;\n    return tfc.tidy(() => {\n        let diff;\n        if (xNDim > yNDim) {\n            diff = xNDim - yNDim;\n            const diffShape = [];\n            for (let i = 0; i < diff; ++i) {\n                diffShape.push(1);\n            }\n            y = y.reshape(y.shape.concat(diffShape));\n        }\n        else if (yNDim > xNDim) {\n            diff = yNDim - xNDim;\n            const diffShape = [];\n            for (let i = 0; i < diff; ++i) {\n                diffShape.push(1);\n            }\n            x = x.reshape(x.shape.concat(diffShape));\n        }\n        else {\n            diff = 0;\n        }\n        let out;\n        if (x.shape.length === 2 && y.shape.length === 2) {\n            if (axesArray[0] === axesArray[1]) {\n                out = x.mul(y).sum(axesArray[0]);\n            }\n            else {\n                out = x.transpose([1, 0]).mul(y).sum(axesArray[1]);\n            }\n        }\n        else {\n            const adjX = axesArray[0] !== x.shape.length - 1;\n            const adjY = axesArray[1] === y.shape.length - 1;\n            out = x.matMul(y, adjX, adjY);\n        }\n        if (diff > 0) {\n            let idx;\n            if (xNDim > yNDim) {\n                idx = xNDim + yNDim - 3;\n            }\n            else {\n                idx = xNDim - 1;\n            }\n            const squeezeAxes = [];\n            for (let i = idx; i < idx + diff; ++i) {\n                squeezeAxes.push(i);\n            }\n            out = out.squeeze(squeezeAxes);\n        }\n        if (out.shape.length === 1) {\n            out = out.expandDims(1);\n        }\n        return out;\n    });\n}\nexport class Dot extends Merge {\n    constructor(args) {\n        super(args);\n        this.axes = args.axes;\n        this.normalize = args.normalize == null ? false : args.normalize;\n        this.supportsMasking = true;\n        this.reshapeRequired = false;\n    }\n    build(inputShape) {\n        tfc.util.assert(Array.isArray(inputShape) && inputShape.length === 2 &&\n            Array.isArray(inputShape[0]) && Array.isArray(inputShape[1]), () => 'A `Dot` layer should be called on a list of exactly 2 inputs.');\n        const shape1 = inputShape[0];\n        const shape2 = inputShape[1];\n        if (shape1.length > 3 || shape2.length > 3) {\n            throw new NotImplementedError('Dot layer does not support tensors of 4D or higher rank yet.');\n        }\n        const axes = this.interpretAxes(shape1, shape2);\n        if (shape1[axes[0]] !== shape2[axes[1]]) {\n            throw new ValueError(`Dimension incompatibility: ` +\n                `${shape1[axes[0]]} !== ${shape2[axes[1]]}`);\n        }\n    }\n    mergeFunction(inputs) {\n        if (inputs.length !== 2) {\n            throw new ValueError('A `Dot` layer must be called on exactly 2 inputs, ' +\n                `but received ${inputs.length} input(s).`);\n        }\n        let x1 = inputs[0];\n        let x2 = inputs[1];\n        let axes;\n        if (!Array.isArray(this.axes)) {\n            axes = [\n                interpretAxis(this.axes, x1.shape.length),\n                interpretAxis(this.axes, x2.shape.length)\n            ];\n        }\n        else {\n            axes = this.axes.map((axis, i) => interpretAxis(axis, inputs[i].shape.length));\n        }\n        if (this.normalize) {\n            x1 = l2Normalize(x1, axes[0]);\n            x2 = l2Normalize(x2, axes[1]);\n        }\n        return batchDot(x1, x2, axes);\n    }\n    interpretAxes(shape1, shape2) {\n        let axes;\n        if (!Array.isArray(this.axes)) {\n            // `this.axes` is a single integer.\n            axes = [\n                interpretAxis(this.axes, shape1.length),\n                interpretAxis(this.axes, shape2.length)\n            ];\n        }\n        else {\n            // `this.axes` is an Array of integers.\n            axes = this.axes;\n        }\n        return axes;\n    }\n    computeOutputShape(inputShape) {\n        tfc.util.assert(Array.isArray(inputShape) && inputShape.length === 2 &&\n            Array.isArray(inputShape[0]) && Array.isArray(inputShape[1]), () => 'A `Dot` layer should be called on a list of exactly 2 inputs.');\n        const shape1 = inputShape[0].slice();\n        const shape2 = inputShape[1].slice();\n        if (shape1.length > 3 || shape2.length > 3) {\n            throw new NotImplementedError('Dot layer does not support tensors of 4D or higher rank yet.');\n        }\n        const axes = this.interpretAxes(shape1, shape2);\n        shape1.splice(axes[0], 1);\n        shape2.splice(axes[1], 1);\n        shape2.splice(0, 1);\n        const outputShape = shape1.concat(shape2);\n        if (outputShape.length === 1) {\n            outputShape.push(1);\n        }\n        return outputShape;\n    }\n    computeMask(inputs, mask) {\n        return null;\n    }\n    getConfig() {\n        const config = {\n            'axes': this.axes,\n            'normalize': this.normalize\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\n/** @nocollapse */\nDot.className = 'Dot';\nserialization.registerClass(Dot);\n// TODO(cais): Add functional interfaces for the merge layers.\n//# sourceMappingURL=merge.js.map"]},"metadata":{},"sourceType":"module"}