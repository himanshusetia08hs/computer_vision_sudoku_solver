{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { UnsortedSegmentSum, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { cast } from './Cast';\nimport { equal } from './Equal';\nimport { expandDims } from './ExpandDims';\nimport { multiply } from './Multiply';\nimport { pack } from './Pack';\nimport { sum } from './Sum';\nexport function unsortedSegmentSum(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    x,\n    segmentIds\n  } = inputs;\n  const {\n    numSegments\n  } = attrs;\n  assertNotComplex(x, 'unsortedSegmentSum');\n  const xRank = x.shape.length;\n  const segmentIdsRank = segmentIds.shape.length;\n  const res = [];\n  const intermediates = [];\n  // Reshape the segment id's so that they can be broadcast with\n  // x. The new shape should be [segmentIds.shape, 1, ..., 1]\n  const numIters = xRank - segmentIdsRank;\n  let $segmentIds = segmentIds;\n  for (let i = 0; i < numIters; ++i) {\n    const expanded = expandDims({\n      inputs: {\n        input: $segmentIds\n      },\n      backend,\n      attrs: {\n        dim: i + 1\n      }\n    });\n    $segmentIds = expanded;\n    intermediates.push(expanded);\n  }\n  for (let i = 0; i < numSegments; ++i) {\n    const scalarValue = util.createScalarValue(i, 'int32');\n    const segmentId = backend.makeTensorInfo([], 'int32', scalarValue);\n    const mask = equal({\n      inputs: {\n        a: segmentId,\n        b: $segmentIds\n      },\n      backend\n    });\n    const maskCasted = cast({\n      inputs: {\n        x: mask\n      },\n      backend,\n      attrs: {\n        dtype: 'float32'\n      }\n    });\n    const mul = multiply({\n      inputs: {\n        a: maskCasted,\n        b: x\n      },\n      backend\n    });\n    const sumTensorInfo = sum({\n      inputs: {\n        x: mul\n      },\n      backend,\n      attrs: {\n        axis: 0,\n        keepDims: false\n      }\n    });\n    res.push(sumTensorInfo);\n    intermediates.push(segmentId);\n    intermediates.push(mask);\n    intermediates.push(maskCasted);\n    intermediates.push(mul);\n    intermediates.push(sumTensorInfo);\n  }\n  const result = pack({\n    inputs: res,\n    backend,\n    attrs: {\n      axis: 0\n    }\n  });\n  intermediates.forEach(t => backend.disposeIntermediateTensorInfo(t));\n  return result;\n}\nexport const unsortedSegmentSumConfig = {\n  kernelName: UnsortedSegmentSum,\n  backendName: 'cpu',\n  kernelFunc: unsortedSegmentSum\n};","map":{"version":3,"sources":["../../src/kernels/UnsortedSegmentSum.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { UnsortedSegmentSum, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { cast } from './Cast';\nimport { equal } from './Equal';\nimport { expandDims } from './ExpandDims';\nimport { multiply } from './Multiply';\nimport { pack } from './Pack';\nimport { sum } from './Sum';\nexport function unsortedSegmentSum(args) {\n    const { inputs, backend, attrs } = args;\n    const { x, segmentIds } = inputs;\n    const { numSegments } = attrs;\n    assertNotComplex(x, 'unsortedSegmentSum');\n    const xRank = x.shape.length;\n    const segmentIdsRank = segmentIds.shape.length;\n    const res = [];\n    const intermediates = [];\n    // Reshape the segment id's so that they can be broadcast with\n    // x. The new shape should be [segmentIds.shape, 1, ..., 1]\n    const numIters = xRank - segmentIdsRank;\n    let $segmentIds = segmentIds;\n    for (let i = 0; i < numIters; ++i) {\n        const expanded = expandDims({ inputs: { input: $segmentIds }, backend, attrs: { dim: i + 1 } });\n        $segmentIds = expanded;\n        intermediates.push(expanded);\n    }\n    for (let i = 0; i < numSegments; ++i) {\n        const scalarValue = util.createScalarValue(i, 'int32');\n        const segmentId = backend.makeTensorInfo([], 'int32', scalarValue);\n        const mask = equal({ inputs: { a: segmentId, b: $segmentIds }, backend });\n        const maskCasted = cast({ inputs: { x: mask }, backend, attrs: { dtype: 'float32' } });\n        const mul = multiply({ inputs: { a: maskCasted, b: x }, backend });\n        const sumTensorInfo = sum({ inputs: { x: mul }, backend, attrs: { axis: 0, keepDims: false } });\n        res.push(sumTensorInfo);\n        intermediates.push(segmentId);\n        intermediates.push(mask);\n        intermediates.push(maskCasted);\n        intermediates.push(mul);\n        intermediates.push(sumTensorInfo);\n    }\n    const result = pack({ inputs: res, backend, attrs: { axis: 0 } });\n    intermediates.forEach(t => backend.disposeIntermediateTensorInfo(t));\n    return result;\n}\nexport const unsortedSegmentSumConfig = {\n    kernelName: UnsortedSegmentSum,\n    backendName: 'cpu',\n    kernelFunc: unsortedSegmentSum\n};\n//# sourceMappingURL=UnsortedSegmentSum.js.map"]},"metadata":{},"sourceType":"module"}