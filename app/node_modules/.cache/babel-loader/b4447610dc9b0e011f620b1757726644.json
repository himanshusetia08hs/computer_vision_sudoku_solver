{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { cast } from '../ops/cast';\nimport { scalar } from '../ops/scalar';\nimport { zeros } from '../ops/zeros';\nimport { decodeString, encodeString, hasEncodingLoss } from '../util';\n// Utilities needed by backend consumers of tf-core.\nexport * from '../ops/axis_util';\nexport * from '../ops/broadcast_util';\nexport * from '../ops/concat_util';\nexport * from '../ops/conv_util';\nexport * from '../ops/fused_util';\nexport * from '../ops/reduce_util';\nimport * as slice_util from '../ops/slice_util';\nexport { slice_util };\nexport { upcastType } from '../types';\nexport * from '../ops/rotate_util';\nexport * from '../ops/array_ops_util';\nexport * from '../ops/gather_nd_util';\nexport * from '../ops/scatter_nd_util';\nexport * from '../ops/selu_util';\nexport * from '../ops/fused_util';\nexport * from '../ops/erf_util';\nexport * from '../log';\nexport * from '../backends/complex_util';\nexport * from '../ops/split_util';\nimport * as segment_util from '../ops/segment_util';\nexport { segment_util };\nexport function castTensor(x, dtype, backend) {\n  if (dtype === 'complex64') {\n    if (x.dtype === 'complex64') {\n      return x.clone();\n    }\n    const zerosTensor = zeros(x.shape);\n    const floatX = cast(x, 'float32');\n    const result = backend.complex(floatX, zerosTensor);\n    zerosTensor.dispose();\n    floatX.dispose();\n    return result;\n  }\n  if (!hasEncodingLoss(x.dtype, dtype)) {\n    // We don't change the underlying data, since we cast to higher\n    // precision.\n    return ENGINE.makeTensorFromDataId(x.dataId, x.shape, dtype);\n  }\n  if (x.dtype === 'complex64') {\n    const real = backend.real(x);\n    const result = cast(real, dtype);\n    real.dispose();\n    return result;\n  }\n  if (dtype === 'int32') {\n    return backend.int(x);\n  } else if (dtype === 'bool') {\n    const zero = scalar(0, x.dtype);\n    const result = backend.notEqual(x, zero);\n    zero.dispose();\n    return result;\n  } else {\n    throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);\n  }\n}\nexport function reshapeTensor(x, shape) {\n  return ENGINE.makeTensorFromDataId(x.dataId, shape, x.dtype);\n}\nexport function fromUint8ToStringArray(vals) {\n  try {\n    // Decode the bytes into string.\n    return vals.map(val => decodeString(val));\n  } catch (err) {\n    throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${err}`);\n  }\n}\nexport function fromStringArrayToUint8(strings) {\n  return strings.map(s => encodeString(s));\n}","map":{"version":3,"sources":["../../src/backends/backend_util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { cast } from '../ops/cast';\nimport { scalar } from '../ops/scalar';\nimport { zeros } from '../ops/zeros';\nimport { decodeString, encodeString, hasEncodingLoss } from '../util';\n// Utilities needed by backend consumers of tf-core.\nexport * from '../ops/axis_util';\nexport * from '../ops/broadcast_util';\nexport * from '../ops/concat_util';\nexport * from '../ops/conv_util';\nexport * from '../ops/fused_util';\nexport * from '../ops/reduce_util';\nimport * as slice_util from '../ops/slice_util';\nexport { slice_util };\nexport { upcastType } from '../types';\nexport * from '../ops/rotate_util';\nexport * from '../ops/array_ops_util';\nexport * from '../ops/gather_nd_util';\nexport * from '../ops/scatter_nd_util';\nexport * from '../ops/selu_util';\nexport * from '../ops/fused_util';\nexport * from '../ops/erf_util';\nexport * from '../log';\nexport * from '../backends/complex_util';\nexport * from '../ops/split_util';\nimport * as segment_util from '../ops/segment_util';\nexport { segment_util };\nexport function castTensor(x, dtype, backend) {\n    if (dtype === 'complex64') {\n        if (x.dtype === 'complex64') {\n            return x.clone();\n        }\n        const zerosTensor = zeros(x.shape);\n        const floatX = cast(x, 'float32');\n        const result = backend.complex(floatX, zerosTensor);\n        zerosTensor.dispose();\n        floatX.dispose();\n        return result;\n    }\n    if (!hasEncodingLoss(x.dtype, dtype)) {\n        // We don't change the underlying data, since we cast to higher\n        // precision.\n        return ENGINE.makeTensorFromDataId(x.dataId, x.shape, dtype);\n    }\n    if (x.dtype === 'complex64') {\n        const real = backend.real(x);\n        const result = cast(real, dtype);\n        real.dispose();\n        return result;\n    }\n    if (dtype === 'int32') {\n        return backend.int(x);\n    }\n    else if (dtype === 'bool') {\n        const zero = scalar(0, x.dtype);\n        const result = backend.notEqual(x, zero);\n        zero.dispose();\n        return result;\n    }\n    else {\n        throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);\n    }\n}\nexport function reshapeTensor(x, shape) {\n    return ENGINE.makeTensorFromDataId(x.dataId, shape, x.dtype);\n}\nexport function fromUint8ToStringArray(vals) {\n    try {\n        // Decode the bytes into string.\n        return vals.map(val => decodeString(val));\n    }\n    catch (err) {\n        throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${err}`);\n    }\n}\nexport function fromStringArrayToUint8(strings) {\n    return strings.map(s => encodeString(s));\n}\n//# sourceMappingURL=backend_util.js.map"]},"metadata":{},"sourceType":"module"}