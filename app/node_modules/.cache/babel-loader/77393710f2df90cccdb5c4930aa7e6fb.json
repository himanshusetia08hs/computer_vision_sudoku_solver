{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, SparseFillEmptyRows } from '@tensorflow/tfjs-core';\nimport { slice } from './Slice';\nimport { CppDType } from './types';\nlet wasmSparseFillEmptyRows;\nexport function setup(backend) {\n  wasmSparseFillEmptyRows = backend.wasm.cwrap('SparseFillEmptyRows', 'number', ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number' // exceptionValuesId\n  ]);\n}\n\nexport function sparseFillEmptyRows(args) {\n  const {\n    backend,\n    inputs\n  } = args;\n  const {\n    indices,\n    values,\n    denseShape,\n    defaultValue\n  } = inputs;\n  const indicesCount = indices.shape[0];\n  const rank = indices.shape[1];\n  const denseRows = backend.readSync(denseShape.dataId)[0];\n  // Set output size to maximum possible and resize later (actual result\n  // might be smaller).\n  const maxOutputIndicesShape = [indicesCount + denseRows, rank];\n  const indicesId = backend.dataIdMap.get(indices.dataId).id;\n  const valuesId = backend.dataIdMap.get(values.dataId).id;\n  const defaultValueId = backend.dataIdMap.get(defaultValue.dataId).id;\n  const outputIndices = backend.makeOutput(maxOutputIndicesShape, indices.dtype);\n  const outputIndicesId = backend.dataIdMap.get(outputIndices.dataId).id;\n  const outputValues = backend.makeOutput(maxOutputIndicesShape.slice(0, 1), values.dtype);\n  const outputValuesId = backend.dataIdMap.get(outputValues.dataId).id;\n  const emptyRowIndicator = backend.makeOutput([denseRows], 'bool');\n  const emptyRowIndicatorId = backend.dataIdMap.get(emptyRowIndicator.dataId).id;\n  const reverseIndexMap = backend.makeOutput([indicesCount], indices.dtype);\n  const reverseIndexMapId = backend.dataIdMap.get(reverseIndexMap.dataId).id;\n  const exceptionValues = backend.makeOutput([4], 'int32');\n  const exceptionValuesId = backend.dataIdMap.get(exceptionValues.dataId).id;\n  const outputRows = wasmSparseFillEmptyRows(indicesId, valuesId, CppDType[values.dtype], indicesCount, denseRows, rank, defaultValueId, outputIndicesId, outputValuesId, emptyRowIndicatorId, reverseIndexMapId, exceptionValuesId);\n  const exceptionValuesArray = backend.readSync(exceptionValues.dataId);\n  let exceptionMessage;\n  switch (exceptionValuesArray[0]) {\n    case 1:\n      {\n        exceptionMessage = backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(exceptionValuesArray[1]);\n        break;\n      }\n    case 2:\n      {\n        exceptionMessage = backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(exceptionValuesArray[1], exceptionValuesArray[2]);\n        break;\n      }\n    case 3:\n      exceptionMessage = backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(exceptionValuesArray[1], exceptionValuesArray[2], exceptionValuesArray[3]);\n      break;\n    default:\n      exceptionMessage = '';\n  }\n  backend.disposeData(exceptionValues.dataId);\n  if (exceptionMessage) {\n    backend.disposeData(outputIndices.dataId);\n    backend.disposeData(outputValues.dataId);\n    backend.disposeData(emptyRowIndicator.dataId);\n    backend.disposeData(reverseIndexMap.dataId);\n    throw new Error(exceptionMessage);\n  }\n  let resizedIndices = outputIndices;\n  let resizedValues = outputValues;\n  // Overestimated output size.\n  if (outputRows !== maxOutputIndicesShape[0]) {\n    resizedIndices = slice({\n      inputs: {\n        x: outputIndices\n      },\n      attrs: {\n        begin: 0,\n        size: [outputRows, rank]\n      },\n      backend\n    });\n    resizedValues = slice({\n      inputs: {\n        x: outputValues\n      },\n      attrs: {\n        begin: 0,\n        size: outputRows\n      },\n      backend\n    });\n    backend.disposeData(outputIndices.dataId);\n    backend.disposeData(outputValues.dataId);\n  }\n  return [resizedIndices, resizedValues, emptyRowIndicator, reverseIndexMap];\n}\nexport const sparseFillEmptyRowsConfig = {\n  kernelName: SparseFillEmptyRows,\n  backendName: 'wasm',\n  setupFunc: setup,\n  kernelFunc: sparseFillEmptyRows\n};","map":{"version":3,"sources":["../../../../../../tfjs-backend-wasm/src/kernels/SparseFillEmptyRows.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, KernelFunc, SparseFillEmptyRows, SparseFillEmptyRowsInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {BackendWasm} from '../backend_wasm';\nimport {slice} from './Slice';\n\nimport {CppDType} from './types';\n\nlet wasmSparseFillEmptyRows: (\n    indicesId: number, valuesId: number, valuesDType: number,\n    indicesCount: number, denseRows: number, rank: number,\n    defaultValueId: number, outputIndicesId: number, outputValuesId: number,\n    emptyRowIndicatorId: number, reverseIndexMapId: number,\n    exceptionValuesId: number) => number;\n\nexport function setup(backend: BackendWasm): void {\n  wasmSparseFillEmptyRows =\n      backend.wasm.cwrap('SparseFillEmptyRows', 'number', [\n        'number',  // indicesId\n        'number',  // valuesId\n        'number',  // valuesDType\n        'number',  // indicesCount\n        'number',  // denseRows\n        'number',  // rank\n        'number',  // defaultValueId\n        'number',  // outputIndicesId\n        'number',  // outputValuesId\n        'number',  // emptyRowIndicatorId\n        'number',  // reverseIndexMapId\n        'number',  // exceptionValuesId\n      ]);\n}\n\nexport function sparseFillEmptyRows(args: {\n  backend: BackendWasm,\n  inputs: SparseFillEmptyRowsInputs,\n}): [TensorInfo, TensorInfo, TensorInfo, TensorInfo] {\n  const {backend, inputs} = args;\n  const {indices, values, denseShape, defaultValue} = inputs;\n\n  const indicesCount = indices.shape[0];\n  const rank = indices.shape[1];\n  const denseRows = backend.readSync(denseShape.dataId)[0] as number;\n\n  // Set output size to maximum possible and resize later (actual result\n  // might be smaller).\n  const maxOutputIndicesShape = [indicesCount + denseRows, rank];\n\n  const indicesId = backend.dataIdMap.get(indices.dataId).id;\n  const valuesId = backend.dataIdMap.get(values.dataId).id;\n  const defaultValueId = backend.dataIdMap.get(defaultValue.dataId).id;\n\n  const outputIndices =\n      backend.makeOutput(maxOutputIndicesShape, indices.dtype);\n  const outputIndicesId = backend.dataIdMap.get(outputIndices.dataId).id;\n\n  const outputValues =\n      backend.makeOutput(maxOutputIndicesShape.slice(0, 1), values.dtype);\n  const outputValuesId = backend.dataIdMap.get(outputValues.dataId).id;\n\n  const emptyRowIndicator = backend.makeOutput([denseRows], 'bool');\n  const emptyRowIndicatorId =\n      backend.dataIdMap.get(emptyRowIndicator.dataId).id;\n\n  const reverseIndexMap = backend.makeOutput([indicesCount], indices.dtype);\n  const reverseIndexMapId = backend.dataIdMap.get(reverseIndexMap.dataId).id;\n\n  const exceptionValues = backend.makeOutput([4], 'int32');\n  const exceptionValuesId = backend.dataIdMap.get(exceptionValues.dataId).id;\n\n  const outputRows = wasmSparseFillEmptyRows(\n      indicesId, valuesId, CppDType[values.dtype], indicesCount, denseRows,\n      rank, defaultValueId, outputIndicesId, outputValuesId,\n      emptyRowIndicatorId, reverseIndexMapId, exceptionValuesId);\n\n  const exceptionValuesArray =\n      backend.readSync(exceptionValues.dataId) as Int32Array;\n\n  let exceptionMessage: string;\n  switch (exceptionValuesArray[0]) {\n    case 1: {\n      exceptionMessage =\n          backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(\n              exceptionValuesArray[1]);\n      break;\n    }\n    case 2: {\n      exceptionMessage =\n          backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(\n              exceptionValuesArray[1], exceptionValuesArray[2]);\n      break;\n    }\n    case 3:\n      exceptionMessage =\n          backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(\n              exceptionValuesArray[1], exceptionValuesArray[2],\n              exceptionValuesArray[3]);\n      break;\n    default:\n      exceptionMessage = '';\n  }\n\n  backend.disposeData(exceptionValues.dataId);\n  if (exceptionMessage) {\n    backend.disposeData(outputIndices.dataId);\n    backend.disposeData(outputValues.dataId);\n    backend.disposeData(emptyRowIndicator.dataId);\n    backend.disposeData(reverseIndexMap.dataId);\n    throw new Error(exceptionMessage);\n  }\n\n  let resizedIndices = outputIndices;\n  let resizedValues = outputValues;\n  // Overestimated output size.\n  if (outputRows !== maxOutputIndicesShape[0]) {\n    resizedIndices = slice({\n      inputs: {x: outputIndices},\n      attrs: {begin: 0, size: [outputRows, rank]},\n      backend\n    });\n    resizedValues = slice({\n      inputs: {x: outputValues},\n      attrs: {begin: 0, size: outputRows},\n      backend\n    });\n    backend.disposeData(outputIndices.dataId);\n    backend.disposeData(outputValues.dataId);\n  }\n\n  return [resizedIndices, resizedValues, emptyRowIndicator, reverseIndexMap];\n}\n\nexport const sparseFillEmptyRowsConfig: KernelConfig = {\n  kernelName: SparseFillEmptyRows,\n  backendName: 'wasm',\n  setupFunc: setup,\n  kernelFunc: sparseFillEmptyRows as {} as KernelFunc\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}